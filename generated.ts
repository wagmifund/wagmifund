import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  BigDecimal: any;
  BigInt: any;
  /** Blockchain data scalar type */
  BlockchainData: any;
  /** Broadcast scalar id type */
  BroadcastId: any;
  Bytes: any;
  /** ChainId custom scalar type */
  ChainId: any;
  /** collect module data scalar type */
  CollectModuleData: any;
  /** ContentEncryptionKey scalar type */
  ContentEncryptionKey: any;
  /** Contract address custom scalar type */
  ContractAddress: any;
  /** create handle custom scalar type */
  CreateHandle: any;
  /** Cursor custom scalar type */
  Cursor: any;
  /** The da id */
  DataAvailabilityId: any;
  /** The javascript `Date` as string. Type represents date and time as the ISO Date string. */
  DateTime: any;
  /** EncryptedValue custom scalar type */
  EncryptedValueScalar: any;
  /** Ens custom scalar type */
  Ens: any;
  /** Ethereum address custom scalar type */
  EthereumAddress: any;
  /** follow module data scalar type */
  FollowModuleData: any;
  /** handle custom scalar type */
  Handle: any;
  /** handle claim id custom scalar type */
  HandleClaimIdScalar: any;
  /** image size transform custom scalar type */
  ImageSizeTransform: any;
  /**
   * 8 bytes signed integer
   *
   */
  Int8: any;
  /** Internal publication id custom scalar type */
  InternalPublicationId: any;
  /** IpfsCid scalar type */
  IpfsCid: any;
  /** jwt custom scalar type */
  Jwt: any;
  /** limit custom scalar type */
  LimitScalar: any;
  /** Locale scalar type */
  Locale: any;
  /** Markdown scalar type */
  Markdown: any;
  /** mimetype custom scalar type */
  MimeType: any;
  /** Nft gallery id type */
  NftGalleryId: any;
  /** Nft gallery name type */
  NftGalleryName: any;
  /** Nft ownership id type */
  NftOwnershipId: any;
  /** Nonce custom scalar type */
  Nonce: any;
  /** The notification id */
  NotificationId: any;
  /** ProfileId custom scalar type */
  ProfileId: any;
  /** ProfileInterest custom scalar type */
  ProfileInterest: any;
  /** proxy action scalar id type */
  ProxyActionId: any;
  /** Publication id custom scalar type */
  PublicationId: any;
  /** The publication tag */
  PublicationTag: any;
  /** Publication url scalar type */
  PublicationUrl: any;
  /** The reaction id */
  ReactionId: any;
  /** reference module data scalar type */
  ReferenceModuleData: any;
  /** Query search */
  Search: any;
  /** Relayer signature */
  Signature: any;
  /** Sources custom scalar type */
  Sources: any;
  /** timestamp date custom scalar type */
  TimestampScalar: any;
  /** The NFT token id */
  TokenId: any;
  /** The tx hash */
  TxHash: any;
  /** The tx id */
  TxId: any;
  /** UnixTimestamp custom scalar type */
  UnixTimestamp: any;
  /** Url scalar type */
  Url: any;
  /** Represents NULL values */
  Void: any;
};

export type AaveFeeCollectModuleParams = {
  /** The collect module amount info */
  amount: ModuleFeeAmountParams;
  /** The collect module limit */
  collectLimit?: InputMaybe<Scalars['String']>;
  /** The timestamp that this collect module will expire */
  endTimestamp?: InputMaybe<Scalars['DateTime']>;
  /** Follower only */
  followerOnly: Scalars['Boolean'];
  /** The collect module recipient address */
  recipient: Scalars['EthereumAddress'];
  /** The collect module referral fee */
  referralFee: Scalars['Float'];
};

export type AaveFeeCollectModuleSettings = {
  __typename?: 'AaveFeeCollectModuleSettings';
  /** The collect module amount info */
  amount: ModuleFeeAmount;
  /** The maximum number of collects for this publication. Omit for no limit. */
  collectLimit?: Maybe<Scalars['String']>;
  contractAddress: Scalars['ContractAddress'];
  /** The end timestamp after which collecting is impossible. No expiry if missing. */
  endTimestamp?: Maybe<Scalars['DateTime']>;
  /** True if only followers of publisher may collect the post. */
  followerOnly: Scalars['Boolean'];
  /** Recipient of collect fees. */
  recipient: Scalars['EthereumAddress'];
  /** The referral fee associated with this publication. */
  referralFee: Scalars['Float'];
  /** The collect modules enum */
  type: CollectModules;
};

/** The access conditions for the publication */
export type AccessConditionInput = {
  /** AND condition */
  and?: InputMaybe<AndConditionInput>;
  /** Profile follow condition */
  collect?: InputMaybe<CollectConditionInput>;
  /** EOA ownership condition */
  eoa?: InputMaybe<EoaOwnershipInput>;
  /** Profile follow condition */
  follow?: InputMaybe<FollowConditionInput>;
  /** NFT ownership condition */
  nft?: InputMaybe<NftOwnershipInput>;
  /** OR condition */
  or?: InputMaybe<OrConditionInput>;
  /** Profile ownership condition */
  profile?: InputMaybe<ProfileOwnershipInput>;
  /** ERC20 token ownership condition */
  token?: InputMaybe<Erc20OwnershipInput>;
};

/** The access conditions for the publication */
export type AccessConditionOutput = {
  __typename?: 'AccessConditionOutput';
  /** AND condition */
  and?: Maybe<AndConditionOutput>;
  /** Profile follow condition */
  collect?: Maybe<CollectConditionOutput>;
  /** EOA ownership condition */
  eoa?: Maybe<EoaOwnershipOutput>;
  /** Profile follow condition */
  follow?: Maybe<FollowConditionOutput>;
  /** NFT ownership condition */
  nft?: Maybe<NftOwnershipOutput>;
  /** OR condition */
  or?: Maybe<OrConditionOutput>;
  /** Profile ownership condition */
  profile?: Maybe<ProfileOwnershipOutput>;
  /** ERC20 token ownership condition */
  token?: Maybe<Erc20OwnershipOutput>;
};

/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type Account = {
  __typename?: 'Account';
  accountTokenSnapshots: Array<AccountTokenSnapshot>;
  createdAtBlockNumber: Scalars['BigInt'];
  createdAtTimestamp: Scalars['BigInt'];
  id: Scalars['ID'];
  inflows: Array<Stream>;
  /**
   * Indicates whether the address/account is a super app.
   *
   */
  isSuperApp: Scalars['Boolean'];
  outflows: Array<Stream>;
  publishedIndexes: Array<Index>;
  receivedTransferEvents: Array<TransferEvent>;
  sentTransferEvents: Array<TransferEvent>;
  subscriptions: Array<IndexSubscription>;
  tokenDowngradedEvents: Array<TokenDowngradedEvent>;
  tokenUpgradedEvents: Array<TokenUpgradedEvent>;
  updatedAtBlockNumber: Scalars['BigInt'];
  updatedAtTimestamp: Scalars['BigInt'];
};


/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountAccountTokenSnapshotsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenSnapshot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenSnapshot_Filter>;
};


/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountInflowsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Stream_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Stream_Filter>;
};


/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountOutflowsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Stream_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Stream_Filter>;
};


/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountPublishedIndexesArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Index_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<Index_Filter>;
};


/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountReceivedTransferEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TransferEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<TransferEvent_Filter>;
};


/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountSentTransferEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TransferEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<TransferEvent_Filter>;
};


/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountSubscriptionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexSubscription_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<IndexSubscription_Filter>;
};


/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountTokenDowngradedEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenDowngradedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<TokenDowngradedEvent_Filter>;
};


/**
 * Account: A higher order entity created for any addresses which interact with Superfluid contracts.
 *
 */
export type AccountTokenUpgradedEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenUpgradedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<TokenUpgradedEvent_Filter>;
};

/**
 * AccountTokenSnapshot: An aggregate entity which aggregates data between an `account`'s interaction with `token`.
 *
 */
export type AccountTokenSnapshot = {
  __typename?: 'AccountTokenSnapshot';
  account: Account;
  accountTokenSnapshotLogs: Array<AccountTokenSnapshotLog>;
  /**
   * The count of active incoming streams to this account.
   *
   */
  activeIncomingStreamCount: Scalars['Int'];
  /**
   * The count of active outgoing streams from this account.
   *
   */
  activeOutgoingStreamCount: Scalars['Int'];
  /**
   * Balance of `account` as of `updatedAtTimestamp`/`updatedAtBlock`.
   *
   */
  balanceUntilUpdatedAt: Scalars['BigInt'];
  flowOperators: Array<FlowOperator>;
  /**
   * ID composed of: accountID-tokenID
   *
   */
  id: Scalars['ID'];
  /**
   * The count of closed incoming streams by `account`.
   *
   */
  inactiveIncomingStreamCount: Scalars['Int'];
  /**
   * The count of closed outgoing streams by `account`.
   *
   */
  inactiveOutgoingStreamCount: Scalars['Int'];
  /**
   * isLiquidationEstimateOptimistic, If `totalSubscriptionsWithUnits > 0`, it is true.
   * "Optimistic" can be thought of as conservative as it refers to the earliest time the user may be liquidated as they may receive ongoing distributions which aren't tracked by the subgraph.
   *
   */
  isLiquidationEstimateOptimistic: Scalars['Boolean'];
  /**
   * Optimistic liquidation estimation property.
   *
   */
  maybeCriticalAtTimestamp?: Maybe<Scalars['BigInt']>;
  token: Token;
  /**
   * The total amount of `token` streamed into this `account` until the `updatedAtTimestamp`/`updatedAtBlock`.
   *
   */
  totalAmountStreamedInUntilUpdatedAt: Scalars['BigInt'];
  /**
   * The total amount of `token` streamed from this `account` until the `updatedAtTimestamp`/`updatedAtBlock`.
   *
   */
  totalAmountStreamedOutUntilUpdatedAt: Scalars['BigInt'];
  /**
   * The total amount of `token` streamed through this `account` until the `updatedAtTimestamp`/`updatedAtBlock`.
   *
   */
  totalAmountStreamedUntilUpdatedAt: Scalars['BigInt'];
  /**
   * The total amount of `token` this `account` has transferred.
   *
   */
  totalAmountTransferredUntilUpdatedAt: Scalars['BigInt'];
  /**
   * Counts all currently (as of updatedAt) approved subscriptions whether or not they have units.
   *
   */
  totalApprovedSubscriptions: Scalars['Int'];
  /**
   * The total deposit this account has held by the CFA agreement for `account` active streams.
   *
   */
  totalDeposit: Scalars['BigInt'];
  /**
   * The total inflow rate (receive flowRate per second) of the `account`.
   *
   */
  totalInflowRate: Scalars['BigInt'];
  /**
   * The total net flow rate of the `account` as of `updatedAtTimestamp`/`updatedAtBlock`.
   *
   */
  totalNetFlowRate: Scalars['BigInt'];
  /**
   * The count of currently open streams for an account, both incoming and outgoing.
   *
   */
  totalNumberOfActiveStreams: Scalars['Int'];
  /**
   * The count of closed streams by `account`, both incoming and outgoing.
   *
   */
  totalNumberOfClosedStreams: Scalars['Int'];
  /**
   * The total outflow rate (send flowrate per second) of the `account`.
   *
   */
  totalOutflowRate: Scalars['BigInt'];
  /**
   * The current (as of updatedAt) number of subscriptions with units allocated to them tied to this `account`.
   *
   */
  totalSubscriptionsWithUnits: Scalars['Int'];
  updatedAtBlockNumber: Scalars['BigInt'];
  updatedAtTimestamp: Scalars['BigInt'];
};


/**
 * AccountTokenSnapshot: An aggregate entity which aggregates data between an `account`'s interaction with `token`.
 *
 */
export type AccountTokenSnapshotAccountTokenSnapshotLogsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenSnapshotLog_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccountTokenSnapshotLog_Filter>;
};


/**
 * AccountTokenSnapshot: An aggregate entity which aggregates data between an `account`'s interaction with `token`.
 *
 */
export type AccountTokenSnapshotFlowOperatorsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<FlowOperator_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<FlowOperator_Filter>;
};

/**
 * AccountTokenSnapshotLog: Historical entries of `AccountTokenSnapshot` updates.
 *
 */
export type AccountTokenSnapshotLog = {
  __typename?: 'AccountTokenSnapshotLog';
  account: Account;
  accountTokenSnapshot: AccountTokenSnapshot;
  /**
   * The count of active incoming streams to this account.
   *
   */
  activeIncomingStreamCount: Scalars['Int'];
  /**
   * The count of active outgoing streams from this account.
   *
   */
  activeOutgoingStreamCount: Scalars['Int'];
  /**
   * Balance of `account` as of `timestamp`/`block`.
   *
   */
  balance: Scalars['BigInt'];
  blockNumber: Scalars['BigInt'];
  id: Scalars['ID'];
  /**
   * The count of closed incoming streams by `account`.
   *
   */
  inactiveIncomingStreamCount: Scalars['Int'];
  /**
   * The count of closed outgoing streams by `account`.
   *
   */
  inactiveOutgoingStreamCount: Scalars['Int'];
  logIndex: Scalars['BigInt'];
  /**
   * Optimistic liquidation estimation property.
   *
   */
  maybeCriticalAtTimestamp?: Maybe<Scalars['BigInt']>;
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  token: Token;
  /**
   * The total (as of timestamp) net amount of `token` streamed through this `account` until the `timestamp`/`block`.
   *
   */
  totalAmountStreamed: Scalars['BigInt'];
  /**
   * The total (as of timestamp) amount of `token` streamed into this `account` until the `timestamp`/`block`.
   *
   */
  totalAmountStreamedIn: Scalars['BigInt'];
  /**
   * The total (as of timestamp) amount of `token` streamed from this `account` until the `timestamp`/`block`.
   *
   */
  totalAmountStreamedOut: Scalars['BigInt'];
  /**
   * The total (as of timestamp) amount of `token` this `account` has transferred out until the `timestamp`/`block`.
   *
   */
  totalAmountTransferred: Scalars['BigInt'];
  /**
   * Counts all currently (as of timestamp) approved subscriptions whether or not they have units.
   *
   */
  totalApprovedSubscriptions: Scalars['Int'];
  /**
   * The total (as of timestamp) deposit this account has held by the CFA agreement for `account` active streams.
   *
   */
  totalDeposit: Scalars['BigInt'];
  /**
   * The total (as of timestamp) inflow rate (receive flowRate per second) of the `account`.
   *
   */
  totalInflowRate: Scalars['BigInt'];
  /**
   * The total (as of timestamp) net flow rate of the `account` as of `timestamp`/`block`.
   * This can be obtained by: `totalInflowRate - totalOutflowRate`
   *
   */
  totalNetFlowRate: Scalars['BigInt'];
  /**
   * The current (as of timestamp) number of open streams.
   *
   */
  totalNumberOfActiveStreams: Scalars['Int'];
  /**
   * The current (as of timestamp) count of closed streams.
   *
   */
  totalNumberOfClosedStreams: Scalars['Int'];
  /**
   * The total (as of timestamp) outflow rate (send flowrate per second) of the `account`.
   *
   */
  totalOutflowRate: Scalars['BigInt'];
  /**
   * The current (as of timestamp) number of subscriptions with units allocated to them tied to this `account`.
   *
   */
  totalSubscriptionsWithUnits: Scalars['Int'];
  transactionHash: Scalars['Bytes'];
  triggeredByEventName: Scalars['String'];
};

export type AccountTokenSnapshotLog_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_?: InputMaybe<AccountTokenSnapshot_Filter>;
  accountTokenSnapshot_contains?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_contains_nocase?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_ends_with?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_gt?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_gte?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_in?: InputMaybe<Array<Scalars['String']>>;
  accountTokenSnapshot_lt?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_lte?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_not?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_not_contains?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_not_ends_with?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountTokenSnapshot_not_starts_with?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_starts_with?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_?: InputMaybe<Account_Filter>;
  account_contains?: InputMaybe<Scalars['String']>;
  account_contains_nocase?: InputMaybe<Scalars['String']>;
  account_ends_with?: InputMaybe<Scalars['String']>;
  account_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_gt?: InputMaybe<Scalars['String']>;
  account_gte?: InputMaybe<Scalars['String']>;
  account_in?: InputMaybe<Array<Scalars['String']>>;
  account_lt?: InputMaybe<Scalars['String']>;
  account_lte?: InputMaybe<Scalars['String']>;
  account_not?: InputMaybe<Scalars['String']>;
  account_not_contains?: InputMaybe<Scalars['String']>;
  account_not_contains_nocase?: InputMaybe<Scalars['String']>;
  account_not_ends_with?: InputMaybe<Scalars['String']>;
  account_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_not_in?: InputMaybe<Array<Scalars['String']>>;
  account_not_starts_with?: InputMaybe<Scalars['String']>;
  account_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_starts_with?: InputMaybe<Scalars['String']>;
  account_starts_with_nocase?: InputMaybe<Scalars['String']>;
  activeIncomingStreamCount?: InputMaybe<Scalars['Int']>;
  activeIncomingStreamCount_gt?: InputMaybe<Scalars['Int']>;
  activeIncomingStreamCount_gte?: InputMaybe<Scalars['Int']>;
  activeIncomingStreamCount_in?: InputMaybe<Array<Scalars['Int']>>;
  activeIncomingStreamCount_lt?: InputMaybe<Scalars['Int']>;
  activeIncomingStreamCount_lte?: InputMaybe<Scalars['Int']>;
  activeIncomingStreamCount_not?: InputMaybe<Scalars['Int']>;
  activeIncomingStreamCount_not_in?: InputMaybe<Array<Scalars['Int']>>;
  activeOutgoingStreamCount?: InputMaybe<Scalars['Int']>;
  activeOutgoingStreamCount_gt?: InputMaybe<Scalars['Int']>;
  activeOutgoingStreamCount_gte?: InputMaybe<Scalars['Int']>;
  activeOutgoingStreamCount_in?: InputMaybe<Array<Scalars['Int']>>;
  activeOutgoingStreamCount_lt?: InputMaybe<Scalars['Int']>;
  activeOutgoingStreamCount_lte?: InputMaybe<Scalars['Int']>;
  activeOutgoingStreamCount_not?: InputMaybe<Scalars['Int']>;
  activeOutgoingStreamCount_not_in?: InputMaybe<Array<Scalars['Int']>>;
  and?: InputMaybe<Array<InputMaybe<AccountTokenSnapshotLog_Filter>>>;
  balance?: InputMaybe<Scalars['BigInt']>;
  balance_gt?: InputMaybe<Scalars['BigInt']>;
  balance_gte?: InputMaybe<Scalars['BigInt']>;
  balance_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balance_lt?: InputMaybe<Scalars['BigInt']>;
  balance_lte?: InputMaybe<Scalars['BigInt']>;
  balance_not?: InputMaybe<Scalars['BigInt']>;
  balance_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  inactiveIncomingStreamCount?: InputMaybe<Scalars['Int']>;
  inactiveIncomingStreamCount_gt?: InputMaybe<Scalars['Int']>;
  inactiveIncomingStreamCount_gte?: InputMaybe<Scalars['Int']>;
  inactiveIncomingStreamCount_in?: InputMaybe<Array<Scalars['Int']>>;
  inactiveIncomingStreamCount_lt?: InputMaybe<Scalars['Int']>;
  inactiveIncomingStreamCount_lte?: InputMaybe<Scalars['Int']>;
  inactiveIncomingStreamCount_not?: InputMaybe<Scalars['Int']>;
  inactiveIncomingStreamCount_not_in?: InputMaybe<Array<Scalars['Int']>>;
  inactiveOutgoingStreamCount?: InputMaybe<Scalars['Int']>;
  inactiveOutgoingStreamCount_gt?: InputMaybe<Scalars['Int']>;
  inactiveOutgoingStreamCount_gte?: InputMaybe<Scalars['Int']>;
  inactiveOutgoingStreamCount_in?: InputMaybe<Array<Scalars['Int']>>;
  inactiveOutgoingStreamCount_lt?: InputMaybe<Scalars['Int']>;
  inactiveOutgoingStreamCount_lte?: InputMaybe<Scalars['Int']>;
  inactiveOutgoingStreamCount_not?: InputMaybe<Scalars['Int']>;
  inactiveOutgoingStreamCount_not_in?: InputMaybe<Array<Scalars['Int']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  maybeCriticalAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  maybeCriticalAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  maybeCriticalAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  maybeCriticalAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  maybeCriticalAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  maybeCriticalAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  maybeCriticalAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  maybeCriticalAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  or?: InputMaybe<Array<InputMaybe<AccountTokenSnapshotLog_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  totalAmountStreamed?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedIn?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedIn_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedIn_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedIn_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountStreamedIn_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedIn_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedIn_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedIn_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountStreamedOut?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedOut_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedOut_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedOut_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountStreamedOut_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedOut_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedOut_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedOut_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountStreamed_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamed_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountStreamed_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamed_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamed_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountTransferred?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferred_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferred_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferred_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountTransferred_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferred_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferred_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferred_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalApprovedSubscriptions?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_gt?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_gte?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_in?: InputMaybe<Array<Scalars['Int']>>;
  totalApprovedSubscriptions_lt?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_lte?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_not?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalDeposit?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_gt?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_gte?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalDeposit_lt?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_lte?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_not?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalInflowRate?: InputMaybe<Scalars['BigInt']>;
  totalInflowRate_gt?: InputMaybe<Scalars['BigInt']>;
  totalInflowRate_gte?: InputMaybe<Scalars['BigInt']>;
  totalInflowRate_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalInflowRate_lt?: InputMaybe<Scalars['BigInt']>;
  totalInflowRate_lte?: InputMaybe<Scalars['BigInt']>;
  totalInflowRate_not?: InputMaybe<Scalars['BigInt']>;
  totalInflowRate_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalNetFlowRate?: InputMaybe<Scalars['BigInt']>;
  totalNetFlowRate_gt?: InputMaybe<Scalars['BigInt']>;
  totalNetFlowRate_gte?: InputMaybe<Scalars['BigInt']>;
  totalNetFlowRate_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalNetFlowRate_lt?: InputMaybe<Scalars['BigInt']>;
  totalNetFlowRate_lte?: InputMaybe<Scalars['BigInt']>;
  totalNetFlowRate_not?: InputMaybe<Scalars['BigInt']>;
  totalNetFlowRate_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalNumberOfActiveStreams?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_gt?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_gte?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfActiveStreams_lt?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_lte?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_not?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfClosedStreams?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_gt?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_gte?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfClosedStreams_lt?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_lte?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_not?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalOutflowRate?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_gt?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_gte?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalOutflowRate_lt?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_lte?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_not?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalSubscriptionsWithUnits?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_gt?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_gte?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_in?: InputMaybe<Array<Scalars['Int']>>;
  totalSubscriptionsWithUnits_lt?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_lte?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_not?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_not_in?: InputMaybe<Array<Scalars['Int']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  triggeredByEventName?: InputMaybe<Scalars['String']>;
  triggeredByEventName_contains?: InputMaybe<Scalars['String']>;
  triggeredByEventName_contains_nocase?: InputMaybe<Scalars['String']>;
  triggeredByEventName_ends_with?: InputMaybe<Scalars['String']>;
  triggeredByEventName_ends_with_nocase?: InputMaybe<Scalars['String']>;
  triggeredByEventName_gt?: InputMaybe<Scalars['String']>;
  triggeredByEventName_gte?: InputMaybe<Scalars['String']>;
  triggeredByEventName_in?: InputMaybe<Array<Scalars['String']>>;
  triggeredByEventName_lt?: InputMaybe<Scalars['String']>;
  triggeredByEventName_lte?: InputMaybe<Scalars['String']>;
  triggeredByEventName_not?: InputMaybe<Scalars['String']>;
  triggeredByEventName_not_contains?: InputMaybe<Scalars['String']>;
  triggeredByEventName_not_contains_nocase?: InputMaybe<Scalars['String']>;
  triggeredByEventName_not_ends_with?: InputMaybe<Scalars['String']>;
  triggeredByEventName_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  triggeredByEventName_not_in?: InputMaybe<Array<Scalars['String']>>;
  triggeredByEventName_not_starts_with?: InputMaybe<Scalars['String']>;
  triggeredByEventName_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  triggeredByEventName_starts_with?: InputMaybe<Scalars['String']>;
  triggeredByEventName_starts_with_nocase?: InputMaybe<Scalars['String']>;
};

export enum AccountTokenSnapshotLog_OrderBy {
  Account = 'account',
  AccountTokenSnapshot = 'accountTokenSnapshot',
  AccountTokenSnapshotActiveIncomingStreamCount = 'accountTokenSnapshot__activeIncomingStreamCount',
  AccountTokenSnapshotActiveOutgoingStreamCount = 'accountTokenSnapshot__activeOutgoingStreamCount',
  AccountTokenSnapshotBalanceUntilUpdatedAt = 'accountTokenSnapshot__balanceUntilUpdatedAt',
  AccountTokenSnapshotId = 'accountTokenSnapshot__id',
  AccountTokenSnapshotInactiveIncomingStreamCount = 'accountTokenSnapshot__inactiveIncomingStreamCount',
  AccountTokenSnapshotInactiveOutgoingStreamCount = 'accountTokenSnapshot__inactiveOutgoingStreamCount',
  AccountTokenSnapshotIsLiquidationEstimateOptimistic = 'accountTokenSnapshot__isLiquidationEstimateOptimistic',
  AccountTokenSnapshotMaybeCriticalAtTimestamp = 'accountTokenSnapshot__maybeCriticalAtTimestamp',
  AccountTokenSnapshotTotalAmountStreamedInUntilUpdatedAt = 'accountTokenSnapshot__totalAmountStreamedInUntilUpdatedAt',
  AccountTokenSnapshotTotalAmountStreamedOutUntilUpdatedAt = 'accountTokenSnapshot__totalAmountStreamedOutUntilUpdatedAt',
  AccountTokenSnapshotTotalAmountStreamedUntilUpdatedAt = 'accountTokenSnapshot__totalAmountStreamedUntilUpdatedAt',
  AccountTokenSnapshotTotalAmountTransferredUntilUpdatedAt = 'accountTokenSnapshot__totalAmountTransferredUntilUpdatedAt',
  AccountTokenSnapshotTotalApprovedSubscriptions = 'accountTokenSnapshot__totalApprovedSubscriptions',
  AccountTokenSnapshotTotalDeposit = 'accountTokenSnapshot__totalDeposit',
  AccountTokenSnapshotTotalInflowRate = 'accountTokenSnapshot__totalInflowRate',
  AccountTokenSnapshotTotalNetFlowRate = 'accountTokenSnapshot__totalNetFlowRate',
  AccountTokenSnapshotTotalNumberOfActiveStreams = 'accountTokenSnapshot__totalNumberOfActiveStreams',
  AccountTokenSnapshotTotalNumberOfClosedStreams = 'accountTokenSnapshot__totalNumberOfClosedStreams',
  AccountTokenSnapshotTotalOutflowRate = 'accountTokenSnapshot__totalOutflowRate',
  AccountTokenSnapshotTotalSubscriptionsWithUnits = 'accountTokenSnapshot__totalSubscriptionsWithUnits',
  AccountTokenSnapshotUpdatedAtBlockNumber = 'accountTokenSnapshot__updatedAtBlockNumber',
  AccountTokenSnapshotUpdatedAtTimestamp = 'accountTokenSnapshot__updatedAtTimestamp',
  AccountCreatedAtBlockNumber = 'account__createdAtBlockNumber',
  AccountCreatedAtTimestamp = 'account__createdAtTimestamp',
  AccountId = 'account__id',
  AccountIsSuperApp = 'account__isSuperApp',
  AccountUpdatedAtBlockNumber = 'account__updatedAtBlockNumber',
  AccountUpdatedAtTimestamp = 'account__updatedAtTimestamp',
  ActiveIncomingStreamCount = 'activeIncomingStreamCount',
  ActiveOutgoingStreamCount = 'activeOutgoingStreamCount',
  Balance = 'balance',
  BlockNumber = 'blockNumber',
  Id = 'id',
  InactiveIncomingStreamCount = 'inactiveIncomingStreamCount',
  InactiveOutgoingStreamCount = 'inactiveOutgoingStreamCount',
  LogIndex = 'logIndex',
  MaybeCriticalAtTimestamp = 'maybeCriticalAtTimestamp',
  Order = 'order',
  Timestamp = 'timestamp',
  Token = 'token',
  TokenCreatedAtBlockNumber = 'token__createdAtBlockNumber',
  TokenCreatedAtTimestamp = 'token__createdAtTimestamp',
  TokenDecimals = 'token__decimals',
  TokenId = 'token__id',
  TokenIsListed = 'token__isListed',
  TokenIsNativeAssetSuperToken = 'token__isNativeAssetSuperToken',
  TokenIsSuperToken = 'token__isSuperToken',
  TokenName = 'token__name',
  TokenSymbol = 'token__symbol',
  TokenUnderlyingAddress = 'token__underlyingAddress',
  TotalAmountStreamed = 'totalAmountStreamed',
  TotalAmountStreamedIn = 'totalAmountStreamedIn',
  TotalAmountStreamedOut = 'totalAmountStreamedOut',
  TotalAmountTransferred = 'totalAmountTransferred',
  TotalApprovedSubscriptions = 'totalApprovedSubscriptions',
  TotalDeposit = 'totalDeposit',
  TotalInflowRate = 'totalInflowRate',
  TotalNetFlowRate = 'totalNetFlowRate',
  TotalNumberOfActiveStreams = 'totalNumberOfActiveStreams',
  TotalNumberOfClosedStreams = 'totalNumberOfClosedStreams',
  TotalOutflowRate = 'totalOutflowRate',
  TotalSubscriptionsWithUnits = 'totalSubscriptionsWithUnits',
  TransactionHash = 'transactionHash',
  TriggeredByEventName = 'triggeredByEventName'
}

export type AccountTokenSnapshot_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['String']>;
  accountTokenSnapshotLogs_?: InputMaybe<AccountTokenSnapshotLog_Filter>;
  account_?: InputMaybe<Account_Filter>;
  account_contains?: InputMaybe<Scalars['String']>;
  account_contains_nocase?: InputMaybe<Scalars['String']>;
  account_ends_with?: InputMaybe<Scalars['String']>;
  account_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_gt?: InputMaybe<Scalars['String']>;
  account_gte?: InputMaybe<Scalars['String']>;
  account_in?: InputMaybe<Array<Scalars['String']>>;
  account_lt?: InputMaybe<Scalars['String']>;
  account_lte?: InputMaybe<Scalars['String']>;
  account_not?: InputMaybe<Scalars['String']>;
  account_not_contains?: InputMaybe<Scalars['String']>;
  account_not_contains_nocase?: InputMaybe<Scalars['String']>;
  account_not_ends_with?: InputMaybe<Scalars['String']>;
  account_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_not_in?: InputMaybe<Array<Scalars['String']>>;
  account_not_starts_with?: InputMaybe<Scalars['String']>;
  account_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_starts_with?: InputMaybe<Scalars['String']>;
  account_starts_with_nocase?: InputMaybe<Scalars['String']>;
  activeIncomingStreamCount?: InputMaybe<Scalars['Int']>;
  activeIncomingStreamCount_gt?: InputMaybe<Scalars['Int']>;
  activeIncomingStreamCount_gte?: InputMaybe<Scalars['Int']>;
  activeIncomingStreamCount_in?: InputMaybe<Array<Scalars['Int']>>;
  activeIncomingStreamCount_lt?: InputMaybe<Scalars['Int']>;
  activeIncomingStreamCount_lte?: InputMaybe<Scalars['Int']>;
  activeIncomingStreamCount_not?: InputMaybe<Scalars['Int']>;
  activeIncomingStreamCount_not_in?: InputMaybe<Array<Scalars['Int']>>;
  activeOutgoingStreamCount?: InputMaybe<Scalars['Int']>;
  activeOutgoingStreamCount_gt?: InputMaybe<Scalars['Int']>;
  activeOutgoingStreamCount_gte?: InputMaybe<Scalars['Int']>;
  activeOutgoingStreamCount_in?: InputMaybe<Array<Scalars['Int']>>;
  activeOutgoingStreamCount_lt?: InputMaybe<Scalars['Int']>;
  activeOutgoingStreamCount_lte?: InputMaybe<Scalars['Int']>;
  activeOutgoingStreamCount_not?: InputMaybe<Scalars['Int']>;
  activeOutgoingStreamCount_not_in?: InputMaybe<Array<Scalars['Int']>>;
  and?: InputMaybe<Array<InputMaybe<AccountTokenSnapshot_Filter>>>;
  balanceUntilUpdatedAt?: InputMaybe<Scalars['BigInt']>;
  balanceUntilUpdatedAt_gt?: InputMaybe<Scalars['BigInt']>;
  balanceUntilUpdatedAt_gte?: InputMaybe<Scalars['BigInt']>;
  balanceUntilUpdatedAt_in?: InputMaybe<Array<Scalars['BigInt']>>;
  balanceUntilUpdatedAt_lt?: InputMaybe<Scalars['BigInt']>;
  balanceUntilUpdatedAt_lte?: InputMaybe<Scalars['BigInt']>;
  balanceUntilUpdatedAt_not?: InputMaybe<Scalars['BigInt']>;
  balanceUntilUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  flowOperators_?: InputMaybe<FlowOperator_Filter>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  inactiveIncomingStreamCount?: InputMaybe<Scalars['Int']>;
  inactiveIncomingStreamCount_gt?: InputMaybe<Scalars['Int']>;
  inactiveIncomingStreamCount_gte?: InputMaybe<Scalars['Int']>;
  inactiveIncomingStreamCount_in?: InputMaybe<Array<Scalars['Int']>>;
  inactiveIncomingStreamCount_lt?: InputMaybe<Scalars['Int']>;
  inactiveIncomingStreamCount_lte?: InputMaybe<Scalars['Int']>;
  inactiveIncomingStreamCount_not?: InputMaybe<Scalars['Int']>;
  inactiveIncomingStreamCount_not_in?: InputMaybe<Array<Scalars['Int']>>;
  inactiveOutgoingStreamCount?: InputMaybe<Scalars['Int']>;
  inactiveOutgoingStreamCount_gt?: InputMaybe<Scalars['Int']>;
  inactiveOutgoingStreamCount_gte?: InputMaybe<Scalars['Int']>;
  inactiveOutgoingStreamCount_in?: InputMaybe<Array<Scalars['Int']>>;
  inactiveOutgoingStreamCount_lt?: InputMaybe<Scalars['Int']>;
  inactiveOutgoingStreamCount_lte?: InputMaybe<Scalars['Int']>;
  inactiveOutgoingStreamCount_not?: InputMaybe<Scalars['Int']>;
  inactiveOutgoingStreamCount_not_in?: InputMaybe<Array<Scalars['Int']>>;
  isLiquidationEstimateOptimistic?: InputMaybe<Scalars['Boolean']>;
  isLiquidationEstimateOptimistic_in?: InputMaybe<Array<Scalars['Boolean']>>;
  isLiquidationEstimateOptimistic_not?: InputMaybe<Scalars['Boolean']>;
  isLiquidationEstimateOptimistic_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  maybeCriticalAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  maybeCriticalAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  maybeCriticalAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  maybeCriticalAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  maybeCriticalAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  maybeCriticalAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  maybeCriticalAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  maybeCriticalAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  or?: InputMaybe<Array<InputMaybe<AccountTokenSnapshot_Filter>>>;
  token?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  totalAmountStreamedInUntilUpdatedAt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedInUntilUpdatedAt_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedInUntilUpdatedAt_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedInUntilUpdatedAt_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountStreamedInUntilUpdatedAt_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedInUntilUpdatedAt_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedInUntilUpdatedAt_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedInUntilUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountStreamedOutUntilUpdatedAt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedOutUntilUpdatedAt_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedOutUntilUpdatedAt_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedOutUntilUpdatedAt_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountStreamedOutUntilUpdatedAt_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedOutUntilUpdatedAt_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedOutUntilUpdatedAt_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedOutUntilUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountStreamedUntilUpdatedAt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilUpdatedAt_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilUpdatedAt_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilUpdatedAt_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountStreamedUntilUpdatedAt_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilUpdatedAt_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilUpdatedAt_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountTransferredUntilUpdatedAt?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferredUntilUpdatedAt_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferredUntilUpdatedAt_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferredUntilUpdatedAt_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountTransferredUntilUpdatedAt_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferredUntilUpdatedAt_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferredUntilUpdatedAt_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferredUntilUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalApprovedSubscriptions?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_gt?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_gte?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_in?: InputMaybe<Array<Scalars['Int']>>;
  totalApprovedSubscriptions_lt?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_lte?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_not?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalDeposit?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_gt?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_gte?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalDeposit_lt?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_lte?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_not?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalInflowRate?: InputMaybe<Scalars['BigInt']>;
  totalInflowRate_gt?: InputMaybe<Scalars['BigInt']>;
  totalInflowRate_gte?: InputMaybe<Scalars['BigInt']>;
  totalInflowRate_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalInflowRate_lt?: InputMaybe<Scalars['BigInt']>;
  totalInflowRate_lte?: InputMaybe<Scalars['BigInt']>;
  totalInflowRate_not?: InputMaybe<Scalars['BigInt']>;
  totalInflowRate_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalNetFlowRate?: InputMaybe<Scalars['BigInt']>;
  totalNetFlowRate_gt?: InputMaybe<Scalars['BigInt']>;
  totalNetFlowRate_gte?: InputMaybe<Scalars['BigInt']>;
  totalNetFlowRate_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalNetFlowRate_lt?: InputMaybe<Scalars['BigInt']>;
  totalNetFlowRate_lte?: InputMaybe<Scalars['BigInt']>;
  totalNetFlowRate_not?: InputMaybe<Scalars['BigInt']>;
  totalNetFlowRate_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalNumberOfActiveStreams?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_gt?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_gte?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfActiveStreams_lt?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_lte?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_not?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfClosedStreams?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_gt?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_gte?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfClosedStreams_lt?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_lte?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_not?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalOutflowRate?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_gt?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_gte?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalOutflowRate_lt?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_lte?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_not?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalSubscriptionsWithUnits?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_gt?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_gte?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_in?: InputMaybe<Array<Scalars['Int']>>;
  totalSubscriptionsWithUnits_lt?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_lte?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_not?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_not_in?: InputMaybe<Array<Scalars['Int']>>;
  updatedAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum AccountTokenSnapshot_OrderBy {
  Account = 'account',
  AccountTokenSnapshotLogs = 'accountTokenSnapshotLogs',
  AccountCreatedAtBlockNumber = 'account__createdAtBlockNumber',
  AccountCreatedAtTimestamp = 'account__createdAtTimestamp',
  AccountId = 'account__id',
  AccountIsSuperApp = 'account__isSuperApp',
  AccountUpdatedAtBlockNumber = 'account__updatedAtBlockNumber',
  AccountUpdatedAtTimestamp = 'account__updatedAtTimestamp',
  ActiveIncomingStreamCount = 'activeIncomingStreamCount',
  ActiveOutgoingStreamCount = 'activeOutgoingStreamCount',
  BalanceUntilUpdatedAt = 'balanceUntilUpdatedAt',
  FlowOperators = 'flowOperators',
  Id = 'id',
  InactiveIncomingStreamCount = 'inactiveIncomingStreamCount',
  InactiveOutgoingStreamCount = 'inactiveOutgoingStreamCount',
  IsLiquidationEstimateOptimistic = 'isLiquidationEstimateOptimistic',
  MaybeCriticalAtTimestamp = 'maybeCriticalAtTimestamp',
  Token = 'token',
  TokenCreatedAtBlockNumber = 'token__createdAtBlockNumber',
  TokenCreatedAtTimestamp = 'token__createdAtTimestamp',
  TokenDecimals = 'token__decimals',
  TokenId = 'token__id',
  TokenIsListed = 'token__isListed',
  TokenIsNativeAssetSuperToken = 'token__isNativeAssetSuperToken',
  TokenIsSuperToken = 'token__isSuperToken',
  TokenName = 'token__name',
  TokenSymbol = 'token__symbol',
  TokenUnderlyingAddress = 'token__underlyingAddress',
  TotalAmountStreamedInUntilUpdatedAt = 'totalAmountStreamedInUntilUpdatedAt',
  TotalAmountStreamedOutUntilUpdatedAt = 'totalAmountStreamedOutUntilUpdatedAt',
  TotalAmountStreamedUntilUpdatedAt = 'totalAmountStreamedUntilUpdatedAt',
  TotalAmountTransferredUntilUpdatedAt = 'totalAmountTransferredUntilUpdatedAt',
  TotalApprovedSubscriptions = 'totalApprovedSubscriptions',
  TotalDeposit = 'totalDeposit',
  TotalInflowRate = 'totalInflowRate',
  TotalNetFlowRate = 'totalNetFlowRate',
  TotalNumberOfActiveStreams = 'totalNumberOfActiveStreams',
  TotalNumberOfClosedStreams = 'totalNumberOfClosedStreams',
  TotalOutflowRate = 'totalOutflowRate',
  TotalSubscriptionsWithUnits = 'totalSubscriptionsWithUnits',
  UpdatedAtBlockNumber = 'updatedAtBlockNumber',
  UpdatedAtTimestamp = 'updatedAtTimestamp'
}

export type Account_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountTokenSnapshots_?: InputMaybe<AccountTokenSnapshot_Filter>;
  and?: InputMaybe<Array<InputMaybe<Account_Filter>>>;
  createdAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  inflows_?: InputMaybe<Stream_Filter>;
  isSuperApp?: InputMaybe<Scalars['Boolean']>;
  isSuperApp_in?: InputMaybe<Array<Scalars['Boolean']>>;
  isSuperApp_not?: InputMaybe<Scalars['Boolean']>;
  isSuperApp_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  or?: InputMaybe<Array<InputMaybe<Account_Filter>>>;
  outflows_?: InputMaybe<Stream_Filter>;
  publishedIndexes_?: InputMaybe<Index_Filter>;
  receivedTransferEvents_?: InputMaybe<TransferEvent_Filter>;
  sentTransferEvents_?: InputMaybe<TransferEvent_Filter>;
  subscriptions_?: InputMaybe<IndexSubscription_Filter>;
  tokenDowngradedEvents_?: InputMaybe<TokenDowngradedEvent_Filter>;
  tokenUpgradedEvents_?: InputMaybe<TokenUpgradedEvent_Filter>;
  updatedAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum Account_OrderBy {
  AccountTokenSnapshots = 'accountTokenSnapshots',
  CreatedAtBlockNumber = 'createdAtBlockNumber',
  CreatedAtTimestamp = 'createdAtTimestamp',
  Id = 'id',
  Inflows = 'inflows',
  IsSuperApp = 'isSuperApp',
  Outflows = 'outflows',
  PublishedIndexes = 'publishedIndexes',
  ReceivedTransferEvents = 'receivedTransferEvents',
  SentTransferEvents = 'sentTransferEvents',
  Subscriptions = 'subscriptions',
  TokenDowngradedEvents = 'tokenDowngradedEvents',
  TokenUpgradedEvents = 'tokenUpgradedEvents',
  UpdatedAtBlockNumber = 'updatedAtBlockNumber',
  UpdatedAtTimestamp = 'updatedAtTimestamp'
}

export type AchRequest = {
  ethereumAddress: Scalars['EthereumAddress'];
  freeTextHandle?: InputMaybe<Scalars['Boolean']>;
  handle?: InputMaybe<Scalars['CreateHandle']>;
  overrideAlreadyClaimed: Scalars['Boolean'];
  overrideTradeMark: Scalars['Boolean'];
  secret: Scalars['String'];
};

/** The request object to add interests to a profile */
export type AddProfileInterestsRequest = {
  /** The profile interest to add */
  interests: Array<Scalars['ProfileInterest']>;
  /** The profileId to add interests to */
  profileId: Scalars['ProfileId'];
};

export type AgreementClassRegisteredEvent = Event & {
  __typename?: 'AgreementClassRegisteredEvent';
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  agreementType: Scalars['Bytes'];
  blockNumber: Scalars['BigInt'];
  code: Scalars['Bytes'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
};

export type AgreementClassRegisteredEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  agreementType?: InputMaybe<Scalars['Bytes']>;
  agreementType_contains?: InputMaybe<Scalars['Bytes']>;
  agreementType_gt?: InputMaybe<Scalars['Bytes']>;
  agreementType_gte?: InputMaybe<Scalars['Bytes']>;
  agreementType_in?: InputMaybe<Array<Scalars['Bytes']>>;
  agreementType_lt?: InputMaybe<Scalars['Bytes']>;
  agreementType_lte?: InputMaybe<Scalars['Bytes']>;
  agreementType_not?: InputMaybe<Scalars['Bytes']>;
  agreementType_not_contains?: InputMaybe<Scalars['Bytes']>;
  agreementType_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<AgreementClassRegisteredEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  code?: InputMaybe<Scalars['Bytes']>;
  code_contains?: InputMaybe<Scalars['Bytes']>;
  code_gt?: InputMaybe<Scalars['Bytes']>;
  code_gte?: InputMaybe<Scalars['Bytes']>;
  code_in?: InputMaybe<Array<Scalars['Bytes']>>;
  code_lt?: InputMaybe<Scalars['Bytes']>;
  code_lte?: InputMaybe<Scalars['Bytes']>;
  code_not?: InputMaybe<Scalars['Bytes']>;
  code_not_contains?: InputMaybe<Scalars['Bytes']>;
  code_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<AgreementClassRegisteredEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum AgreementClassRegisteredEvent_OrderBy {
  Addresses = 'addresses',
  AgreementType = 'agreementType',
  BlockNumber = 'blockNumber',
  Code = 'code',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Timestamp = 'timestamp',
  TransactionHash = 'transactionHash'
}

export type AgreementClassUpdatedEvent = Event & {
  __typename?: 'AgreementClassUpdatedEvent';
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  agreementType: Scalars['Bytes'];
  blockNumber: Scalars['BigInt'];
  code: Scalars['Bytes'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
};

export type AgreementClassUpdatedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  agreementType?: InputMaybe<Scalars['Bytes']>;
  agreementType_contains?: InputMaybe<Scalars['Bytes']>;
  agreementType_gt?: InputMaybe<Scalars['Bytes']>;
  agreementType_gte?: InputMaybe<Scalars['Bytes']>;
  agreementType_in?: InputMaybe<Array<Scalars['Bytes']>>;
  agreementType_lt?: InputMaybe<Scalars['Bytes']>;
  agreementType_lte?: InputMaybe<Scalars['Bytes']>;
  agreementType_not?: InputMaybe<Scalars['Bytes']>;
  agreementType_not_contains?: InputMaybe<Scalars['Bytes']>;
  agreementType_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<AgreementClassUpdatedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  code?: InputMaybe<Scalars['Bytes']>;
  code_contains?: InputMaybe<Scalars['Bytes']>;
  code_gt?: InputMaybe<Scalars['Bytes']>;
  code_gte?: InputMaybe<Scalars['Bytes']>;
  code_in?: InputMaybe<Array<Scalars['Bytes']>>;
  code_lt?: InputMaybe<Scalars['Bytes']>;
  code_lte?: InputMaybe<Scalars['Bytes']>;
  code_not?: InputMaybe<Scalars['Bytes']>;
  code_not_contains?: InputMaybe<Scalars['Bytes']>;
  code_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<AgreementClassUpdatedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum AgreementClassUpdatedEvent_OrderBy {
  Addresses = 'addresses',
  AgreementType = 'agreementType',
  BlockNumber = 'blockNumber',
  Code = 'code',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Timestamp = 'timestamp',
  TransactionHash = 'transactionHash'
}

/**
 * NOTE: This event was deprecated since the introduction of the 3Ps system.
 * Replaced by: `AgreementLiquidatedV2Event`
 * See: https://docs.superfluid.finance/superfluid/sentinels/liquidations-and-toga#patricians-plebs-and-pirates-3ps for more details on the 3Ps system.
 * See: https://github.com/superfluid-finance/protocol-monorepo/blob/dev/packages/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluidToken.sol#L425 for more details on the events.
 *
 */
export type AgreementLiquidatedByEvent = Event & {
  __typename?: 'AgreementLiquidatedByEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = liquidatorAccount (executor of liquidation)
   * addresses[2] = penaltyAccount (the sender of the flow/stream)
   * addresses[3] = bondAccount (the address receiving the reward - the reward account for the token, pre 3Ps)
   *
   */
  addresses: Array<Scalars['Bytes']>;
  agreementClass: Scalars['Bytes'];
  agreementId: Scalars['Bytes'];
  bailoutAmount: Scalars['BigInt'];
  blockNumber: Scalars['BigInt'];
  bondAccount: Scalars['Bytes'];
  /**
   * The full deposit amount of the stream that was liquidated.
   *
   */
  deposit: Scalars['BigInt'];
  /**
   * The flow rate of the stream at the time of liquidation.
   *
   */
  flowRateAtLiquidation: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  liquidatorAccount: Scalars['Bytes'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  penaltyAccount: Scalars['Bytes'];
  rewardAmount: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
};

export type AgreementLiquidatedByEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  agreementClass?: InputMaybe<Scalars['Bytes']>;
  agreementClass_contains?: InputMaybe<Scalars['Bytes']>;
  agreementClass_gt?: InputMaybe<Scalars['Bytes']>;
  agreementClass_gte?: InputMaybe<Scalars['Bytes']>;
  agreementClass_in?: InputMaybe<Array<Scalars['Bytes']>>;
  agreementClass_lt?: InputMaybe<Scalars['Bytes']>;
  agreementClass_lte?: InputMaybe<Scalars['Bytes']>;
  agreementClass_not?: InputMaybe<Scalars['Bytes']>;
  agreementClass_not_contains?: InputMaybe<Scalars['Bytes']>;
  agreementClass_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  agreementId?: InputMaybe<Scalars['Bytes']>;
  agreementId_contains?: InputMaybe<Scalars['Bytes']>;
  agreementId_gt?: InputMaybe<Scalars['Bytes']>;
  agreementId_gte?: InputMaybe<Scalars['Bytes']>;
  agreementId_in?: InputMaybe<Array<Scalars['Bytes']>>;
  agreementId_lt?: InputMaybe<Scalars['Bytes']>;
  agreementId_lte?: InputMaybe<Scalars['Bytes']>;
  agreementId_not?: InputMaybe<Scalars['Bytes']>;
  agreementId_not_contains?: InputMaybe<Scalars['Bytes']>;
  agreementId_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<AgreementLiquidatedByEvent_Filter>>>;
  bailoutAmount?: InputMaybe<Scalars['BigInt']>;
  bailoutAmount_gt?: InputMaybe<Scalars['BigInt']>;
  bailoutAmount_gte?: InputMaybe<Scalars['BigInt']>;
  bailoutAmount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  bailoutAmount_lt?: InputMaybe<Scalars['BigInt']>;
  bailoutAmount_lte?: InputMaybe<Scalars['BigInt']>;
  bailoutAmount_not?: InputMaybe<Scalars['BigInt']>;
  bailoutAmount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  bondAccount?: InputMaybe<Scalars['Bytes']>;
  bondAccount_contains?: InputMaybe<Scalars['Bytes']>;
  bondAccount_gt?: InputMaybe<Scalars['Bytes']>;
  bondAccount_gte?: InputMaybe<Scalars['Bytes']>;
  bondAccount_in?: InputMaybe<Array<Scalars['Bytes']>>;
  bondAccount_lt?: InputMaybe<Scalars['Bytes']>;
  bondAccount_lte?: InputMaybe<Scalars['Bytes']>;
  bondAccount_not?: InputMaybe<Scalars['Bytes']>;
  bondAccount_not_contains?: InputMaybe<Scalars['Bytes']>;
  bondAccount_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  deposit?: InputMaybe<Scalars['BigInt']>;
  deposit_gt?: InputMaybe<Scalars['BigInt']>;
  deposit_gte?: InputMaybe<Scalars['BigInt']>;
  deposit_in?: InputMaybe<Array<Scalars['BigInt']>>;
  deposit_lt?: InputMaybe<Scalars['BigInt']>;
  deposit_lte?: InputMaybe<Scalars['BigInt']>;
  deposit_not?: InputMaybe<Scalars['BigInt']>;
  deposit_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  flowRateAtLiquidation?: InputMaybe<Scalars['BigInt']>;
  flowRateAtLiquidation_gt?: InputMaybe<Scalars['BigInt']>;
  flowRateAtLiquidation_gte?: InputMaybe<Scalars['BigInt']>;
  flowRateAtLiquidation_in?: InputMaybe<Array<Scalars['BigInt']>>;
  flowRateAtLiquidation_lt?: InputMaybe<Scalars['BigInt']>;
  flowRateAtLiquidation_lte?: InputMaybe<Scalars['BigInt']>;
  flowRateAtLiquidation_not?: InputMaybe<Scalars['BigInt']>;
  flowRateAtLiquidation_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  liquidatorAccount?: InputMaybe<Scalars['Bytes']>;
  liquidatorAccount_contains?: InputMaybe<Scalars['Bytes']>;
  liquidatorAccount_gt?: InputMaybe<Scalars['Bytes']>;
  liquidatorAccount_gte?: InputMaybe<Scalars['Bytes']>;
  liquidatorAccount_in?: InputMaybe<Array<Scalars['Bytes']>>;
  liquidatorAccount_lt?: InputMaybe<Scalars['Bytes']>;
  liquidatorAccount_lte?: InputMaybe<Scalars['Bytes']>;
  liquidatorAccount_not?: InputMaybe<Scalars['Bytes']>;
  liquidatorAccount_not_contains?: InputMaybe<Scalars['Bytes']>;
  liquidatorAccount_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<AgreementLiquidatedByEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  penaltyAccount?: InputMaybe<Scalars['Bytes']>;
  penaltyAccount_contains?: InputMaybe<Scalars['Bytes']>;
  penaltyAccount_gt?: InputMaybe<Scalars['Bytes']>;
  penaltyAccount_gte?: InputMaybe<Scalars['Bytes']>;
  penaltyAccount_in?: InputMaybe<Array<Scalars['Bytes']>>;
  penaltyAccount_lt?: InputMaybe<Scalars['Bytes']>;
  penaltyAccount_lte?: InputMaybe<Scalars['Bytes']>;
  penaltyAccount_not?: InputMaybe<Scalars['Bytes']>;
  penaltyAccount_not_contains?: InputMaybe<Scalars['Bytes']>;
  penaltyAccount_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  rewardAmount?: InputMaybe<Scalars['BigInt']>;
  rewardAmount_gt?: InputMaybe<Scalars['BigInt']>;
  rewardAmount_gte?: InputMaybe<Scalars['BigInt']>;
  rewardAmount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  rewardAmount_lt?: InputMaybe<Scalars['BigInt']>;
  rewardAmount_lte?: InputMaybe<Scalars['BigInt']>;
  rewardAmount_not?: InputMaybe<Scalars['BigInt']>;
  rewardAmount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum AgreementLiquidatedByEvent_OrderBy {
  Addresses = 'addresses',
  AgreementClass = 'agreementClass',
  AgreementId = 'agreementId',
  BailoutAmount = 'bailoutAmount',
  BlockNumber = 'blockNumber',
  BondAccount = 'bondAccount',
  Deposit = 'deposit',
  FlowRateAtLiquidation = 'flowRateAtLiquidation',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LiquidatorAccount = 'liquidatorAccount',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  PenaltyAccount = 'penaltyAccount',
  RewardAmount = 'rewardAmount',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash'
}

export type AgreementLiquidatedV2Event = Event & {
  __typename?: 'AgreementLiquidatedV2Event';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `liquidatorAccount` (executor of liquidation)
   * addresses[2] = `targetAccount` (the sender of the flow/stream)
   * addresses[3] = `rewardAmountReceiver` (the address receiving the reward) addresses
   *
   */
  addresses: Array<Scalars['Bytes']>;
  agreementClass: Scalars['Bytes'];
  agreementId: Scalars['Bytes'];
  blockNumber: Scalars['BigInt'];
  /**
   * The full deposit amount of the stream that was liquidated.
   *
   */
  deposit: Scalars['BigInt'];
  /**
   * The flow rate of the stream at the time of liquidation.
   *
   */
  flowRateAtLiquidation: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  liquidationType: Scalars['Int'];
  liquidatorAccount: Scalars['Bytes'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  /**
   * TO BE DEPRECATED in v2 endpoint - use rewardAmountReceiver instead
   *
   */
  rewardAccount: Scalars['Bytes'];
  rewardAmount: Scalars['BigInt'];
  rewardAmountReceiver: Scalars['Bytes'];
  targetAccount: Scalars['Bytes'];
  targetAccountBalanceDelta: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
  version: Scalars['BigInt'];
};

export type AgreementLiquidatedV2Event_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  agreementClass?: InputMaybe<Scalars['Bytes']>;
  agreementClass_contains?: InputMaybe<Scalars['Bytes']>;
  agreementClass_gt?: InputMaybe<Scalars['Bytes']>;
  agreementClass_gte?: InputMaybe<Scalars['Bytes']>;
  agreementClass_in?: InputMaybe<Array<Scalars['Bytes']>>;
  agreementClass_lt?: InputMaybe<Scalars['Bytes']>;
  agreementClass_lte?: InputMaybe<Scalars['Bytes']>;
  agreementClass_not?: InputMaybe<Scalars['Bytes']>;
  agreementClass_not_contains?: InputMaybe<Scalars['Bytes']>;
  agreementClass_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  agreementId?: InputMaybe<Scalars['Bytes']>;
  agreementId_contains?: InputMaybe<Scalars['Bytes']>;
  agreementId_gt?: InputMaybe<Scalars['Bytes']>;
  agreementId_gte?: InputMaybe<Scalars['Bytes']>;
  agreementId_in?: InputMaybe<Array<Scalars['Bytes']>>;
  agreementId_lt?: InputMaybe<Scalars['Bytes']>;
  agreementId_lte?: InputMaybe<Scalars['Bytes']>;
  agreementId_not?: InputMaybe<Scalars['Bytes']>;
  agreementId_not_contains?: InputMaybe<Scalars['Bytes']>;
  agreementId_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<AgreementLiquidatedV2Event_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  deposit?: InputMaybe<Scalars['BigInt']>;
  deposit_gt?: InputMaybe<Scalars['BigInt']>;
  deposit_gte?: InputMaybe<Scalars['BigInt']>;
  deposit_in?: InputMaybe<Array<Scalars['BigInt']>>;
  deposit_lt?: InputMaybe<Scalars['BigInt']>;
  deposit_lte?: InputMaybe<Scalars['BigInt']>;
  deposit_not?: InputMaybe<Scalars['BigInt']>;
  deposit_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  flowRateAtLiquidation?: InputMaybe<Scalars['BigInt']>;
  flowRateAtLiquidation_gt?: InputMaybe<Scalars['BigInt']>;
  flowRateAtLiquidation_gte?: InputMaybe<Scalars['BigInt']>;
  flowRateAtLiquidation_in?: InputMaybe<Array<Scalars['BigInt']>>;
  flowRateAtLiquidation_lt?: InputMaybe<Scalars['BigInt']>;
  flowRateAtLiquidation_lte?: InputMaybe<Scalars['BigInt']>;
  flowRateAtLiquidation_not?: InputMaybe<Scalars['BigInt']>;
  flowRateAtLiquidation_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  liquidationType?: InputMaybe<Scalars['Int']>;
  liquidationType_gt?: InputMaybe<Scalars['Int']>;
  liquidationType_gte?: InputMaybe<Scalars['Int']>;
  liquidationType_in?: InputMaybe<Array<Scalars['Int']>>;
  liquidationType_lt?: InputMaybe<Scalars['Int']>;
  liquidationType_lte?: InputMaybe<Scalars['Int']>;
  liquidationType_not?: InputMaybe<Scalars['Int']>;
  liquidationType_not_in?: InputMaybe<Array<Scalars['Int']>>;
  liquidatorAccount?: InputMaybe<Scalars['Bytes']>;
  liquidatorAccount_contains?: InputMaybe<Scalars['Bytes']>;
  liquidatorAccount_gt?: InputMaybe<Scalars['Bytes']>;
  liquidatorAccount_gte?: InputMaybe<Scalars['Bytes']>;
  liquidatorAccount_in?: InputMaybe<Array<Scalars['Bytes']>>;
  liquidatorAccount_lt?: InputMaybe<Scalars['Bytes']>;
  liquidatorAccount_lte?: InputMaybe<Scalars['Bytes']>;
  liquidatorAccount_not?: InputMaybe<Scalars['Bytes']>;
  liquidatorAccount_not_contains?: InputMaybe<Scalars['Bytes']>;
  liquidatorAccount_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<AgreementLiquidatedV2Event_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  rewardAccount?: InputMaybe<Scalars['Bytes']>;
  rewardAccount_contains?: InputMaybe<Scalars['Bytes']>;
  rewardAccount_gt?: InputMaybe<Scalars['Bytes']>;
  rewardAccount_gte?: InputMaybe<Scalars['Bytes']>;
  rewardAccount_in?: InputMaybe<Array<Scalars['Bytes']>>;
  rewardAccount_lt?: InputMaybe<Scalars['Bytes']>;
  rewardAccount_lte?: InputMaybe<Scalars['Bytes']>;
  rewardAccount_not?: InputMaybe<Scalars['Bytes']>;
  rewardAccount_not_contains?: InputMaybe<Scalars['Bytes']>;
  rewardAccount_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  rewardAmount?: InputMaybe<Scalars['BigInt']>;
  rewardAmountReceiver?: InputMaybe<Scalars['Bytes']>;
  rewardAmountReceiver_contains?: InputMaybe<Scalars['Bytes']>;
  rewardAmountReceiver_gt?: InputMaybe<Scalars['Bytes']>;
  rewardAmountReceiver_gte?: InputMaybe<Scalars['Bytes']>;
  rewardAmountReceiver_in?: InputMaybe<Array<Scalars['Bytes']>>;
  rewardAmountReceiver_lt?: InputMaybe<Scalars['Bytes']>;
  rewardAmountReceiver_lte?: InputMaybe<Scalars['Bytes']>;
  rewardAmountReceiver_not?: InputMaybe<Scalars['Bytes']>;
  rewardAmountReceiver_not_contains?: InputMaybe<Scalars['Bytes']>;
  rewardAmountReceiver_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  rewardAmount_gt?: InputMaybe<Scalars['BigInt']>;
  rewardAmount_gte?: InputMaybe<Scalars['BigInt']>;
  rewardAmount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  rewardAmount_lt?: InputMaybe<Scalars['BigInt']>;
  rewardAmount_lte?: InputMaybe<Scalars['BigInt']>;
  rewardAmount_not?: InputMaybe<Scalars['BigInt']>;
  rewardAmount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  targetAccount?: InputMaybe<Scalars['Bytes']>;
  targetAccountBalanceDelta?: InputMaybe<Scalars['BigInt']>;
  targetAccountBalanceDelta_gt?: InputMaybe<Scalars['BigInt']>;
  targetAccountBalanceDelta_gte?: InputMaybe<Scalars['BigInt']>;
  targetAccountBalanceDelta_in?: InputMaybe<Array<Scalars['BigInt']>>;
  targetAccountBalanceDelta_lt?: InputMaybe<Scalars['BigInt']>;
  targetAccountBalanceDelta_lte?: InputMaybe<Scalars['BigInt']>;
  targetAccountBalanceDelta_not?: InputMaybe<Scalars['BigInt']>;
  targetAccountBalanceDelta_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  targetAccount_contains?: InputMaybe<Scalars['Bytes']>;
  targetAccount_gt?: InputMaybe<Scalars['Bytes']>;
  targetAccount_gte?: InputMaybe<Scalars['Bytes']>;
  targetAccount_in?: InputMaybe<Array<Scalars['Bytes']>>;
  targetAccount_lt?: InputMaybe<Scalars['Bytes']>;
  targetAccount_lte?: InputMaybe<Scalars['Bytes']>;
  targetAccount_not?: InputMaybe<Scalars['Bytes']>;
  targetAccount_not_contains?: InputMaybe<Scalars['Bytes']>;
  targetAccount_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  version?: InputMaybe<Scalars['BigInt']>;
  version_gt?: InputMaybe<Scalars['BigInt']>;
  version_gte?: InputMaybe<Scalars['BigInt']>;
  version_in?: InputMaybe<Array<Scalars['BigInt']>>;
  version_lt?: InputMaybe<Scalars['BigInt']>;
  version_lte?: InputMaybe<Scalars['BigInt']>;
  version_not?: InputMaybe<Scalars['BigInt']>;
  version_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum AgreementLiquidatedV2Event_OrderBy {
  Addresses = 'addresses',
  AgreementClass = 'agreementClass',
  AgreementId = 'agreementId',
  BlockNumber = 'blockNumber',
  Deposit = 'deposit',
  FlowRateAtLiquidation = 'flowRateAtLiquidation',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LiquidationType = 'liquidationType',
  LiquidatorAccount = 'liquidatorAccount',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  RewardAccount = 'rewardAccount',
  RewardAmount = 'rewardAmount',
  RewardAmountReceiver = 'rewardAmountReceiver',
  TargetAccount = 'targetAccount',
  TargetAccountBalanceDelta = 'targetAccountBalanceDelta',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash',
  Version = 'version'
}

export type AllPublicationsTagsRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  sort: TagSortCriteria;
  /** The App Id */
  source?: InputMaybe<Scalars['Sources']>;
};

export type AlreadyInvitedCheckRequest = {
  address: Scalars['EthereumAddress'];
};

export type AndConditionInput = {
  /** The list of conditions to apply AND to. You can only use nested boolean conditions at the root level. */
  criteria: Array<AccessConditionInput>;
};

export type AndConditionOutput = {
  __typename?: 'AndConditionOutput';
  /** The list of conditions to apply AND to. You can only use nested boolean conditions at the root level. */
  criteria: Array<AccessConditionOutput>;
};

export type AppRegisteredEvent = Event & {
  __typename?: 'AppRegisteredEvent';
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  app: Scalars['Bytes'];
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
};

export type AppRegisteredEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<AppRegisteredEvent_Filter>>>;
  app?: InputMaybe<Scalars['Bytes']>;
  app_contains?: InputMaybe<Scalars['Bytes']>;
  app_gt?: InputMaybe<Scalars['Bytes']>;
  app_gte?: InputMaybe<Scalars['Bytes']>;
  app_in?: InputMaybe<Array<Scalars['Bytes']>>;
  app_lt?: InputMaybe<Scalars['Bytes']>;
  app_lte?: InputMaybe<Scalars['Bytes']>;
  app_not?: InputMaybe<Scalars['Bytes']>;
  app_not_contains?: InputMaybe<Scalars['Bytes']>;
  app_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<AppRegisteredEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum AppRegisteredEvent_OrderBy {
  Addresses = 'addresses',
  App = 'app',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Timestamp = 'timestamp',
  TransactionHash = 'transactionHash'
}

export type ApprovedAllowanceAmount = {
  __typename?: 'ApprovedAllowanceAmount';
  allowance: Scalars['String'];
  contractAddress: Scalars['ContractAddress'];
  currency: Scalars['ContractAddress'];
  module: Scalars['String'];
};

export type ApprovedModuleAllowanceAmountRequest = {
  collectModules?: InputMaybe<Array<CollectModules>>;
  /** The contract addresses for the module approved currencies you want to find information on about the user */
  currencies: Array<Scalars['ContractAddress']>;
  followModules?: InputMaybe<Array<FollowModules>>;
  referenceModules?: InputMaybe<Array<ReferenceModules>>;
  unknownCollectModules?: InputMaybe<Array<Scalars['ContractAddress']>>;
  unknownFollowModules?: InputMaybe<Array<Scalars['ContractAddress']>>;
  unknownReferenceModules?: InputMaybe<Array<Scalars['ContractAddress']>>;
};

/** The Profile */
export type Attribute = {
  __typename?: 'Attribute';
  /** The display type */
  displayType?: Maybe<Scalars['String']>;
  /** identifier of this attribute, we will update by this id  */
  key: Scalars['String'];
  /** The trait type - can be anything its the name it will render so include spaces */
  traitType?: Maybe<Scalars['String']>;
  /** Value attribute */
  value: Scalars['String'];
};

/** The auth challenge result */
export type AuthChallengeResult = {
  __typename?: 'AuthChallengeResult';
  /** The text to sign */
  text: Scalars['String'];
};

/** The authentication result */
export type AuthenticationResult = {
  __typename?: 'AuthenticationResult';
  /** The access token */
  accessToken: Scalars['Jwt'];
  /** The refresh token */
  refreshToken: Scalars['Jwt'];
};

export type BlockChangedFilter = {
  number_gte: Scalars['Int'];
};

export type Block_Height = {
  hash?: InputMaybe<Scalars['Bytes']>;
  number?: InputMaybe<Scalars['Int']>;
  number_gte?: InputMaybe<Scalars['Int']>;
};

export type BondIncreasedEvent = Event & {
  __typename?: 'BondIncreasedEvent';
  /**
   * The additional amount added to the bond by the current Patrician In Charge (PIC).
   *
   */
  additionalBond: Scalars['BigInt'];
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  /**
   * The address of the `token` (supertoken).
   *
   */
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
};

export type BondIncreasedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  additionalBond?: InputMaybe<Scalars['BigInt']>;
  additionalBond_gt?: InputMaybe<Scalars['BigInt']>;
  additionalBond_gte?: InputMaybe<Scalars['BigInt']>;
  additionalBond_in?: InputMaybe<Array<Scalars['BigInt']>>;
  additionalBond_lt?: InputMaybe<Scalars['BigInt']>;
  additionalBond_lte?: InputMaybe<Scalars['BigInt']>;
  additionalBond_not?: InputMaybe<Scalars['BigInt']>;
  additionalBond_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<BondIncreasedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<BondIncreasedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum BondIncreasedEvent_OrderBy {
  AdditionalBond = 'additionalBond',
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash'
}

export type BroadcastDataAvailabilityUnion = CreateDataAvailabilityPublicationResult | RelayError;

export type BroadcastRequest = {
  id: Scalars['BroadcastId'];
  signature: Scalars['Signature'];
};

export type BurnProfileRequest = {
  profileId: Scalars['ProfileId'];
};

export type BurnedEvent = Event & {
  __typename?: 'BurnedEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `from`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  amount: Scalars['BigInt'];
  blockNumber: Scalars['BigInt'];
  data: Scalars['Bytes'];
  from: Scalars['Bytes'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  operator: Scalars['Bytes'];
  operatorData: Scalars['Bytes'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
};

export type BurnedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  and?: InputMaybe<Array<InputMaybe<BurnedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  data?: InputMaybe<Scalars['Bytes']>;
  data_contains?: InputMaybe<Scalars['Bytes']>;
  data_gt?: InputMaybe<Scalars['Bytes']>;
  data_gte?: InputMaybe<Scalars['Bytes']>;
  data_in?: InputMaybe<Array<Scalars['Bytes']>>;
  data_lt?: InputMaybe<Scalars['Bytes']>;
  data_lte?: InputMaybe<Scalars['Bytes']>;
  data_not?: InputMaybe<Scalars['Bytes']>;
  data_not_contains?: InputMaybe<Scalars['Bytes']>;
  data_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  from?: InputMaybe<Scalars['Bytes']>;
  from_contains?: InputMaybe<Scalars['Bytes']>;
  from_gt?: InputMaybe<Scalars['Bytes']>;
  from_gte?: InputMaybe<Scalars['Bytes']>;
  from_in?: InputMaybe<Array<Scalars['Bytes']>>;
  from_lt?: InputMaybe<Scalars['Bytes']>;
  from_lte?: InputMaybe<Scalars['Bytes']>;
  from_not?: InputMaybe<Scalars['Bytes']>;
  from_not_contains?: InputMaybe<Scalars['Bytes']>;
  from_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  operator?: InputMaybe<Scalars['Bytes']>;
  operatorData?: InputMaybe<Scalars['Bytes']>;
  operatorData_contains?: InputMaybe<Scalars['Bytes']>;
  operatorData_gt?: InputMaybe<Scalars['Bytes']>;
  operatorData_gte?: InputMaybe<Scalars['Bytes']>;
  operatorData_in?: InputMaybe<Array<Scalars['Bytes']>>;
  operatorData_lt?: InputMaybe<Scalars['Bytes']>;
  operatorData_lte?: InputMaybe<Scalars['Bytes']>;
  operatorData_not?: InputMaybe<Scalars['Bytes']>;
  operatorData_not_contains?: InputMaybe<Scalars['Bytes']>;
  operatorData_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  operator_contains?: InputMaybe<Scalars['Bytes']>;
  operator_gt?: InputMaybe<Scalars['Bytes']>;
  operator_gte?: InputMaybe<Scalars['Bytes']>;
  operator_in?: InputMaybe<Array<Scalars['Bytes']>>;
  operator_lt?: InputMaybe<Scalars['Bytes']>;
  operator_lte?: InputMaybe<Scalars['Bytes']>;
  operator_not?: InputMaybe<Scalars['Bytes']>;
  operator_not_contains?: InputMaybe<Scalars['Bytes']>;
  operator_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  or?: InputMaybe<Array<InputMaybe<BurnedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum BurnedEvent_OrderBy {
  Addresses = 'addresses',
  Amount = 'amount',
  BlockNumber = 'blockNumber',
  Data = 'data',
  From = 'from',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Operator = 'operator',
  OperatorData = 'operatorData',
  Order = 'order',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash'
}

export type CfAv1LiquidationPeriodChangedEvent = Event & {
  __typename?: 'CFAv1LiquidationPeriodChangedEvent';
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  /**
   * The address of the governance contract the event was emitted from.
   *
   */
  governanceAddress: Scalars['Bytes'];
  host: Scalars['Bytes'];
  id: Scalars['ID'];
  isKeySet: Scalars['Boolean'];
  liquidationPeriod: Scalars['BigInt'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  superToken: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
};

export type CfAv1LiquidationPeriodChangedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<CfAv1LiquidationPeriodChangedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  governanceAddress?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_contains?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_gt?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_gte?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_in?: InputMaybe<Array<Scalars['Bytes']>>;
  governanceAddress_lt?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_lte?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not_contains?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  host?: InputMaybe<Scalars['Bytes']>;
  host_contains?: InputMaybe<Scalars['Bytes']>;
  host_gt?: InputMaybe<Scalars['Bytes']>;
  host_gte?: InputMaybe<Scalars['Bytes']>;
  host_in?: InputMaybe<Array<Scalars['Bytes']>>;
  host_lt?: InputMaybe<Scalars['Bytes']>;
  host_lte?: InputMaybe<Scalars['Bytes']>;
  host_not?: InputMaybe<Scalars['Bytes']>;
  host_not_contains?: InputMaybe<Scalars['Bytes']>;
  host_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  isKeySet?: InputMaybe<Scalars['Boolean']>;
  isKeySet_in?: InputMaybe<Array<Scalars['Boolean']>>;
  isKeySet_not?: InputMaybe<Scalars['Boolean']>;
  isKeySet_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  liquidationPeriod?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_gt?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_gte?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_in?: InputMaybe<Array<Scalars['BigInt']>>;
  liquidationPeriod_lt?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_lte?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_not?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<CfAv1LiquidationPeriodChangedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  superToken?: InputMaybe<Scalars['Bytes']>;
  superToken_contains?: InputMaybe<Scalars['Bytes']>;
  superToken_gt?: InputMaybe<Scalars['Bytes']>;
  superToken_gte?: InputMaybe<Scalars['Bytes']>;
  superToken_in?: InputMaybe<Array<Scalars['Bytes']>>;
  superToken_lt?: InputMaybe<Scalars['Bytes']>;
  superToken_lte?: InputMaybe<Scalars['Bytes']>;
  superToken_not?: InputMaybe<Scalars['Bytes']>;
  superToken_not_contains?: InputMaybe<Scalars['Bytes']>;
  superToken_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum CfAv1LiquidationPeriodChangedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  GovernanceAddress = 'governanceAddress',
  Host = 'host',
  Id = 'id',
  IsKeySet = 'isKeySet',
  LiquidationPeriod = 'liquidationPeriod',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  SuperToken = 'superToken',
  Timestamp = 'timestamp',
  TransactionHash = 'transactionHash'
}

export type CanCommentResponse = {
  __typename?: 'CanCommentResponse';
  result: Scalars['Boolean'];
};

export type CanDecryptResponse = {
  __typename?: 'CanDecryptResponse';
  extraDetails?: Maybe<Scalars['String']>;
  reasons?: Maybe<Array<DecryptFailReason>>;
  result: Scalars['Boolean'];
};

export type CanMirrorResponse = {
  __typename?: 'CanMirrorResponse';
  result: Scalars['Boolean'];
};

/** The challenge request */
export type ChallengeRequest = {
  /** The ethereum address you want to login with */
  address: Scalars['EthereumAddress'];
};

export type ClaimHandleRequest = {
  /** The follow module */
  followModule?: InputMaybe<FollowModuleParams>;
  freeTextHandle?: InputMaybe<Scalars['CreateHandle']>;
  id?: InputMaybe<Scalars['HandleClaimIdScalar']>;
};

/** The claim status */
export enum ClaimStatus {
  AlreadyClaimed = 'ALREADY_CLAIMED',
  ClaimFailed = 'CLAIM_FAILED',
  NotClaimed = 'NOT_CLAIMED'
}

export type ClaimableHandles = {
  __typename?: 'ClaimableHandles';
  canClaimFreeTextHandle: Scalars['Boolean'];
  reservedHandles: Array<ReservedClaimableHandle>;
};

/** Condition that signifies if address or profile has collected a publication */
export type CollectConditionInput = {
  /** The publication id that has to be collected to unlock content */
  publicationId?: InputMaybe<Scalars['InternalPublicationId']>;
  /** True if the content will be unlocked for this specific publication */
  thisPublication?: InputMaybe<Scalars['Boolean']>;
};

/** Condition that signifies if address or profile has collected a publication */
export type CollectConditionOutput = {
  __typename?: 'CollectConditionOutput';
  /** The publication id that has to be collected to unlock content */
  publicationId?: Maybe<Scalars['InternalPublicationId']>;
  /** True if the content will be unlocked for this specific publication */
  thisPublication?: Maybe<Scalars['Boolean']>;
};

export type CollectModule = AaveFeeCollectModuleSettings | Erc4626FeeCollectModuleSettings | FeeCollectModuleSettings | FreeCollectModuleSettings | LimitedFeeCollectModuleSettings | LimitedTimedFeeCollectModuleSettings | MultirecipientFeeCollectModuleSettings | RevertCollectModuleSettings | SimpleCollectModuleSettings | TimedFeeCollectModuleSettings | UnknownCollectModuleSettings;

export type CollectModuleParams = {
  /** The collect aave fee collect module */
  aaveFeeCollectModule?: InputMaybe<AaveFeeCollectModuleParams>;
  /** The collect ERC4626 fee collect module */
  erc4626FeeCollectModule?: InputMaybe<Erc4626FeeCollectModuleParams>;
  /** The collect fee collect module */
  feeCollectModule?: InputMaybe<FeeCollectModuleParams>;
  /** The collect empty collect module */
  freeCollectModule?: InputMaybe<FreeCollectModuleParams>;
  /** The collect limited fee collect module */
  limitedFeeCollectModule?: InputMaybe<LimitedFeeCollectModuleParams>;
  /** The collect limited timed fee collect module */
  limitedTimedFeeCollectModule?: InputMaybe<LimitedTimedFeeCollectModuleParams>;
  /** The multirecipient fee collect module */
  multirecipientFeeCollectModule?: InputMaybe<MultirecipientFeeCollectModuleParams>;
  /** The collect revert collect module */
  revertCollectModule?: InputMaybe<Scalars['Boolean']>;
  /** The collect simple fee collect module */
  simpleCollectModule?: InputMaybe<SimpleCollectModuleParams>;
  /** The collect timed fee collect module */
  timedFeeCollectModule?: InputMaybe<TimedFeeCollectModuleParams>;
  /** A unknown collect module */
  unknownCollectModule?: InputMaybe<UnknownCollectModuleParams>;
};

/** The collect module types */
export enum CollectModules {
  AaveFeeCollectModule = 'AaveFeeCollectModule',
  Erc4626FeeCollectModule = 'ERC4626FeeCollectModule',
  FeeCollectModule = 'FeeCollectModule',
  FreeCollectModule = 'FreeCollectModule',
  LimitedFeeCollectModule = 'LimitedFeeCollectModule',
  LimitedTimedFeeCollectModule = 'LimitedTimedFeeCollectModule',
  MultirecipientFeeCollectModule = 'MultirecipientFeeCollectModule',
  RevertCollectModule = 'RevertCollectModule',
  SimpleCollectModule = 'SimpleCollectModule',
  TimedFeeCollectModule = 'TimedFeeCollectModule',
  UnknownCollectModule = 'UnknownCollectModule'
}

export type CollectProxyAction = {
  freeCollect?: InputMaybe<FreeCollectProxyAction>;
};

export type CollectedEvent = {
  __typename?: 'CollectedEvent';
  profile: Profile;
  timestamp: Scalars['DateTime'];
};

/** The social comment */
export type Comment = {
  __typename?: 'Comment';
  /** ID of the source */
  appId?: Maybe<Scalars['Sources']>;
  bookmarked: Scalars['Boolean'];
  canComment: CanCommentResponse;
  canDecrypt: CanDecryptResponse;
  canMirror: CanMirrorResponse;
  /** The collect module */
  collectModule: CollectModule;
  /** The contract address for the collect nft.. if its null it means nobody collected yet as it lazy deployed */
  collectNftAddress?: Maybe<Scalars['ContractAddress']>;
  /** Who collected it, this is used for timeline results and like this for better caching for the client */
  collectedBy?: Maybe<Wallet>;
  /** Which comment this points to if its null the pointer too deep so do another query to find it out */
  commentOn?: Maybe<Publication>;
  /** The date the post was created on */
  createdAt: Scalars['DateTime'];
  /** The data availability proofs you can fetch from */
  dataAvailabilityProofs?: Maybe<Scalars['String']>;
  /** This will bring back the first comment of a comment and only be defined if using `publication` query and `commentOf` */
  firstComment?: Maybe<Comment>;
  hasCollectedByMe: Scalars['Boolean'];
  /** If the publication has been hidden if it has then the content and media is not available */
  hidden: Scalars['Boolean'];
  /** The internal publication id */
  id: Scalars['InternalPublicationId'];
  /** Indicates if the publication is data availability post */
  isDataAvailability: Scalars['Boolean'];
  /** Indicates if the publication is gated behind some access criteria */
  isGated: Scalars['Boolean'];
  /** The top level post/mirror this comment lives on */
  mainPost: MainPostReference;
  /** The metadata for the post */
  metadata: MetadataOutput;
  mirrors: Array<Scalars['InternalPublicationId']>;
  notInterested: Scalars['Boolean'];
  /** The on chain content uri could be `ipfs://` or `https` */
  onChainContentURI: Scalars['String'];
  /** The profile ref */
  profile: Profile;
  /** Comment ranking score */
  rankingScore?: Maybe<Scalars['Float']>;
  reaction?: Maybe<ReactionTypes>;
  /** The reference module */
  referenceModule?: Maybe<ReferenceModule>;
  /** The publication stats */
  stats: PublicationStats;
};


/** The social comment */
export type CommentBookmarkedArgs = {
  by?: InputMaybe<Scalars['ProfileId']>;
};


/** The social comment */
export type CommentCanCommentArgs = {
  profileId?: InputMaybe<Scalars['ProfileId']>;
};


/** The social comment */
export type CommentCanDecryptArgs = {
  address?: InputMaybe<Scalars['EthereumAddress']>;
  profileId?: InputMaybe<Scalars['ProfileId']>;
};


/** The social comment */
export type CommentCanMirrorArgs = {
  profileId?: InputMaybe<Scalars['ProfileId']>;
};


/** The social comment */
export type CommentHasCollectedByMeArgs = {
  isFinalisedOnChain?: InputMaybe<Scalars['Boolean']>;
};


/** The social comment */
export type CommentMirrorsArgs = {
  by?: InputMaybe<Scalars['ProfileId']>;
};


/** The social comment */
export type CommentNotInterestedArgs = {
  by?: InputMaybe<Scalars['ProfileId']>;
};


/** The social comment */
export type CommentReactionArgs = {
  request?: InputMaybe<ReactionFieldResolverRequest>;
};

/** The comment ordering types */
export enum CommentOrderingTypes {
  Desc = 'DESC',
  Ranking = 'RANKING'
}

/** The comment ranking filter types */
export enum CommentRankingFilter {
  NoneRelevant = 'NONE_RELEVANT',
  Relevant = 'RELEVANT'
}

export type ConfigChangedEvent = Event & {
  __typename?: 'ConfigChangedEvent';
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  /**
   * The address of the governance contract the event was emitted from.
   *
   */
  governanceAddress: Scalars['Bytes'];
  host: Scalars['Bytes'];
  id: Scalars['ID'];
  isKeySet: Scalars['Boolean'];
  key: Scalars['Bytes'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  superToken: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
  value: Scalars['BigInt'];
};

export type ConfigChangedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<ConfigChangedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  governanceAddress?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_contains?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_gt?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_gte?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_in?: InputMaybe<Array<Scalars['Bytes']>>;
  governanceAddress_lt?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_lte?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not_contains?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  host?: InputMaybe<Scalars['Bytes']>;
  host_contains?: InputMaybe<Scalars['Bytes']>;
  host_gt?: InputMaybe<Scalars['Bytes']>;
  host_gte?: InputMaybe<Scalars['Bytes']>;
  host_in?: InputMaybe<Array<Scalars['Bytes']>>;
  host_lt?: InputMaybe<Scalars['Bytes']>;
  host_lte?: InputMaybe<Scalars['Bytes']>;
  host_not?: InputMaybe<Scalars['Bytes']>;
  host_not_contains?: InputMaybe<Scalars['Bytes']>;
  host_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  isKeySet?: InputMaybe<Scalars['Boolean']>;
  isKeySet_in?: InputMaybe<Array<Scalars['Boolean']>>;
  isKeySet_not?: InputMaybe<Scalars['Boolean']>;
  isKeySet_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  key?: InputMaybe<Scalars['Bytes']>;
  key_contains?: InputMaybe<Scalars['Bytes']>;
  key_gt?: InputMaybe<Scalars['Bytes']>;
  key_gte?: InputMaybe<Scalars['Bytes']>;
  key_in?: InputMaybe<Array<Scalars['Bytes']>>;
  key_lt?: InputMaybe<Scalars['Bytes']>;
  key_lte?: InputMaybe<Scalars['Bytes']>;
  key_not?: InputMaybe<Scalars['Bytes']>;
  key_not_contains?: InputMaybe<Scalars['Bytes']>;
  key_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<ConfigChangedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  superToken?: InputMaybe<Scalars['Bytes']>;
  superToken_contains?: InputMaybe<Scalars['Bytes']>;
  superToken_gt?: InputMaybe<Scalars['Bytes']>;
  superToken_gte?: InputMaybe<Scalars['Bytes']>;
  superToken_in?: InputMaybe<Array<Scalars['Bytes']>>;
  superToken_lt?: InputMaybe<Scalars['Bytes']>;
  superToken_lte?: InputMaybe<Scalars['Bytes']>;
  superToken_not?: InputMaybe<Scalars['Bytes']>;
  superToken_not_contains?: InputMaybe<Scalars['Bytes']>;
  superToken_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  value?: InputMaybe<Scalars['BigInt']>;
  value_gt?: InputMaybe<Scalars['BigInt']>;
  value_gte?: InputMaybe<Scalars['BigInt']>;
  value_in?: InputMaybe<Array<Scalars['BigInt']>>;
  value_lt?: InputMaybe<Scalars['BigInt']>;
  value_lte?: InputMaybe<Scalars['BigInt']>;
  value_not?: InputMaybe<Scalars['BigInt']>;
  value_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum ConfigChangedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  GovernanceAddress = 'governanceAddress',
  Host = 'host',
  Id = 'id',
  IsKeySet = 'isKeySet',
  Key = 'key',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  SuperToken = 'superToken',
  Timestamp = 'timestamp',
  TransactionHash = 'transactionHash',
  Value = 'value'
}

/** The gated publication access criteria contract types */
export enum ContractType {
  Erc20 = 'ERC20',
  Erc721 = 'ERC721',
  Erc1155 = 'ERC1155'
}

/** The create burn eip 712 typed data */
export type CreateBurnEip712TypedData = {
  __typename?: 'CreateBurnEIP712TypedData';
  /** The typed data domain */
  domain: Eip712TypedDataDomain;
  /** The types */
  types: CreateBurnEip712TypedDataTypes;
  /** The values */
  value: CreateBurnEip712TypedDataValue;
};

/** The create burn eip 712 typed data types */
export type CreateBurnEip712TypedDataTypes = {
  __typename?: 'CreateBurnEIP712TypedDataTypes';
  BurnWithSig: Array<Eip712TypedDataField>;
};

/** The create burn eip 712 typed data value */
export type CreateBurnEip712TypedDataValue = {
  __typename?: 'CreateBurnEIP712TypedDataValue';
  deadline: Scalars['UnixTimestamp'];
  nonce: Scalars['Nonce'];
  tokenId: Scalars['String'];
};

/** The broadcast item */
export type CreateBurnProfileBroadcastItemResult = {
  __typename?: 'CreateBurnProfileBroadcastItemResult';
  /** The date the broadcast item expiries */
  expiresAt: Scalars['DateTime'];
  /** This broadcast item ID */
  id: Scalars['BroadcastId'];
  /** The typed data */
  typedData: CreateBurnEip712TypedData;
};

/** The broadcast item */
export type CreateCollectBroadcastItemResult = {
  __typename?: 'CreateCollectBroadcastItemResult';
  /** The date the broadcast item expiries */
  expiresAt: Scalars['DateTime'];
  /** This broadcast item ID */
  id: Scalars['BroadcastId'];
  /** The typed data */
  typedData: CreateCollectEip712TypedData;
};

/** The collect eip 712 typed data */
export type CreateCollectEip712TypedData = {
  __typename?: 'CreateCollectEIP712TypedData';
  /** The typed data domain */
  domain: Eip712TypedDataDomain;
  /** The types */
  types: CreateCollectEip712TypedDataTypes;
  /** The values */
  value: CreateCollectEip712TypedDataValue;
};

/** The collect eip 712 typed data types */
export type CreateCollectEip712TypedDataTypes = {
  __typename?: 'CreateCollectEIP712TypedDataTypes';
  CollectWithSig: Array<Eip712TypedDataField>;
};

/** The collect eip 712 typed data value */
export type CreateCollectEip712TypedDataValue = {
  __typename?: 'CreateCollectEIP712TypedDataValue';
  data: Scalars['BlockchainData'];
  deadline: Scalars['UnixTimestamp'];
  nonce: Scalars['Nonce'];
  profileId: Scalars['ProfileId'];
  pubId: Scalars['PublicationId'];
};

export type CreateCollectRequest = {
  publicationId: Scalars['InternalPublicationId'];
  /** The encoded data to collect with if using an unknown module */
  unknownModuleData?: InputMaybe<Scalars['BlockchainData']>;
};

/** The broadcast item */
export type CreateCommentBroadcastItemResult = {
  __typename?: 'CreateCommentBroadcastItemResult';
  /** The date the broadcast item expiries */
  expiresAt: Scalars['DateTime'];
  /** This broadcast item ID */
  id: Scalars['BroadcastId'];
  /** The typed data */
  typedData: CreateCommentEip712TypedData;
};

/** The create comment eip 712 typed data */
export type CreateCommentEip712TypedData = {
  __typename?: 'CreateCommentEIP712TypedData';
  /** The typed data domain */
  domain: Eip712TypedDataDomain;
  /** The types */
  types: CreateCommentEip712TypedDataTypes;
  /** The values */
  value: CreateCommentEip712TypedDataValue;
};

/** The create comment eip 712 typed data types */
export type CreateCommentEip712TypedDataTypes = {
  __typename?: 'CreateCommentEIP712TypedDataTypes';
  CommentWithSig: Array<Eip712TypedDataField>;
};

/** The create comment eip 712 typed data value */
export type CreateCommentEip712TypedDataValue = {
  __typename?: 'CreateCommentEIP712TypedDataValue';
  collectModule: Scalars['ContractAddress'];
  collectModuleInitData: Scalars['CollectModuleData'];
  contentURI: Scalars['PublicationUrl'];
  deadline: Scalars['UnixTimestamp'];
  nonce: Scalars['Nonce'];
  profileId: Scalars['ProfileId'];
  profileIdPointed: Scalars['ProfileId'];
  pubIdPointed: Scalars['PublicationId'];
  referenceModule: Scalars['ContractAddress'];
  referenceModuleData: Scalars['ReferenceModuleData'];
  referenceModuleInitData: Scalars['ReferenceModuleData'];
};

export type CreateDataAvailabilityCommentRequest = {
  /** Publication your commenting on */
  commentOn: Scalars['InternalPublicationId'];
  /** The metadata contentURI resolver */
  contentURI: Scalars['Url'];
  /** Profile id */
  from: Scalars['ProfileId'];
};

export type CreateDataAvailabilityMirrorRequest = {
  /** Profile id which will broadcast the mirror */
  from: Scalars['ProfileId'];
  /** The publication to mirror */
  mirror: Scalars['InternalPublicationId'];
};

export type CreateDataAvailabilityPostRequest = {
  /** The metadata contentURI resolver */
  contentURI: Scalars['Url'];
  /** Profile id */
  from: Scalars['ProfileId'];
};

export type CreateDataAvailabilityPublicationResult = {
  __typename?: 'CreateDataAvailabilityPublicationResult';
  /** The data availability id */
  dataAvailabilityId: Scalars['DataAvailabilityId'];
  /** The id of the post */
  id: Scalars['InternalPublicationId'];
  /** The proofs for the DA */
  proofs: Scalars['String'];
};

/** The broadcast item */
export type CreateFollowBroadcastItemResult = {
  __typename?: 'CreateFollowBroadcastItemResult';
  /** The date the broadcast item expiries */
  expiresAt: Scalars['DateTime'];
  /** This broadcast item ID */
  id: Scalars['BroadcastId'];
  /** The typed data */
  typedData: CreateFollowEip712TypedData;
};

/** The create follow eip 712 typed data */
export type CreateFollowEip712TypedData = {
  __typename?: 'CreateFollowEIP712TypedData';
  /** The typed data domain */
  domain: Eip712TypedDataDomain;
  /** The types */
  types: CreateFollowEip712TypedDataTypes;
  /** The values */
  value: CreateFollowEip712TypedDataValue;
};

/** The create follow eip 712 typed data types */
export type CreateFollowEip712TypedDataTypes = {
  __typename?: 'CreateFollowEIP712TypedDataTypes';
  FollowWithSig: Array<Eip712TypedDataField>;
};

/** The create follow eip 712 typed data value */
export type CreateFollowEip712TypedDataValue = {
  __typename?: 'CreateFollowEIP712TypedDataValue';
  datas: Array<Scalars['BlockchainData']>;
  deadline: Scalars['UnixTimestamp'];
  nonce: Scalars['Nonce'];
  profileIds: Array<Scalars['ProfileId']>;
};

/** The broadcast item */
export type CreateMirrorBroadcastItemResult = {
  __typename?: 'CreateMirrorBroadcastItemResult';
  /** The date the broadcast item expiries */
  expiresAt: Scalars['DateTime'];
  /** This broadcast item ID */
  id: Scalars['BroadcastId'];
  /** The typed data */
  typedData: CreateMirrorEip712TypedData;
};

/** The mirror eip 712 typed data */
export type CreateMirrorEip712TypedData = {
  __typename?: 'CreateMirrorEIP712TypedData';
  /** The typed data domain */
  domain: Eip712TypedDataDomain;
  /** The types */
  types: CreateMirrorEip712TypedDataTypes;
  /** The values */
  value: CreateMirrorEip712TypedDataValue;
};

/** The mirror eip 712 typed data types */
export type CreateMirrorEip712TypedDataTypes = {
  __typename?: 'CreateMirrorEIP712TypedDataTypes';
  MirrorWithSig: Array<Eip712TypedDataField>;
};

/** The mirror eip 712 typed data value */
export type CreateMirrorEip712TypedDataValue = {
  __typename?: 'CreateMirrorEIP712TypedDataValue';
  deadline: Scalars['UnixTimestamp'];
  nonce: Scalars['Nonce'];
  profileId: Scalars['ProfileId'];
  profileIdPointed: Scalars['ProfileId'];
  pubIdPointed: Scalars['PublicationId'];
  referenceModule: Scalars['ContractAddress'];
  referenceModuleData: Scalars['ReferenceModuleData'];
  referenceModuleInitData: Scalars['ReferenceModuleData'];
};

export type CreateMirrorRequest = {
  /** Profile id */
  profileId: Scalars['ProfileId'];
  /** Publication id of what you want to mirror on remember if this is a comment it will be that as the id */
  publicationId: Scalars['InternalPublicationId'];
  /** The reference module info */
  referenceModule?: InputMaybe<ReferenceModuleParams>;
};

/** The broadcast item */
export type CreatePostBroadcastItemResult = {
  __typename?: 'CreatePostBroadcastItemResult';
  /** The date the broadcast item expiries */
  expiresAt: Scalars['DateTime'];
  /** This broadcast item ID */
  id: Scalars['BroadcastId'];
  /** The typed data */
  typedData: CreatePostEip712TypedData;
};

/** The create post eip 712 typed data */
export type CreatePostEip712TypedData = {
  __typename?: 'CreatePostEIP712TypedData';
  /** The typed data domain */
  domain: Eip712TypedDataDomain;
  /** The types */
  types: CreatePostEip712TypedDataTypes;
  /** The values */
  value: CreatePostEip712TypedDataValue;
};

/** The create post eip 712 typed data types */
export type CreatePostEip712TypedDataTypes = {
  __typename?: 'CreatePostEIP712TypedDataTypes';
  PostWithSig: Array<Eip712TypedDataField>;
};

/** The create post eip 712 typed data value */
export type CreatePostEip712TypedDataValue = {
  __typename?: 'CreatePostEIP712TypedDataValue';
  collectModule: Scalars['ContractAddress'];
  collectModuleInitData: Scalars['CollectModuleData'];
  contentURI: Scalars['PublicationUrl'];
  deadline: Scalars['UnixTimestamp'];
  nonce: Scalars['Nonce'];
  profileId: Scalars['ProfileId'];
  referenceModule: Scalars['ContractAddress'];
  referenceModuleInitData: Scalars['ReferenceModuleData'];
};

export type CreateProfileRequest = {
  /** The follow module */
  followModule?: InputMaybe<FollowModuleParams>;
  /** The follow NFT URI is the NFT metadata your followers will mint when they follow you. This can be updated at all times. If you do not pass in anything it will create a super cool changing NFT which will show the last publication of your profile as the NFT which looks awesome! This means people do not have to worry about writing this logic but still have the ability to customise it for their followers */
  followNFTURI?: InputMaybe<Scalars['Url']>;
  handle: Scalars['CreateHandle'];
  /** The profile picture uri */
  profilePictureUri?: InputMaybe<Scalars['Url']>;
};

export type CreatePublicCommentRequest = {
  /** The collect module */
  collectModule: CollectModuleParams;
  /** The metadata contentURI resolver */
  contentURI: Scalars['Url'];
  /** The criteria to access the publication data */
  gated?: InputMaybe<GatedPublicationParamsInput>;
  /** Profile id */
  profileId: Scalars['ProfileId'];
  /** Publication id of what your comments on remember if this is a comment you commented on it will be that as the id */
  publicationId: Scalars['InternalPublicationId'];
  /** The reference module */
  referenceModule?: InputMaybe<ReferenceModuleParams>;
};

export type CreatePublicPostRequest = {
  /** The collect module */
  collectModule: CollectModuleParams;
  /** The metadata uploaded somewhere passing in the url to reach it */
  contentURI: Scalars['Url'];
  /** The criteria to access the publication data */
  gated?: InputMaybe<GatedPublicationParamsInput>;
  /** Profile id */
  profileId: Scalars['ProfileId'];
  /** The reference module */
  referenceModule?: InputMaybe<ReferenceModuleParams>;
};

export type CreatePublicSetProfileMetadataUriRequest = {
  /** The metadata uploaded somewhere passing in the url to reach it */
  metadata: Scalars['Url'];
  /** Profile id */
  profileId: Scalars['ProfileId'];
};

export type CreateSetDefaultProfileRequest = {
  /** Profile id */
  profileId: Scalars['ProfileId'];
};

/** The broadcast item */
export type CreateSetDispatcherBroadcastItemResult = {
  __typename?: 'CreateSetDispatcherBroadcastItemResult';
  /** The date the broadcast item expiries */
  expiresAt: Scalars['DateTime'];
  /** This broadcast item ID */
  id: Scalars['BroadcastId'];
  /** The typed data */
  typedData: CreateSetDispatcherEip712TypedData;
};

/** The set dispatcher eip 712 typed data */
export type CreateSetDispatcherEip712TypedData = {
  __typename?: 'CreateSetDispatcherEIP712TypedData';
  /** The typed data domain */
  domain: Eip712TypedDataDomain;
  /** The types */
  types: CreateSetDispatcherEip712TypedDataTypes;
  /** The values */
  value: CreateSetDispatcherEip712TypedDataValue;
};

/** The set dispatcher eip 712 typed data types */
export type CreateSetDispatcherEip712TypedDataTypes = {
  __typename?: 'CreateSetDispatcherEIP712TypedDataTypes';
  SetDispatcherWithSig: Array<Eip712TypedDataField>;
};

/** The set dispatcher eip 712 typed data value */
export type CreateSetDispatcherEip712TypedDataValue = {
  __typename?: 'CreateSetDispatcherEIP712TypedDataValue';
  deadline: Scalars['UnixTimestamp'];
  dispatcher: Scalars['EthereumAddress'];
  nonce: Scalars['Nonce'];
  profileId: Scalars['ProfileId'];
};

/** The broadcast item */
export type CreateSetFollowModuleBroadcastItemResult = {
  __typename?: 'CreateSetFollowModuleBroadcastItemResult';
  /** The date the broadcast item expiries */
  expiresAt: Scalars['DateTime'];
  /** This broadcast item ID */
  id: Scalars['BroadcastId'];
  /** The typed data */
  typedData: CreateSetFollowModuleEip712TypedData;
};

/** The set follow module eip 712 typed data */
export type CreateSetFollowModuleEip712TypedData = {
  __typename?: 'CreateSetFollowModuleEIP712TypedData';
  /** The typed data domain */
  domain: Eip712TypedDataDomain;
  /** The types */
  types: CreateSetFollowModuleEip712TypedDataTypes;
  /** The values */
  value: CreateSetFollowModuleEip712TypedDataValue;
};

/** The set follow module eip 712 typed data types */
export type CreateSetFollowModuleEip712TypedDataTypes = {
  __typename?: 'CreateSetFollowModuleEIP712TypedDataTypes';
  SetFollowModuleWithSig: Array<Eip712TypedDataField>;
};

/** The set follow module eip 712 typed data value */
export type CreateSetFollowModuleEip712TypedDataValue = {
  __typename?: 'CreateSetFollowModuleEIP712TypedDataValue';
  deadline: Scalars['UnixTimestamp'];
  followModule: Scalars['ContractAddress'];
  followModuleInitData: Scalars['FollowModuleData'];
  nonce: Scalars['Nonce'];
  profileId: Scalars['ProfileId'];
};

export type CreateSetFollowModuleRequest = {
  /** The follow module info */
  followModule: FollowModuleParams;
  profileId: Scalars['ProfileId'];
};

/** The broadcast item */
export type CreateSetFollowNftUriBroadcastItemResult = {
  __typename?: 'CreateSetFollowNFTUriBroadcastItemResult';
  /** The date the broadcast item expiries */
  expiresAt: Scalars['DateTime'];
  /** This broadcast item ID */
  id: Scalars['BroadcastId'];
  /** The typed data */
  typedData: CreateSetFollowNftUriEip712TypedData;
};

/** The set follow nft uri eip 712 typed data */
export type CreateSetFollowNftUriEip712TypedData = {
  __typename?: 'CreateSetFollowNFTUriEIP712TypedData';
  /** The typed data domain */
  domain: Eip712TypedDataDomain;
  /** The types */
  types: CreateSetFollowNftUriEip712TypedDataTypes;
  /** The values */
  value: CreateSetFollowNftUriEip712TypedDataValue;
};

/** The set follow nft uri eip 712 typed data types */
export type CreateSetFollowNftUriEip712TypedDataTypes = {
  __typename?: 'CreateSetFollowNFTUriEIP712TypedDataTypes';
  SetFollowNFTURIWithSig: Array<Eip712TypedDataField>;
};

/** The set follow nft uri eip 712 typed data value */
export type CreateSetFollowNftUriEip712TypedDataValue = {
  __typename?: 'CreateSetFollowNFTUriEIP712TypedDataValue';
  deadline: Scalars['UnixTimestamp'];
  followNFTURI: Scalars['Url'];
  nonce: Scalars['Nonce'];
  profileId: Scalars['ProfileId'];
};

export type CreateSetFollowNftUriRequest = {
  /** The follow NFT URI is the NFT metadata your followers will mint when they follow you. This can be updated at all times. If you do not pass in anything it will create a super cool changing NFT which will show the last publication of your profile as the NFT which looks awesome! This means people do not have to worry about writing this logic but still have the ability to customise it for their followers */
  followNFTURI?: InputMaybe<Scalars['Url']>;
  profileId: Scalars['ProfileId'];
};

/** The broadcast item */
export type CreateSetProfileImageUriBroadcastItemResult = {
  __typename?: 'CreateSetProfileImageUriBroadcastItemResult';
  /** The date the broadcast item expiries */
  expiresAt: Scalars['DateTime'];
  /** This broadcast item ID */
  id: Scalars['BroadcastId'];
  /** The typed data */
  typedData: CreateSetProfileImageUriEip712TypedData;
};

/** The set profile uri eip 712 typed data */
export type CreateSetProfileImageUriEip712TypedData = {
  __typename?: 'CreateSetProfileImageUriEIP712TypedData';
  /** The typed data domain */
  domain: Eip712TypedDataDomain;
  /** The types */
  types: CreateSetProfileImageUriEip712TypedDataTypes;
  /** The values */
  value: CreateSetProfileImageUriEip712TypedDataValue;
};

/** The set profile image uri eip 712 typed data types */
export type CreateSetProfileImageUriEip712TypedDataTypes = {
  __typename?: 'CreateSetProfileImageUriEIP712TypedDataTypes';
  SetProfileImageURIWithSig: Array<Eip712TypedDataField>;
};

/** The set profile uri eip 712 typed data value */
export type CreateSetProfileImageUriEip712TypedDataValue = {
  __typename?: 'CreateSetProfileImageUriEIP712TypedDataValue';
  deadline: Scalars['UnixTimestamp'];
  imageURI: Scalars['Url'];
  nonce: Scalars['Nonce'];
  profileId: Scalars['ProfileId'];
};

/** The broadcast item */
export type CreateSetProfileMetadataUriBroadcastItemResult = {
  __typename?: 'CreateSetProfileMetadataURIBroadcastItemResult';
  /** The date the broadcast item expiries */
  expiresAt: Scalars['DateTime'];
  /** This broadcast item ID */
  id: Scalars['BroadcastId'];
  /** The typed data */
  typedData: CreateSetProfileMetadataUrieip712TypedData;
};

/** The set follow nft uri eip 712 typed data */
export type CreateSetProfileMetadataUrieip712TypedData = {
  __typename?: 'CreateSetProfileMetadataURIEIP712TypedData';
  /** The typed data domain */
  domain: Eip712TypedDataDomain;
  /** The types */
  types: CreateSetProfileMetadataUrieip712TypedDataTypes;
  /** The values */
  value: CreateSetProfileMetadataUrieip712TypedDataValue;
};

/** The set follow nft uri eip 712 typed data types */
export type CreateSetProfileMetadataUrieip712TypedDataTypes = {
  __typename?: 'CreateSetProfileMetadataURIEIP712TypedDataTypes';
  SetProfileMetadataURIWithSig: Array<Eip712TypedDataField>;
};

/** The set follow nft uri eip 712 typed data value */
export type CreateSetProfileMetadataUrieip712TypedDataValue = {
  __typename?: 'CreateSetProfileMetadataURIEIP712TypedDataValue';
  deadline: Scalars['UnixTimestamp'];
  metadata: Scalars['Url'];
  nonce: Scalars['Nonce'];
  profileId: Scalars['ProfileId'];
};

/** The broadcast item */
export type CreateToggleFollowBroadcastItemResult = {
  __typename?: 'CreateToggleFollowBroadcastItemResult';
  /** The date the broadcast item expiries */
  expiresAt: Scalars['DateTime'];
  /** This broadcast item ID */
  id: Scalars['BroadcastId'];
  /** The typed data */
  typedData: CreateToggleFollowEip712TypedData;
};

/** The create toggle follows eip 712 typed data */
export type CreateToggleFollowEip712TypedData = {
  __typename?: 'CreateToggleFollowEIP712TypedData';
  /** The typed data domain */
  domain: Eip712TypedDataDomain;
  /** The types */
  types: CreateToggleFollowEip712TypedDataTypes;
  /** The values */
  value: CreateToggleFollowEip712TypedDataValue;
};

/** The create toggle follows eip 712 typed data types */
export type CreateToggleFollowEip712TypedDataTypes = {
  __typename?: 'CreateToggleFollowEIP712TypedDataTypes';
  ToggleFollowWithSig: Array<Eip712TypedDataField>;
};

/** The create toggle follow eip 712 typed data value */
export type CreateToggleFollowEip712TypedDataValue = {
  __typename?: 'CreateToggleFollowEIP712TypedDataValue';
  deadline: Scalars['UnixTimestamp'];
  enables: Array<Scalars['Boolean']>;
  nonce: Scalars['Nonce'];
  profileIds: Array<Scalars['ProfileId']>;
};

export type CreateToggleFollowRequest = {
  enables: Array<Scalars['Boolean']>;
  profileIds: Array<Scalars['ProfileId']>;
};

/** The broadcast item */
export type CreateUnfollowBroadcastItemResult = {
  __typename?: 'CreateUnfollowBroadcastItemResult';
  /** The date the broadcast item expiries */
  expiresAt: Scalars['DateTime'];
  /** This broadcast item ID */
  id: Scalars['BroadcastId'];
  /** The typed data */
  typedData: CreateBurnEip712TypedData;
};

export type CurRequest = {
  secret: Scalars['String'];
};

/** The custom filters types */
export enum CustomFiltersTypes {
  Gardeners = 'GARDENERS'
}

export type CustomSuperTokenCreatedEvent = Event & {
  __typename?: 'CustomSuperTokenCreatedEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
};

export type CustomSuperTokenCreatedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<CustomSuperTokenCreatedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<CustomSuperTokenCreatedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum CustomSuperTokenCreatedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash'
}

export type DataAvailabilityComment = {
  __typename?: 'DataAvailabilityComment';
  appId?: Maybe<Scalars['Sources']>;
  commentedOnProfile: Profile;
  commentedOnPublicationId: Scalars['InternalPublicationId'];
  createdAt: Scalars['DateTime'];
  profile: Profile;
  publicationId: Scalars['InternalPublicationId'];
  submitter: Scalars['EthereumAddress'];
  transactionId: Scalars['String'];
  verificationStatus: DataAvailabilityVerificationStatusUnion;
};

export type DataAvailabilityMirror = {
  __typename?: 'DataAvailabilityMirror';
  appId?: Maybe<Scalars['Sources']>;
  createdAt: Scalars['DateTime'];
  mirrorOfProfile: Profile;
  mirrorOfPublicationId: Scalars['InternalPublicationId'];
  profile: Profile;
  publicationId: Scalars['InternalPublicationId'];
  submitter: Scalars['EthereumAddress'];
  transactionId: Scalars['String'];
  verificationStatus: DataAvailabilityVerificationStatusUnion;
};

export type DataAvailabilityPost = {
  __typename?: 'DataAvailabilityPost';
  appId?: Maybe<Scalars['Sources']>;
  createdAt: Scalars['DateTime'];
  profile: Profile;
  publicationId: Scalars['InternalPublicationId'];
  submitter: Scalars['EthereumAddress'];
  transactionId: Scalars['String'];
  verificationStatus: DataAvailabilityVerificationStatusUnion;
};

export type DataAvailabilitySubmitterResult = {
  __typename?: 'DataAvailabilitySubmitterResult';
  address: Scalars['EthereumAddress'];
  name: Scalars['String'];
  totalTransactions: Scalars['Int'];
};

/** The paginated submitter results */
export type DataAvailabilitySubmittersResult = {
  __typename?: 'DataAvailabilitySubmittersResult';
  items: Array<DataAvailabilitySubmitterResult>;
  pageInfo: PaginatedResultInfo;
};

export type DataAvailabilitySummaryResult = {
  __typename?: 'DataAvailabilitySummaryResult';
  totalTransactions: Scalars['Int'];
};

export type DataAvailabilityTransactionRequest = {
  /** The DA transaction id or internal publiation id */
  id: Scalars['String'];
};

export type DataAvailabilityTransactionUnion = DataAvailabilityComment | DataAvailabilityMirror | DataAvailabilityPost;

export type DataAvailabilityTransactionsRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  profileId?: InputMaybe<Scalars['ProfileId']>;
};

export type DataAvailabilityTransactionsResult = {
  __typename?: 'DataAvailabilityTransactionsResult';
  items: Array<DataAvailabilityTransactionUnion>;
  pageInfo: PaginatedResultInfo;
};

export type DataAvailabilityVerificationStatusFailure = {
  __typename?: 'DataAvailabilityVerificationStatusFailure';
  status?: Maybe<MomokaValidatorError>;
};

export type DataAvailabilityVerificationStatusSuccess = {
  __typename?: 'DataAvailabilityVerificationStatusSuccess';
  verified: Scalars['Boolean'];
};

export type DataAvailabilityVerificationStatusUnion = DataAvailabilityVerificationStatusFailure | DataAvailabilityVerificationStatusSuccess;

/** The reason why a profile cannot decrypt a publication */
export enum DecryptFailReason {
  CanNotDecrypt = 'CAN_NOT_DECRYPT',
  CollectNotFinalisedOnChain = 'COLLECT_NOT_FINALISED_ON_CHAIN',
  DoesNotFollowProfile = 'DOES_NOT_FOLLOW_PROFILE',
  DoesNotOwnNft = 'DOES_NOT_OWN_NFT',
  DoesNotOwnProfile = 'DOES_NOT_OWN_PROFILE',
  FollowNotFinalisedOnChain = 'FOLLOW_NOT_FINALISED_ON_CHAIN',
  HasNotCollectedPublication = 'HAS_NOT_COLLECTED_PUBLICATION',
  MissingEncryptionParams = 'MISSING_ENCRYPTION_PARAMS',
  ProfileDoesNotExist = 'PROFILE_DOES_NOT_EXIST',
  UnauthorizedAddress = 'UNAUTHORIZED_ADDRESS',
  UnauthorizedBalance = 'UNAUTHORIZED_BALANCE'
}

export type DefaultProfileRequest = {
  ethereumAddress: Scalars['EthereumAddress'];
};

export type DegreesOfSeparationReferenceModuleParams = {
  /** Applied to comments */
  commentsRestricted: Scalars['Boolean'];
  /** Degrees of separation */
  degreesOfSeparation: Scalars['Int'];
  /** Applied to mirrors */
  mirrorsRestricted: Scalars['Boolean'];
};

export type DegreesOfSeparationReferenceModuleSettings = {
  __typename?: 'DegreesOfSeparationReferenceModuleSettings';
  /** Applied to comments */
  commentsRestricted: Scalars['Boolean'];
  contractAddress: Scalars['ContractAddress'];
  /** Degrees of separation */
  degreesOfSeparation: Scalars['Int'];
  /** Applied to mirrors */
  mirrorsRestricted: Scalars['Boolean'];
  /** The reference modules enum */
  type: ReferenceModules;
};

export type DismissRecommendedProfilesRequest = {
  profileIds: Array<Scalars['ProfileId']>;
};

/** The dispatcher */
export type Dispatcher = {
  __typename?: 'Dispatcher';
  /** The dispatcher address */
  address: Scalars['EthereumAddress'];
  /** If the dispatcher can use the relay */
  canUseRelay: Scalars['Boolean'];
  /** If the dispatcher transactions will be sponsored by lens aka cover the gas costs */
  sponsor: Scalars['Boolean'];
};

export type DoesFollow = {
  /** The follower address remember wallets follow profiles */
  followerAddress: Scalars['EthereumAddress'];
  /** The profile id */
  profileId: Scalars['ProfileId'];
};

export type DoesFollowRequest = {
  /** The follower infos */
  followInfos: Array<DoesFollow>;
};

/** The does follow response */
export type DoesFollowResponse = {
  __typename?: 'DoesFollowResponse';
  /** The follower address remember wallets follow profiles */
  followerAddress: Scalars['EthereumAddress'];
  /** If the user does follow */
  follows: Scalars['Boolean'];
  /** Is finalised on-chain */
  isFinalisedOnChain: Scalars['Boolean'];
  /** The profile id */
  profileId: Scalars['ProfileId'];
};

/** The eip 712 typed data domain */
export type Eip712TypedDataDomain = {
  __typename?: 'EIP712TypedDataDomain';
  /** The chainId */
  chainId: Scalars['ChainId'];
  /** The name of the typed data domain */
  name: Scalars['String'];
  /** The verifying contract */
  verifyingContract: Scalars['ContractAddress'];
  /** The version */
  version: Scalars['String'];
};

/** The eip 712 typed data field */
export type Eip712TypedDataField = {
  __typename?: 'EIP712TypedDataField';
  /** The name of the typed data field */
  name: Scalars['String'];
  /** The type of the typed data field */
  type: Scalars['String'];
};

export type Erc4626FeeCollectModuleParams = {
  /** The collecting cost associated with this publication. 0 for free collect. */
  amount: ModuleFeeAmountParams;
  /** The maximum number of collects for this publication. Omit for no limit. */
  collectLimit?: InputMaybe<Scalars['String']>;
  /** The end timestamp after which collecting is impossible. Omit for no expiry. */
  endTimestamp?: InputMaybe<Scalars['DateTime']>;
  /** True if only followers of publisher may collect the post. */
  followerOnly: Scalars['Boolean'];
  /** The address of the recipient who will recieve vault shares after depositing is completed. */
  recipient: Scalars['EthereumAddress'];
  /** The referral fee associated with this publication. */
  referralFee?: InputMaybe<Scalars['Float']>;
  /** The address of the ERC4626 vault to deposit funds to. */
  vault: Scalars['ContractAddress'];
};

export type Erc4626FeeCollectModuleSettings = {
  __typename?: 'ERC4626FeeCollectModuleSettings';
  /** The collect module amount info */
  amount: ModuleFeeAmount;
  /** The maximum number of collects for this publication. 0 for no limit. */
  collectLimit?: Maybe<Scalars['String']>;
  contractAddress: Scalars['ContractAddress'];
  /** The end timestamp after which collecting is impossible. 0 for no expiry. */
  endTimestamp?: Maybe<Scalars['DateTime']>;
  /** True if only followers of publisher may collect the post. */
  followerOnly: Scalars['Boolean'];
  /** The recipient of the ERC4626 vault shares */
  recipient: Scalars['EthereumAddress'];
  /** The referral fee associated with this publication. */
  referralFee: Scalars['Float'];
  /** The collect modules enum */
  type: CollectModules;
  /** The ERC4626 vault address */
  vault: Scalars['ContractAddress'];
};

export type ElectedMirror = {
  __typename?: 'ElectedMirror';
  mirrorId: Scalars['InternalPublicationId'];
  profile: Profile;
  timestamp: Scalars['DateTime'];
};

export type EnabledModule = {
  __typename?: 'EnabledModule';
  contractAddress: Scalars['ContractAddress'];
  inputParams: Array<ModuleInfo>;
  moduleName: Scalars['String'];
  redeemParams: Array<ModuleInfo>;
  returnDataParms: Array<ModuleInfo>;
};

/** The enabled modules */
export type EnabledModules = {
  __typename?: 'EnabledModules';
  collectModules: Array<EnabledModule>;
  followModules: Array<EnabledModule>;
  referenceModules: Array<EnabledModule>;
};

/** The encrypted fields */
export type EncryptedFieldsOutput = {
  __typename?: 'EncryptedFieldsOutput';
  /** The encrypted animation_url field */
  animation_url?: Maybe<Scalars['EncryptedValueScalar']>;
  /** The encrypted content field */
  content?: Maybe<Scalars['EncryptedValueScalar']>;
  /** The encrypted external_url field */
  external_url?: Maybe<Scalars['EncryptedValueScalar']>;
  /** The encrypted image field */
  image?: Maybe<Scalars['EncryptedValueScalar']>;
  /** The encrypted media field */
  media?: Maybe<Array<EncryptedMediaSet>>;
};

/** The Encrypted Media url and metadata */
export type EncryptedMedia = {
  __typename?: 'EncryptedMedia';
  /** The encrypted alt tags for accessibility */
  altTag?: Maybe<Scalars['EncryptedValueScalar']>;
  /** The encrypted cover for any video or audio you attached */
  cover?: Maybe<Scalars['EncryptedValueScalar']>;
  /** Height - will always be null on the public API */
  height?: Maybe<Scalars['Int']>;
  /** The image/audio/video mime type for the publication */
  mimeType?: Maybe<Scalars['MimeType']>;
  /** Size - will always be null on the public API */
  size?: Maybe<Scalars['Int']>;
  /** The encrypted value for the URL */
  url: Scalars['Url'];
  /** Width - will always be null on the public API */
  width?: Maybe<Scalars['Int']>;
};

/** The encrypted media set */
export type EncryptedMediaSet = {
  __typename?: 'EncryptedMediaSet';
  /**
   * Medium media - will always be null on the public API
   * @deprecated should not be used will always be null
   */
  medium?: Maybe<EncryptedMedia>;
  /** Original media */
  original: EncryptedMedia;
  /**
   * Small media - will always be null on the public API
   * @deprecated should not be used will always be null
   */
  small?: Maybe<EncryptedMedia>;
};

/** The metadata encryption params */
export type EncryptionParamsOutput = {
  __typename?: 'EncryptionParamsOutput';
  /** The access conditions */
  accessCondition: AccessConditionOutput;
  /** The encrypted fields */
  encryptedFields: EncryptedFieldsOutput;
  /** The encryption provider */
  encryptionProvider: EncryptionProvider;
  /** The provider-specific encryption params */
  providerSpecificParams: ProviderSpecificParamsOutput;
};

/** The gated publication encryption provider */
export enum EncryptionProvider {
  LitProtocol = 'LIT_PROTOCOL'
}

export type EnsOnChainIdentity = {
  __typename?: 'EnsOnChainIdentity';
  /** The default ens mapped to this address */
  name?: Maybe<Scalars['Ens']>;
};

export type EoaOwnershipInput = {
  /** The address that will have access to the content */
  address: Scalars['EthereumAddress'];
};

export type EoaOwnershipOutput = {
  __typename?: 'EoaOwnershipOutput';
  /** The address that will have access to the content */
  address: Scalars['EthereumAddress'];
};

/** The erc20 type */
export type Erc20 = {
  __typename?: 'Erc20';
  /** The erc20 address */
  address: Scalars['ContractAddress'];
  /** Decimal places for the token */
  decimals: Scalars['Int'];
  /** Name of the symbol */
  name: Scalars['String'];
  /** Symbol for the token */
  symbol: Scalars['String'];
};

export type Erc20Amount = {
  __typename?: 'Erc20Amount';
  /** The erc20 token info */
  asset: Erc20;
  /** Floating point number as string (e.g. 42.009837). It could have the entire precision of the Asset or be truncated to the last significant decimal. */
  value: Scalars['String'];
};

export type Erc20OwnershipInput = {
  /** The amount of tokens required to access the content */
  amount: Scalars['String'];
  /** The amount of tokens required to access the content */
  chainID: Scalars['ChainId'];
  /** The operator to use when comparing the amount of tokens */
  condition: ScalarOperator;
  /** The ERC20 token ethereum address */
  contractAddress: Scalars['ContractAddress'];
  /** The amount of decimals of the ERC20 contract */
  decimals: Scalars['Float'];
};

export type Erc20OwnershipOutput = {
  __typename?: 'Erc20OwnershipOutput';
  /** The amount of tokens required to access the content */
  amount: Scalars['String'];
  /** The amount of tokens required to access the content */
  chainID: Scalars['ChainId'];
  /** The operator to use when comparing the amount of tokens */
  condition: ScalarOperator;
  /** The ERC20 token ethereum address */
  contractAddress: Scalars['ContractAddress'];
  /** The amount of decimals of the ERC20 contract */
  decimals: Scalars['Float'];
  /** The name of the ERC20 token */
  name: Scalars['String'];
  /** The symbol of the ERC20 token */
  symbol: Scalars['String'];
};

/**
 * Event: An interface which is shared by all event entities and contains basic transaction data.
 *
 */
export type Event = {
  /**
   * Contains the addresses for accounts that were "impacted" by the event.
   * This typically involves accounts which experienced a state change as a result of the transaction which emitted this event.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  /**
   * The block number which the event was logged in.
   *
   */
  blockNumber: Scalars['BigInt'];
  /**
   * The gas price of the transaction that the event was logged in.
   *
   */
  gasPrice: Scalars['BigInt'];
  /**
   * The gas used for this transaction.
   *
   */
  gasUsed: Scalars['BigInt'];
  /**
   * The id of the event entity.
   *
   */
  id: Scalars['ID'];
  /**
   * The index of the event, e.g. first event emitted would have `logIndex` of 0.
   *
   */
  logIndex: Scalars['BigInt'];
  /**
   * The name of the event - is a 1-to-1 match with the name in our smart contracts.
   *
   */
  name: Scalars['String'];
  /**
   * A number used internally to sort the order of transactions.
   * The formula: `blockNumber * ORDER_MULTIPLIER + logIndex`
   * where: ORDER_MULTIPLIER = 10000
   *
   */
  order: Scalars['BigInt'];
  /**
   * The block timestamp which the event was logged in.
   *
   */
  timestamp: Scalars['BigInt'];
  /**
   * The transaction hash of the transaction that the event was logged in.
   *
   */
  transactionHash: Scalars['Bytes'];
};

export type Event_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<Event_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<Event_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum Event_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Timestamp = 'timestamp',
  TransactionHash = 'transactionHash'
}

export type ExitRateChangedEvent = Event & {
  __typename?: 'ExitRateChangedEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  /**
   * The flowrate at which the bond is streamed back to the Patrician In Charge.
   *
   */
  exitRate: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  /**
   * The address of the `token` (supertoken).
   *
   */
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
};

export type ExitRateChangedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<ExitRateChangedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  exitRate?: InputMaybe<Scalars['BigInt']>;
  exitRate_gt?: InputMaybe<Scalars['BigInt']>;
  exitRate_gte?: InputMaybe<Scalars['BigInt']>;
  exitRate_in?: InputMaybe<Array<Scalars['BigInt']>>;
  exitRate_lt?: InputMaybe<Scalars['BigInt']>;
  exitRate_lte?: InputMaybe<Scalars['BigInt']>;
  exitRate_not?: InputMaybe<Scalars['BigInt']>;
  exitRate_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<ExitRateChangedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum ExitRateChangedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  ExitRate = 'exitRate',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash'
}

/** The paginated publication result */
export type ExploreProfileResult = {
  __typename?: 'ExploreProfileResult';
  items: Array<Profile>;
  pageInfo: PaginatedResultInfo;
};

export type ExploreProfilesRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  customFilters?: InputMaybe<Array<CustomFiltersTypes>>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  sortCriteria: ProfileSortCriteria;
  timestamp?: InputMaybe<Scalars['TimestampScalar']>;
};

export type ExplorePublicationRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  customFilters?: InputMaybe<Array<CustomFiltersTypes>>;
  /** If you wish to exclude any results for profile ids */
  excludeProfileIds?: InputMaybe<Array<Scalars['ProfileId']>>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  metadata?: InputMaybe<PublicationMetadataFilters>;
  /** If you want the randomizer off (default on) */
  noRandomize?: InputMaybe<Scalars['Boolean']>;
  /** The publication types you want to query */
  publicationTypes?: InputMaybe<Array<PublicationTypes>>;
  sortCriteria: PublicationSortCriteria;
  /** The App Id */
  sources?: InputMaybe<Array<Scalars['Sources']>>;
  timestamp?: InputMaybe<Scalars['TimestampScalar']>;
};

/** The paginated publication result */
export type ExplorePublicationResult = {
  __typename?: 'ExplorePublicationResult';
  items: Array<Publication>;
  pageInfo: PaginatedResultInfo;
};

export type FeeCollectModuleParams = {
  /** The collect module amount info */
  amount: ModuleFeeAmountParams;
  /** Follower only */
  followerOnly: Scalars['Boolean'];
  /** The collect module recipient address */
  recipient: Scalars['EthereumAddress'];
  /** The collect module referral fee */
  referralFee: Scalars['Float'];
};

export type FeeCollectModuleSettings = {
  __typename?: 'FeeCollectModuleSettings';
  /** The collect module amount info */
  amount: ModuleFeeAmount;
  contractAddress: Scalars['ContractAddress'];
  /** Follower only */
  followerOnly: Scalars['Boolean'];
  /** The collect module recipient address */
  recipient: Scalars['EthereumAddress'];
  /** The collect module referral fee */
  referralFee: Scalars['Float'];
  /** The collect modules enum */
  type: CollectModules;
};

export type FeeFollowModuleParams = {
  /** The follow module amount info */
  amount: ModuleFeeAmountParams;
  /** The follow module recipient address */
  recipient: Scalars['EthereumAddress'];
};

export type FeeFollowModuleRedeemParams = {
  /** The expected amount to pay */
  amount: ModuleFeeAmountParams;
};

export type FeeFollowModuleSettings = {
  __typename?: 'FeeFollowModuleSettings';
  /** The collect module amount info */
  amount: ModuleFeeAmount;
  contractAddress: Scalars['ContractAddress'];
  /** The collect module recipient address */
  recipient: Scalars['EthereumAddress'];
  /** The follow modules enum */
  type: FollowModules;
};

/** The feed event item filter types */
export enum FeedEventItemType {
  CollectComment = 'COLLECT_COMMENT',
  CollectPost = 'COLLECT_POST',
  Comment = 'COMMENT',
  Mirror = 'MIRROR',
  Post = 'POST',
  ReactionComment = 'REACTION_COMMENT',
  ReactionPost = 'REACTION_POST'
}

export type FeedHighlightsRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  metadata?: InputMaybe<PublicationMetadataFilters>;
  /** The profile id */
  profileId: Scalars['ProfileId'];
  /** The App Id */
  sources?: InputMaybe<Array<Scalars['Sources']>>;
};

export type FeedItem = {
  __typename?: 'FeedItem';
  /** Sorted by most recent first. Resolves defaultProfile and if null omits the wallet collect event from the list. */
  collects: Array<CollectedEvent>;
  /** Sorted by most recent first. Up to page size - 1 comments. */
  comments?: Maybe<Array<Comment>>;
  /** The elected mirror will be the first Mirror publication within the page results set */
  electedMirror?: Maybe<ElectedMirror>;
  /** Sorted by most recent first. Up to page size - 1 mirrors */
  mirrors: Array<MirrorEvent>;
  /** Sorted by most recent first. Up to page size - 1 reactions */
  reactions: Array<ReactionEvent>;
  root: FeedItemRoot;
};

export type FeedItemRoot = Comment | Post;

export type FeedRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  /** Filter your feed to whatever you wish */
  feedEventItemTypes?: InputMaybe<Array<FeedEventItemType>>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  metadata?: InputMaybe<PublicationMetadataFilters>;
  /** The profile id */
  profileId: Scalars['ProfileId'];
  /** The App Id */
  sources?: InputMaybe<Array<Scalars['Sources']>>;
};

/**
 * FlowOperator: A higher order entity that of a flow operator for an `AccountTokenSnapshot`.
 *
 */
export type FlowOperator = {
  __typename?: 'FlowOperator';
  accountTokenSnapshot: AccountTokenSnapshot;
  /**
   * The transfer allowance granted to the `flowOperator` by the `sender`.
   *
   */
  allowance: Scalars['BigInt'];
  createdAtBlockNumber: Scalars['BigInt'];
  createdAtTimestamp: Scalars['BigInt'];
  flowOperator: Scalars['Bytes'];
  flowOperatorUpdatedEvents: Array<FlowOperatorUpdatedEvent>;
  /**
   * The flow rate allowance granted to the `flowOperator` by the `sender`. This can be reset if the `sender` updates the `flowOperator` flow rate allowance.
   *
   */
  flowRateAllowanceGranted: Scalars['BigInt'];
  /**
   * The remaining flow rate allowance the `flowOperator` has.
   * This will go down every time when the `flowOperator` uses the allowance, that is, if they increase flowRate for `sender` or create a new flow on behalf of `sender`.
   * It can only be reset if the `sender` updates the flow rate allowance.
   * NOTE: this value will NOT go down if max flow rate allowance is set.
   *
   */
  flowRateAllowanceRemaining: Scalars['BigInt'];
  /**
   * ID composed of: flowOperator-token-sender
   *
   */
  id: Scalars['ID'];
  /**
   * The permissions granted to the `flowOperator`.
   * Bitmask representation:
   * Delete | Update | Create
   * | D | U | C |
   * | 0 | 0 | 0 |
   *
   */
  permissions: Scalars['Int'];
  sender: Account;
  token: Token;
  updatedAtBlockNumber: Scalars['BigInt'];
  updatedAtTimestamp: Scalars['BigInt'];
};


/**
 * FlowOperator: A higher order entity that of a flow operator for an `AccountTokenSnapshot`.
 *
 */
export type FlowOperatorFlowOperatorUpdatedEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<FlowOperatorUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<FlowOperatorUpdatedEvent_Filter>;
};

export type FlowOperatorUpdatedEvent = Event & {
  __typename?: 'FlowOperatorUpdatedEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = sender
   * addresses[2] = `flowOperator`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  flowOperator: FlowOperator;
  flowRateAllowance: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  /**
   * The permissions granted to the `flowOperator`.
   * Octo bitmask representation.
   *
   */
  permissions: Scalars['Int'];
  sender: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  /**
   * The address of the `token` being streamed.
   *
   */
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
};

export type FlowOperatorUpdatedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<FlowOperatorUpdatedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  flowOperator?: InputMaybe<Scalars['String']>;
  flowOperator_?: InputMaybe<FlowOperator_Filter>;
  flowOperator_contains?: InputMaybe<Scalars['String']>;
  flowOperator_contains_nocase?: InputMaybe<Scalars['String']>;
  flowOperator_ends_with?: InputMaybe<Scalars['String']>;
  flowOperator_ends_with_nocase?: InputMaybe<Scalars['String']>;
  flowOperator_gt?: InputMaybe<Scalars['String']>;
  flowOperator_gte?: InputMaybe<Scalars['String']>;
  flowOperator_in?: InputMaybe<Array<Scalars['String']>>;
  flowOperator_lt?: InputMaybe<Scalars['String']>;
  flowOperator_lte?: InputMaybe<Scalars['String']>;
  flowOperator_not?: InputMaybe<Scalars['String']>;
  flowOperator_not_contains?: InputMaybe<Scalars['String']>;
  flowOperator_not_contains_nocase?: InputMaybe<Scalars['String']>;
  flowOperator_not_ends_with?: InputMaybe<Scalars['String']>;
  flowOperator_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  flowOperator_not_in?: InputMaybe<Array<Scalars['String']>>;
  flowOperator_not_starts_with?: InputMaybe<Scalars['String']>;
  flowOperator_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  flowOperator_starts_with?: InputMaybe<Scalars['String']>;
  flowOperator_starts_with_nocase?: InputMaybe<Scalars['String']>;
  flowRateAllowance?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowance_gt?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowance_gte?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowance_in?: InputMaybe<Array<Scalars['BigInt']>>;
  flowRateAllowance_lt?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowance_lte?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowance_not?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowance_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<FlowOperatorUpdatedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  permissions?: InputMaybe<Scalars['Int']>;
  permissions_gt?: InputMaybe<Scalars['Int']>;
  permissions_gte?: InputMaybe<Scalars['Int']>;
  permissions_in?: InputMaybe<Array<Scalars['Int']>>;
  permissions_lt?: InputMaybe<Scalars['Int']>;
  permissions_lte?: InputMaybe<Scalars['Int']>;
  permissions_not?: InputMaybe<Scalars['Int']>;
  permissions_not_in?: InputMaybe<Array<Scalars['Int']>>;
  sender?: InputMaybe<Scalars['Bytes']>;
  sender_contains?: InputMaybe<Scalars['Bytes']>;
  sender_gt?: InputMaybe<Scalars['Bytes']>;
  sender_gte?: InputMaybe<Scalars['Bytes']>;
  sender_in?: InputMaybe<Array<Scalars['Bytes']>>;
  sender_lt?: InputMaybe<Scalars['Bytes']>;
  sender_lte?: InputMaybe<Scalars['Bytes']>;
  sender_not?: InputMaybe<Scalars['Bytes']>;
  sender_not_contains?: InputMaybe<Scalars['Bytes']>;
  sender_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum FlowOperatorUpdatedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  FlowOperator = 'flowOperator',
  FlowOperatorAllowance = 'flowOperator__allowance',
  FlowOperatorCreatedAtBlockNumber = 'flowOperator__createdAtBlockNumber',
  FlowOperatorCreatedAtTimestamp = 'flowOperator__createdAtTimestamp',
  FlowOperatorFlowOperator = 'flowOperator__flowOperator',
  FlowOperatorFlowRateAllowanceGranted = 'flowOperator__flowRateAllowanceGranted',
  FlowOperatorFlowRateAllowanceRemaining = 'flowOperator__flowRateAllowanceRemaining',
  FlowOperatorId = 'flowOperator__id',
  FlowOperatorPermissions = 'flowOperator__permissions',
  FlowOperatorUpdatedAtBlockNumber = 'flowOperator__updatedAtBlockNumber',
  FlowOperatorUpdatedAtTimestamp = 'flowOperator__updatedAtTimestamp',
  FlowRateAllowance = 'flowRateAllowance',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Permissions = 'permissions',
  Sender = 'sender',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash'
}

export type FlowOperator_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  accountTokenSnapshot?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_?: InputMaybe<AccountTokenSnapshot_Filter>;
  accountTokenSnapshot_contains?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_contains_nocase?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_ends_with?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_gt?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_gte?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_in?: InputMaybe<Array<Scalars['String']>>;
  accountTokenSnapshot_lt?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_lte?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_not?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_not_contains?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_not_contains_nocase?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_not_ends_with?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_not_in?: InputMaybe<Array<Scalars['String']>>;
  accountTokenSnapshot_not_starts_with?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_starts_with?: InputMaybe<Scalars['String']>;
  accountTokenSnapshot_starts_with_nocase?: InputMaybe<Scalars['String']>;
  allowance?: InputMaybe<Scalars['BigInt']>;
  allowance_gt?: InputMaybe<Scalars['BigInt']>;
  allowance_gte?: InputMaybe<Scalars['BigInt']>;
  allowance_in?: InputMaybe<Array<Scalars['BigInt']>>;
  allowance_lt?: InputMaybe<Scalars['BigInt']>;
  allowance_lte?: InputMaybe<Scalars['BigInt']>;
  allowance_not?: InputMaybe<Scalars['BigInt']>;
  allowance_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  and?: InputMaybe<Array<InputMaybe<FlowOperator_Filter>>>;
  createdAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  flowOperator?: InputMaybe<Scalars['Bytes']>;
  flowOperatorUpdatedEvents_?: InputMaybe<FlowOperatorUpdatedEvent_Filter>;
  flowOperator_contains?: InputMaybe<Scalars['Bytes']>;
  flowOperator_gt?: InputMaybe<Scalars['Bytes']>;
  flowOperator_gte?: InputMaybe<Scalars['Bytes']>;
  flowOperator_in?: InputMaybe<Array<Scalars['Bytes']>>;
  flowOperator_lt?: InputMaybe<Scalars['Bytes']>;
  flowOperator_lte?: InputMaybe<Scalars['Bytes']>;
  flowOperator_not?: InputMaybe<Scalars['Bytes']>;
  flowOperator_not_contains?: InputMaybe<Scalars['Bytes']>;
  flowOperator_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  flowRateAllowanceGranted?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowanceGranted_gt?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowanceGranted_gte?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowanceGranted_in?: InputMaybe<Array<Scalars['BigInt']>>;
  flowRateAllowanceGranted_lt?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowanceGranted_lte?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowanceGranted_not?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowanceGranted_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  flowRateAllowanceRemaining?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowanceRemaining_gt?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowanceRemaining_gte?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowanceRemaining_in?: InputMaybe<Array<Scalars['BigInt']>>;
  flowRateAllowanceRemaining_lt?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowanceRemaining_lte?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowanceRemaining_not?: InputMaybe<Scalars['BigInt']>;
  flowRateAllowanceRemaining_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  or?: InputMaybe<Array<InputMaybe<FlowOperator_Filter>>>;
  permissions?: InputMaybe<Scalars['Int']>;
  permissions_gt?: InputMaybe<Scalars['Int']>;
  permissions_gte?: InputMaybe<Scalars['Int']>;
  permissions_in?: InputMaybe<Array<Scalars['Int']>>;
  permissions_lt?: InputMaybe<Scalars['Int']>;
  permissions_lte?: InputMaybe<Scalars['Int']>;
  permissions_not?: InputMaybe<Scalars['Int']>;
  permissions_not_in?: InputMaybe<Array<Scalars['Int']>>;
  sender?: InputMaybe<Scalars['String']>;
  sender_?: InputMaybe<Account_Filter>;
  sender_contains?: InputMaybe<Scalars['String']>;
  sender_contains_nocase?: InputMaybe<Scalars['String']>;
  sender_ends_with?: InputMaybe<Scalars['String']>;
  sender_ends_with_nocase?: InputMaybe<Scalars['String']>;
  sender_gt?: InputMaybe<Scalars['String']>;
  sender_gte?: InputMaybe<Scalars['String']>;
  sender_in?: InputMaybe<Array<Scalars['String']>>;
  sender_lt?: InputMaybe<Scalars['String']>;
  sender_lte?: InputMaybe<Scalars['String']>;
  sender_not?: InputMaybe<Scalars['String']>;
  sender_not_contains?: InputMaybe<Scalars['String']>;
  sender_not_contains_nocase?: InputMaybe<Scalars['String']>;
  sender_not_ends_with?: InputMaybe<Scalars['String']>;
  sender_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  sender_not_in?: InputMaybe<Array<Scalars['String']>>;
  sender_not_starts_with?: InputMaybe<Scalars['String']>;
  sender_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  sender_starts_with?: InputMaybe<Scalars['String']>;
  sender_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  updatedAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum FlowOperator_OrderBy {
  AccountTokenSnapshot = 'accountTokenSnapshot',
  AccountTokenSnapshotActiveIncomingStreamCount = 'accountTokenSnapshot__activeIncomingStreamCount',
  AccountTokenSnapshotActiveOutgoingStreamCount = 'accountTokenSnapshot__activeOutgoingStreamCount',
  AccountTokenSnapshotBalanceUntilUpdatedAt = 'accountTokenSnapshot__balanceUntilUpdatedAt',
  AccountTokenSnapshotId = 'accountTokenSnapshot__id',
  AccountTokenSnapshotInactiveIncomingStreamCount = 'accountTokenSnapshot__inactiveIncomingStreamCount',
  AccountTokenSnapshotInactiveOutgoingStreamCount = 'accountTokenSnapshot__inactiveOutgoingStreamCount',
  AccountTokenSnapshotIsLiquidationEstimateOptimistic = 'accountTokenSnapshot__isLiquidationEstimateOptimistic',
  AccountTokenSnapshotMaybeCriticalAtTimestamp = 'accountTokenSnapshot__maybeCriticalAtTimestamp',
  AccountTokenSnapshotTotalAmountStreamedInUntilUpdatedAt = 'accountTokenSnapshot__totalAmountStreamedInUntilUpdatedAt',
  AccountTokenSnapshotTotalAmountStreamedOutUntilUpdatedAt = 'accountTokenSnapshot__totalAmountStreamedOutUntilUpdatedAt',
  AccountTokenSnapshotTotalAmountStreamedUntilUpdatedAt = 'accountTokenSnapshot__totalAmountStreamedUntilUpdatedAt',
  AccountTokenSnapshotTotalAmountTransferredUntilUpdatedAt = 'accountTokenSnapshot__totalAmountTransferredUntilUpdatedAt',
  AccountTokenSnapshotTotalApprovedSubscriptions = 'accountTokenSnapshot__totalApprovedSubscriptions',
  AccountTokenSnapshotTotalDeposit = 'accountTokenSnapshot__totalDeposit',
  AccountTokenSnapshotTotalInflowRate = 'accountTokenSnapshot__totalInflowRate',
  AccountTokenSnapshotTotalNetFlowRate = 'accountTokenSnapshot__totalNetFlowRate',
  AccountTokenSnapshotTotalNumberOfActiveStreams = 'accountTokenSnapshot__totalNumberOfActiveStreams',
  AccountTokenSnapshotTotalNumberOfClosedStreams = 'accountTokenSnapshot__totalNumberOfClosedStreams',
  AccountTokenSnapshotTotalOutflowRate = 'accountTokenSnapshot__totalOutflowRate',
  AccountTokenSnapshotTotalSubscriptionsWithUnits = 'accountTokenSnapshot__totalSubscriptionsWithUnits',
  AccountTokenSnapshotUpdatedAtBlockNumber = 'accountTokenSnapshot__updatedAtBlockNumber',
  AccountTokenSnapshotUpdatedAtTimestamp = 'accountTokenSnapshot__updatedAtTimestamp',
  Allowance = 'allowance',
  CreatedAtBlockNumber = 'createdAtBlockNumber',
  CreatedAtTimestamp = 'createdAtTimestamp',
  FlowOperator = 'flowOperator',
  FlowOperatorUpdatedEvents = 'flowOperatorUpdatedEvents',
  FlowRateAllowanceGranted = 'flowRateAllowanceGranted',
  FlowRateAllowanceRemaining = 'flowRateAllowanceRemaining',
  Id = 'id',
  Permissions = 'permissions',
  Sender = 'sender',
  SenderCreatedAtBlockNumber = 'sender__createdAtBlockNumber',
  SenderCreatedAtTimestamp = 'sender__createdAtTimestamp',
  SenderId = 'sender__id',
  SenderIsSuperApp = 'sender__isSuperApp',
  SenderUpdatedAtBlockNumber = 'sender__updatedAtBlockNumber',
  SenderUpdatedAtTimestamp = 'sender__updatedAtTimestamp',
  Token = 'token',
  TokenCreatedAtBlockNumber = 'token__createdAtBlockNumber',
  TokenCreatedAtTimestamp = 'token__createdAtTimestamp',
  TokenDecimals = 'token__decimals',
  TokenId = 'token__id',
  TokenIsListed = 'token__isListed',
  TokenIsNativeAssetSuperToken = 'token__isNativeAssetSuperToken',
  TokenIsSuperToken = 'token__isSuperToken',
  TokenName = 'token__name',
  TokenSymbol = 'token__symbol',
  TokenUnderlyingAddress = 'token__underlyingAddress',
  UpdatedAtBlockNumber = 'updatedAtBlockNumber',
  UpdatedAtTimestamp = 'updatedAtTimestamp'
}

/**
 * FlowUpdated: An `Event` entity that is emitted
 * when a flow is created, updated, or deleted.
 *
 */
export type FlowUpdatedEvent = Event & {
  __typename?: 'FlowUpdatedEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (supertoken)
   * addresses[1] = `sender`
   * addresses[2] = `receiver`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  /**
   * The deposit amount put up for the creation of the flow.
   *
   */
  deposit: Scalars['BigInt'];
  /**
   * The address that is executing the flow update transaction.
   * This will be the zero address until the flowOperator feature is live.
   *
   */
  flowOperator: Scalars['Bytes'];
  /**
   * The flow rate per second.
   *
   */
  flowRate: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  /**
   * The previous flow rate, the absolute (positive) value.
   *
   */
  oldFlowRate: Scalars['BigInt'];
  order: Scalars['BigInt'];
  /**
   * The address of the flow receiver.
   *
   */
  receiver: Scalars['Bytes'];
  /**
   * The address of the flow sender.
   *
   */
  sender: Scalars['Bytes'];
  /**
   * The stream entity which is being modified.
   *
   */
  stream: Stream;
  timestamp: Scalars['BigInt'];
  /**
   * The address of the `token` (supertoken) being streamed.
   *
   */
  token: Scalars['Bytes'];
  /**
   * The total amount streamed until the timestamp
   * for the Stream entity linked to this event.
   *
   */
  totalAmountStreamedUntilTimestamp: Scalars['BigInt'];
  /**
   * The total (global/account level) flow rate of `receiver` for `token` as of this event.
   *
   */
  totalReceiverFlowRate: Scalars['BigInt'];
  /**
   * The total (global/account level) flow rate of `sender` for `token` as of this event.
   *
   */
  totalSenderFlowRate: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
  /**
   * The "type" of the `FlowUpdated` event.
   * 0 = create
   * 1 = update
   * 2 = terminate
   *
   */
  type: Scalars['Int'];
  /**
   * Arbitrary bytes (additional data) passed upon flow creation.
   *
   */
  userData: Scalars['Bytes'];
};

export type FlowUpdatedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<FlowUpdatedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  deposit?: InputMaybe<Scalars['BigInt']>;
  deposit_gt?: InputMaybe<Scalars['BigInt']>;
  deposit_gte?: InputMaybe<Scalars['BigInt']>;
  deposit_in?: InputMaybe<Array<Scalars['BigInt']>>;
  deposit_lt?: InputMaybe<Scalars['BigInt']>;
  deposit_lte?: InputMaybe<Scalars['BigInt']>;
  deposit_not?: InputMaybe<Scalars['BigInt']>;
  deposit_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  flowOperator?: InputMaybe<Scalars['Bytes']>;
  flowOperator_contains?: InputMaybe<Scalars['Bytes']>;
  flowOperator_gt?: InputMaybe<Scalars['Bytes']>;
  flowOperator_gte?: InputMaybe<Scalars['Bytes']>;
  flowOperator_in?: InputMaybe<Array<Scalars['Bytes']>>;
  flowOperator_lt?: InputMaybe<Scalars['Bytes']>;
  flowOperator_lte?: InputMaybe<Scalars['Bytes']>;
  flowOperator_not?: InputMaybe<Scalars['Bytes']>;
  flowOperator_not_contains?: InputMaybe<Scalars['Bytes']>;
  flowOperator_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  flowRate?: InputMaybe<Scalars['BigInt']>;
  flowRate_gt?: InputMaybe<Scalars['BigInt']>;
  flowRate_gte?: InputMaybe<Scalars['BigInt']>;
  flowRate_in?: InputMaybe<Array<Scalars['BigInt']>>;
  flowRate_lt?: InputMaybe<Scalars['BigInt']>;
  flowRate_lte?: InputMaybe<Scalars['BigInt']>;
  flowRate_not?: InputMaybe<Scalars['BigInt']>;
  flowRate_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  oldFlowRate?: InputMaybe<Scalars['BigInt']>;
  oldFlowRate_gt?: InputMaybe<Scalars['BigInt']>;
  oldFlowRate_gte?: InputMaybe<Scalars['BigInt']>;
  oldFlowRate_in?: InputMaybe<Array<Scalars['BigInt']>>;
  oldFlowRate_lt?: InputMaybe<Scalars['BigInt']>;
  oldFlowRate_lte?: InputMaybe<Scalars['BigInt']>;
  oldFlowRate_not?: InputMaybe<Scalars['BigInt']>;
  oldFlowRate_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  or?: InputMaybe<Array<InputMaybe<FlowUpdatedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  receiver?: InputMaybe<Scalars['Bytes']>;
  receiver_contains?: InputMaybe<Scalars['Bytes']>;
  receiver_gt?: InputMaybe<Scalars['Bytes']>;
  receiver_gte?: InputMaybe<Scalars['Bytes']>;
  receiver_in?: InputMaybe<Array<Scalars['Bytes']>>;
  receiver_lt?: InputMaybe<Scalars['Bytes']>;
  receiver_lte?: InputMaybe<Scalars['Bytes']>;
  receiver_not?: InputMaybe<Scalars['Bytes']>;
  receiver_not_contains?: InputMaybe<Scalars['Bytes']>;
  receiver_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  sender?: InputMaybe<Scalars['Bytes']>;
  sender_contains?: InputMaybe<Scalars['Bytes']>;
  sender_gt?: InputMaybe<Scalars['Bytes']>;
  sender_gte?: InputMaybe<Scalars['Bytes']>;
  sender_in?: InputMaybe<Array<Scalars['Bytes']>>;
  sender_lt?: InputMaybe<Scalars['Bytes']>;
  sender_lte?: InputMaybe<Scalars['Bytes']>;
  sender_not?: InputMaybe<Scalars['Bytes']>;
  sender_not_contains?: InputMaybe<Scalars['Bytes']>;
  sender_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  stream?: InputMaybe<Scalars['String']>;
  stream_?: InputMaybe<Stream_Filter>;
  stream_contains?: InputMaybe<Scalars['String']>;
  stream_contains_nocase?: InputMaybe<Scalars['String']>;
  stream_ends_with?: InputMaybe<Scalars['String']>;
  stream_ends_with_nocase?: InputMaybe<Scalars['String']>;
  stream_gt?: InputMaybe<Scalars['String']>;
  stream_gte?: InputMaybe<Scalars['String']>;
  stream_in?: InputMaybe<Array<Scalars['String']>>;
  stream_lt?: InputMaybe<Scalars['String']>;
  stream_lte?: InputMaybe<Scalars['String']>;
  stream_not?: InputMaybe<Scalars['String']>;
  stream_not_contains?: InputMaybe<Scalars['String']>;
  stream_not_contains_nocase?: InputMaybe<Scalars['String']>;
  stream_not_ends_with?: InputMaybe<Scalars['String']>;
  stream_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  stream_not_in?: InputMaybe<Array<Scalars['String']>>;
  stream_not_starts_with?: InputMaybe<Scalars['String']>;
  stream_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  stream_starts_with?: InputMaybe<Scalars['String']>;
  stream_starts_with_nocase?: InputMaybe<Scalars['String']>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  totalAmountStreamedUntilTimestamp?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountStreamedUntilTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalReceiverFlowRate?: InputMaybe<Scalars['BigInt']>;
  totalReceiverFlowRate_gt?: InputMaybe<Scalars['BigInt']>;
  totalReceiverFlowRate_gte?: InputMaybe<Scalars['BigInt']>;
  totalReceiverFlowRate_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalReceiverFlowRate_lt?: InputMaybe<Scalars['BigInt']>;
  totalReceiverFlowRate_lte?: InputMaybe<Scalars['BigInt']>;
  totalReceiverFlowRate_not?: InputMaybe<Scalars['BigInt']>;
  totalReceiverFlowRate_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalSenderFlowRate?: InputMaybe<Scalars['BigInt']>;
  totalSenderFlowRate_gt?: InputMaybe<Scalars['BigInt']>;
  totalSenderFlowRate_gte?: InputMaybe<Scalars['BigInt']>;
  totalSenderFlowRate_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalSenderFlowRate_lt?: InputMaybe<Scalars['BigInt']>;
  totalSenderFlowRate_lte?: InputMaybe<Scalars['BigInt']>;
  totalSenderFlowRate_not?: InputMaybe<Scalars['BigInt']>;
  totalSenderFlowRate_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  type?: InputMaybe<Scalars['Int']>;
  type_gt?: InputMaybe<Scalars['Int']>;
  type_gte?: InputMaybe<Scalars['Int']>;
  type_in?: InputMaybe<Array<Scalars['Int']>>;
  type_lt?: InputMaybe<Scalars['Int']>;
  type_lte?: InputMaybe<Scalars['Int']>;
  type_not?: InputMaybe<Scalars['Int']>;
  type_not_in?: InputMaybe<Array<Scalars['Int']>>;
  userData?: InputMaybe<Scalars['Bytes']>;
  userData_contains?: InputMaybe<Scalars['Bytes']>;
  userData_gt?: InputMaybe<Scalars['Bytes']>;
  userData_gte?: InputMaybe<Scalars['Bytes']>;
  userData_in?: InputMaybe<Array<Scalars['Bytes']>>;
  userData_lt?: InputMaybe<Scalars['Bytes']>;
  userData_lte?: InputMaybe<Scalars['Bytes']>;
  userData_not?: InputMaybe<Scalars['Bytes']>;
  userData_not_contains?: InputMaybe<Scalars['Bytes']>;
  userData_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum FlowUpdatedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  Deposit = 'deposit',
  FlowOperator = 'flowOperator',
  FlowRate = 'flowRate',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  OldFlowRate = 'oldFlowRate',
  Order = 'order',
  Receiver = 'receiver',
  Sender = 'sender',
  Stream = 'stream',
  StreamCreatedAtBlockNumber = 'stream__createdAtBlockNumber',
  StreamCreatedAtTimestamp = 'stream__createdAtTimestamp',
  StreamCurrentFlowRate = 'stream__currentFlowRate',
  StreamDeposit = 'stream__deposit',
  StreamId = 'stream__id',
  StreamStreamedUntilUpdatedAt = 'stream__streamedUntilUpdatedAt',
  StreamUpdatedAtBlockNumber = 'stream__updatedAtBlockNumber',
  StreamUpdatedAtTimestamp = 'stream__updatedAtTimestamp',
  StreamUserData = 'stream__userData',
  Timestamp = 'timestamp',
  Token = 'token',
  TotalAmountStreamedUntilTimestamp = 'totalAmountStreamedUntilTimestamp',
  TotalReceiverFlowRate = 'totalReceiverFlowRate',
  TotalSenderFlowRate = 'totalSenderFlowRate',
  TransactionHash = 'transactionHash',
  Type = 'type',
  UserData = 'userData'
}

export type Follow = {
  followModule?: InputMaybe<FollowModuleRedeemParams>;
  profile: Scalars['ProfileId'];
};

export type FollowConditionInput = {
  /** The profile id of the gated profile */
  profileId: Scalars['ProfileId'];
};

export type FollowConditionOutput = {
  __typename?: 'FollowConditionOutput';
  /** The profile id of the gated profile */
  profileId: Scalars['ProfileId'];
};

export type FollowModule = FeeFollowModuleSettings | ProfileFollowModuleSettings | RevertFollowModuleSettings | UnknownFollowModuleSettings;

export type FollowModuleParams = {
  /** The follower fee follower module */
  feeFollowModule?: InputMaybe<FeeFollowModuleParams>;
  /** The empty follow module */
  freeFollowModule?: InputMaybe<Scalars['Boolean']>;
  /** The profile follow module */
  profileFollowModule?: InputMaybe<Scalars['Boolean']>;
  /** The revert follow module */
  revertFollowModule?: InputMaybe<Scalars['Boolean']>;
  /** A unknown follow module */
  unknownFollowModule?: InputMaybe<UnknownFollowModuleParams>;
};

export type FollowModuleRedeemParams = {
  /** The follower fee follower module */
  feeFollowModule?: InputMaybe<FeeFollowModuleRedeemParams>;
  /** The profile follower module */
  profileFollowModule?: InputMaybe<ProfileFollowModuleRedeemParams>;
  /** A unknown follow module */
  unknownFollowModule?: InputMaybe<UnknownFollowModuleRedeemParams>;
};

/** The follow module types */
export enum FollowModules {
  FeeFollowModule = 'FeeFollowModule',
  ProfileFollowModule = 'ProfileFollowModule',
  RevertFollowModule = 'RevertFollowModule',
  UnknownFollowModule = 'UnknownFollowModule'
}

export type FollowOnlyReferenceModuleSettings = {
  __typename?: 'FollowOnlyReferenceModuleSettings';
  contractAddress: Scalars['ContractAddress'];
  /** The reference modules enum */
  type: ReferenceModules;
};

export type FollowProxyAction = {
  freeFollow?: InputMaybe<FreeFollowProxyAction>;
};

export type FollowRequest = {
  follow: Array<Follow>;
};

export type FollowRevenueResult = {
  __typename?: 'FollowRevenueResult';
  revenues: Array<RevenueAggregate>;
};

export type Follower = {
  __typename?: 'Follower';
  totalAmountOfTimesFollowed: Scalars['Int'];
  wallet: Wallet;
};

export type FollowerNftOwnedTokenIds = {
  __typename?: 'FollowerNftOwnedTokenIds';
  followerNftAddress: Scalars['ContractAddress'];
  tokensIds: Array<Scalars['String']>;
};

export type FollowerNftOwnedTokenIdsRequest = {
  address: Scalars['EthereumAddress'];
  profileId: Scalars['ProfileId'];
};

export type FollowersRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  profileId: Scalars['ProfileId'];
};

export type Following = {
  __typename?: 'Following';
  profile: Profile;
  totalAmountOfTimesFollowing: Scalars['Int'];
};

export type FollowingRequest = {
  address: Scalars['EthereumAddress'];
  cursor?: InputMaybe<Scalars['Cursor']>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
};

export type FraudReasonInputParams = {
  reason: PublicationReportingReason;
  subreason: PublicationReportingFraudSubreason;
};

export type FreeCollectModuleParams = {
  /** Follower only */
  followerOnly: Scalars['Boolean'];
};

export type FreeCollectModuleSettings = {
  __typename?: 'FreeCollectModuleSettings';
  contractAddress: Scalars['ContractAddress'];
  /** Follower only */
  followerOnly: Scalars['Boolean'];
  /** The collect modules enum */
  type: CollectModules;
};

export type FreeCollectProxyAction = {
  publicationId: Scalars['InternalPublicationId'];
};

export type FreeFollowProxyAction = {
  profileId: Scalars['ProfileId'];
};

/** The access conditions for the publication */
export type GatedPublicationParamsInput = {
  /** AND condition */
  and?: InputMaybe<AndConditionInput>;
  /** Profile follow condition */
  collect?: InputMaybe<CollectConditionInput>;
  /** The LIT Protocol encrypted symmetric key */
  encryptedSymmetricKey: Scalars['ContentEncryptionKey'];
  /** EOA ownership condition */
  eoa?: InputMaybe<EoaOwnershipInput>;
  /** Profile follow condition */
  follow?: InputMaybe<FollowConditionInput>;
  /** NFT ownership condition */
  nft?: InputMaybe<NftOwnershipInput>;
  /** OR condition */
  or?: InputMaybe<OrConditionInput>;
  /** Profile ownership condition */
  profile?: InputMaybe<ProfileOwnershipInput>;
  /** ERC20 token ownership condition */
  token?: InputMaybe<Erc20OwnershipInput>;
};

export type GciRequest = {
  hhh: Scalars['String'];
  secret: Scalars['String'];
  ttt: Scalars['String'];
};

export type GcrRequest = {
  hhh: Scalars['String'];
  secret: Scalars['String'];
  ttt: Scalars['String'];
};

export type GctRequest = {
  hhh: Scalars['String'];
  secret: Scalars['String'];
};

export type GddRequest = {
  domain: Scalars['Url'];
  secret: Scalars['String'];
};

export type GdmRequest = {
  secret: Scalars['String'];
};

export type GenerateModuleCurrencyApproval = {
  __typename?: 'GenerateModuleCurrencyApproval';
  data: Scalars['BlockchainData'];
  from: Scalars['EthereumAddress'];
  to: Scalars['ContractAddress'];
};

export type GenerateModuleCurrencyApprovalDataRequest = {
  collectModule?: InputMaybe<CollectModules>;
  currency: Scalars['ContractAddress'];
  followModule?: InputMaybe<FollowModules>;
  referenceModule?: InputMaybe<ReferenceModules>;
  unknownCollectModule?: InputMaybe<Scalars['ContractAddress']>;
  unknownFollowModule?: InputMaybe<Scalars['ContractAddress']>;
  unknownReferenceModule?: InputMaybe<Scalars['ContractAddress']>;
  /** Floating point number as string (e.g. 42.009837). The server will move its decimal places for you */
  value: Scalars['String'];
};

export type GetPublicationMetadataStatusRequest = {
  publicationId?: InputMaybe<Scalars['InternalPublicationId']>;
  txHash?: InputMaybe<Scalars['TxHash']>;
  txId?: InputMaybe<Scalars['TxId']>;
};

export type GlobalProtocolStats = {
  __typename?: 'GlobalProtocolStats';
  totalBurntProfiles: Scalars['Int'];
  totalCollects: Scalars['Int'];
  totalComments: Scalars['Int'];
  totalFollows: Scalars['Int'];
  totalMirrors: Scalars['Int'];
  totalPosts: Scalars['Int'];
  totalProfiles: Scalars['Int'];
  totalRevenue: Array<Erc20Amount>;
};

export type GlobalProtocolStatsRequest = {
  /** Unix time from timestamp - if not supplied it will go from 0 timestamp */
  fromTimestamp?: InputMaybe<Scalars['UnixTimestamp']>;
  /** The App Id */
  sources?: InputMaybe<Array<Scalars['Sources']>>;
  /** Unix time to timestamp - if not supplied it go to the present timestamp */
  toTimestamp?: InputMaybe<Scalars['UnixTimestamp']>;
};

export type GovernanceReplacedEvent = Event & {
  __typename?: 'GovernanceReplacedEvent';
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  newGovernance: Scalars['Bytes'];
  oldGovernance: Scalars['Bytes'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
};

export type GovernanceReplacedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<GovernanceReplacedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  newGovernance?: InputMaybe<Scalars['Bytes']>;
  newGovernance_contains?: InputMaybe<Scalars['Bytes']>;
  newGovernance_gt?: InputMaybe<Scalars['Bytes']>;
  newGovernance_gte?: InputMaybe<Scalars['Bytes']>;
  newGovernance_in?: InputMaybe<Array<Scalars['Bytes']>>;
  newGovernance_lt?: InputMaybe<Scalars['Bytes']>;
  newGovernance_lte?: InputMaybe<Scalars['Bytes']>;
  newGovernance_not?: InputMaybe<Scalars['Bytes']>;
  newGovernance_not_contains?: InputMaybe<Scalars['Bytes']>;
  newGovernance_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  oldGovernance?: InputMaybe<Scalars['Bytes']>;
  oldGovernance_contains?: InputMaybe<Scalars['Bytes']>;
  oldGovernance_gt?: InputMaybe<Scalars['Bytes']>;
  oldGovernance_gte?: InputMaybe<Scalars['Bytes']>;
  oldGovernance_in?: InputMaybe<Array<Scalars['Bytes']>>;
  oldGovernance_lt?: InputMaybe<Scalars['Bytes']>;
  oldGovernance_lte?: InputMaybe<Scalars['Bytes']>;
  oldGovernance_not?: InputMaybe<Scalars['Bytes']>;
  oldGovernance_not_contains?: InputMaybe<Scalars['Bytes']>;
  oldGovernance_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  or?: InputMaybe<Array<InputMaybe<GovernanceReplacedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum GovernanceReplacedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  NewGovernance = 'newGovernance',
  OldGovernance = 'oldGovernance',
  Order = 'order',
  Timestamp = 'timestamp',
  TransactionHash = 'transactionHash'
}

export type HasTxHashBeenIndexedRequest = {
  /** Tx hash.. if your using the broadcaster you should use txId due to gas price upgrades */
  txHash?: InputMaybe<Scalars['TxHash']>;
  /** Tx id.. if your using the broadcaster you should always use this field */
  txId?: InputMaybe<Scalars['TxId']>;
};

export type HelRequest = {
  handle: Scalars['Handle'];
  remove: Scalars['Boolean'];
  secret: Scalars['String'];
};

export type HidePublicationRequest = {
  /** Publication id */
  publicationId: Scalars['InternalPublicationId'];
};

export type IdKitPhoneVerifyWebhookRequest = {
  sharedSecret: Scalars['String'];
  worldcoin?: InputMaybe<WorldcoinPhoneVerifyWebhookRequest>;
};

/** The verify webhook result status type */
export enum IdKitPhoneVerifyWebhookResultStatusType {
  AlreadyVerified = 'ALREADY_VERIFIED',
  Success = 'SUCCESS'
}

export type IllegalReasonInputParams = {
  reason: PublicationReportingReason;
  subreason: PublicationReportingIllegalSubreason;
};

export type InRequest = {
  ethereumAddress: Scalars['EthereumAddress'];
  numInvites: Scalars['Int'];
  secret: Scalars['String'];
};

export type InTotalRequest = {
  ethereumAddress: Scalars['EthereumAddress'];
  secret: Scalars['String'];
};

/**
 * Index: An Index higher order entity.
 *
 */
export type Index = {
  __typename?: 'Index';
  createdAtBlockNumber: Scalars['BigInt'];
  createdAtTimestamp: Scalars['BigInt'];
  /**
   * ID composed of: publisherAddress-tokenAddress-indexId
   *
   */
  id: Scalars['ID'];
  /**
   * IndexCreated event, there will only be one.
   *
   */
  indexCreatedEvent: IndexCreatedEvent;
  indexDistributionClaimedEvents: Array<IndexDistributionClaimedEvent>;
  /**
   * NOTE: indexId is not the same as the id of the `Index` entity.
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars['BigInt'];
  indexSubscribedEvents: Array<IndexSubscribedEvent>;
  indexUnitsUpdatedEvents: Array<IndexUnitsUpdatedEvent>;
  indexUnsubscribedEvents: Array<IndexUnsubscribedEvent>;
  indexUpdatedEvents: Array<IndexUpdatedEvent>;
  indexValue: Scalars['BigInt'];
  publisher: Account;
  /**
   * The subscriptions of the index, it will include approved, unapproved
   * and deleted subscriptions.
   *
   */
  subscriptions: Array<IndexSubscription>;
  token: Token;
  /**
   * The total amount distributed from this `Index`.
   *
   */
  totalAmountDistributedUntilUpdatedAt: Scalars['BigInt'];
  /**
   * The number of subscriptions which have units allocated to them on the `Index`.
   *
   */
  totalSubscriptionsWithUnits: Scalars['Int'];
  /**
   * The sum of `totalUnitsPending` and `totalUnitsApproved`.
   *
   */
  totalUnits: Scalars['BigInt'];
  /**
   * The number of units allocated by the `Index` that are approved.
   * This refers to the current (as of updatedAt) `totalUnitsApproved`-not all that has ever been approved.
   *
   */
  totalUnitsApproved: Scalars['BigInt'];
  /**
   * The number of units allocated by the `Index` that are pending.
   * This refers to the current (as of updatedAt) `totalUnitsPending`-not all that has ever been pending.
   *
   */
  totalUnitsPending: Scalars['BigInt'];
  updatedAtBlockNumber: Scalars['BigInt'];
  updatedAtTimestamp: Scalars['BigInt'];
};


/**
 * Index: An Index higher order entity.
 *
 */
export type IndexIndexDistributionClaimedEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexDistributionClaimedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<IndexDistributionClaimedEvent_Filter>;
};


/**
 * Index: An Index higher order entity.
 *
 */
export type IndexIndexSubscribedEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexSubscribedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<IndexSubscribedEvent_Filter>;
};


/**
 * Index: An Index higher order entity.
 *
 */
export type IndexIndexUnitsUpdatedEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexUnitsUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<IndexUnitsUpdatedEvent_Filter>;
};


/**
 * Index: An Index higher order entity.
 *
 */
export type IndexIndexUnsubscribedEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexUnsubscribedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<IndexUnsubscribedEvent_Filter>;
};


/**
 * Index: An Index higher order entity.
 *
 */
export type IndexIndexUpdatedEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<IndexUpdatedEvent_Filter>;
};


/**
 * Index: An Index higher order entity.
 *
 */
export type IndexSubscriptionsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexSubscription_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<IndexSubscription_Filter>;
};

export type IndexCreatedEvent = Event & {
  __typename?: 'IndexCreatedEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  index: Index;
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars['BigInt'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
  userData: Scalars['Bytes'];
};

export type IndexCreatedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<IndexCreatedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  index?: InputMaybe<Scalars['String']>;
  indexId?: InputMaybe<Scalars['BigInt']>;
  indexId_gt?: InputMaybe<Scalars['BigInt']>;
  indexId_gte?: InputMaybe<Scalars['BigInt']>;
  indexId_in?: InputMaybe<Array<Scalars['BigInt']>>;
  indexId_lt?: InputMaybe<Scalars['BigInt']>;
  indexId_lte?: InputMaybe<Scalars['BigInt']>;
  indexId_not?: InputMaybe<Scalars['BigInt']>;
  indexId_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  index_?: InputMaybe<Index_Filter>;
  index_contains?: InputMaybe<Scalars['String']>;
  index_contains_nocase?: InputMaybe<Scalars['String']>;
  index_ends_with?: InputMaybe<Scalars['String']>;
  index_ends_with_nocase?: InputMaybe<Scalars['String']>;
  index_gt?: InputMaybe<Scalars['String']>;
  index_gte?: InputMaybe<Scalars['String']>;
  index_in?: InputMaybe<Array<Scalars['String']>>;
  index_lt?: InputMaybe<Scalars['String']>;
  index_lte?: InputMaybe<Scalars['String']>;
  index_not?: InputMaybe<Scalars['String']>;
  index_not_contains?: InputMaybe<Scalars['String']>;
  index_not_contains_nocase?: InputMaybe<Scalars['String']>;
  index_not_ends_with?: InputMaybe<Scalars['String']>;
  index_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  index_not_in?: InputMaybe<Array<Scalars['String']>>;
  index_not_starts_with?: InputMaybe<Scalars['String']>;
  index_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  index_starts_with?: InputMaybe<Scalars['String']>;
  index_starts_with_nocase?: InputMaybe<Scalars['String']>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<IndexCreatedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  publisher?: InputMaybe<Scalars['Bytes']>;
  publisher_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_gt?: InputMaybe<Scalars['Bytes']>;
  publisher_gte?: InputMaybe<Scalars['Bytes']>;
  publisher_in?: InputMaybe<Array<Scalars['Bytes']>>;
  publisher_lt?: InputMaybe<Scalars['Bytes']>;
  publisher_lte?: InputMaybe<Scalars['Bytes']>;
  publisher_not?: InputMaybe<Scalars['Bytes']>;
  publisher_not_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  userData?: InputMaybe<Scalars['Bytes']>;
  userData_contains?: InputMaybe<Scalars['Bytes']>;
  userData_gt?: InputMaybe<Scalars['Bytes']>;
  userData_gte?: InputMaybe<Scalars['Bytes']>;
  userData_in?: InputMaybe<Array<Scalars['Bytes']>>;
  userData_lt?: InputMaybe<Scalars['Bytes']>;
  userData_lte?: InputMaybe<Scalars['Bytes']>;
  userData_not?: InputMaybe<Scalars['Bytes']>;
  userData_not_contains?: InputMaybe<Scalars['Bytes']>;
  userData_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum IndexCreatedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  Index = 'index',
  IndexId = 'indexId',
  IndexCreatedAtBlockNumber = 'index__createdAtBlockNumber',
  IndexCreatedAtTimestamp = 'index__createdAtTimestamp',
  IndexId = 'index__id',
  IndexIndexId = 'index__indexId',
  IndexIndexValue = 'index__indexValue',
  IndexTotalAmountDistributedUntilUpdatedAt = 'index__totalAmountDistributedUntilUpdatedAt',
  IndexTotalSubscriptionsWithUnits = 'index__totalSubscriptionsWithUnits',
  IndexTotalUnits = 'index__totalUnits',
  IndexTotalUnitsApproved = 'index__totalUnitsApproved',
  IndexTotalUnitsPending = 'index__totalUnitsPending',
  IndexUpdatedAtBlockNumber = 'index__updatedAtBlockNumber',
  IndexUpdatedAtTimestamp = 'index__updatedAtTimestamp',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Publisher = 'publisher',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash',
  UserData = 'userData'
}

export type IndexDistributionClaimedEvent = Event & {
  __typename?: 'IndexDistributionClaimedEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   * addresses[2] = `subscriber`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  amount: Scalars['BigInt'];
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  index: Index;
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars['BigInt'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars['Bytes'];
  /**
   * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
   * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
   *
   */
  subscriber: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
};

export type IndexDistributionClaimedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  and?: InputMaybe<Array<InputMaybe<IndexDistributionClaimedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  index?: InputMaybe<Scalars['String']>;
  indexId?: InputMaybe<Scalars['BigInt']>;
  indexId_gt?: InputMaybe<Scalars['BigInt']>;
  indexId_gte?: InputMaybe<Scalars['BigInt']>;
  indexId_in?: InputMaybe<Array<Scalars['BigInt']>>;
  indexId_lt?: InputMaybe<Scalars['BigInt']>;
  indexId_lte?: InputMaybe<Scalars['BigInt']>;
  indexId_not?: InputMaybe<Scalars['BigInt']>;
  indexId_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  index_?: InputMaybe<Index_Filter>;
  index_contains?: InputMaybe<Scalars['String']>;
  index_contains_nocase?: InputMaybe<Scalars['String']>;
  index_ends_with?: InputMaybe<Scalars['String']>;
  index_ends_with_nocase?: InputMaybe<Scalars['String']>;
  index_gt?: InputMaybe<Scalars['String']>;
  index_gte?: InputMaybe<Scalars['String']>;
  index_in?: InputMaybe<Array<Scalars['String']>>;
  index_lt?: InputMaybe<Scalars['String']>;
  index_lte?: InputMaybe<Scalars['String']>;
  index_not?: InputMaybe<Scalars['String']>;
  index_not_contains?: InputMaybe<Scalars['String']>;
  index_not_contains_nocase?: InputMaybe<Scalars['String']>;
  index_not_ends_with?: InputMaybe<Scalars['String']>;
  index_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  index_not_in?: InputMaybe<Array<Scalars['String']>>;
  index_not_starts_with?: InputMaybe<Scalars['String']>;
  index_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  index_starts_with?: InputMaybe<Scalars['String']>;
  index_starts_with_nocase?: InputMaybe<Scalars['String']>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<IndexDistributionClaimedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  publisher?: InputMaybe<Scalars['Bytes']>;
  publisher_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_gt?: InputMaybe<Scalars['Bytes']>;
  publisher_gte?: InputMaybe<Scalars['Bytes']>;
  publisher_in?: InputMaybe<Array<Scalars['Bytes']>>;
  publisher_lt?: InputMaybe<Scalars['Bytes']>;
  publisher_lte?: InputMaybe<Scalars['Bytes']>;
  publisher_not?: InputMaybe<Scalars['Bytes']>;
  publisher_not_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscriber?: InputMaybe<Scalars['Bytes']>;
  subscriber_contains?: InputMaybe<Scalars['Bytes']>;
  subscriber_gt?: InputMaybe<Scalars['Bytes']>;
  subscriber_gte?: InputMaybe<Scalars['Bytes']>;
  subscriber_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscriber_lt?: InputMaybe<Scalars['Bytes']>;
  subscriber_lte?: InputMaybe<Scalars['Bytes']>;
  subscriber_not?: InputMaybe<Scalars['Bytes']>;
  subscriber_not_contains?: InputMaybe<Scalars['Bytes']>;
  subscriber_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum IndexDistributionClaimedEvent_OrderBy {
  Addresses = 'addresses',
  Amount = 'amount',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  Index = 'index',
  IndexId = 'indexId',
  IndexCreatedAtBlockNumber = 'index__createdAtBlockNumber',
  IndexCreatedAtTimestamp = 'index__createdAtTimestamp',
  IndexId = 'index__id',
  IndexIndexId = 'index__indexId',
  IndexIndexValue = 'index__indexValue',
  IndexTotalAmountDistributedUntilUpdatedAt = 'index__totalAmountDistributedUntilUpdatedAt',
  IndexTotalSubscriptionsWithUnits = 'index__totalSubscriptionsWithUnits',
  IndexTotalUnits = 'index__totalUnits',
  IndexTotalUnitsApproved = 'index__totalUnitsApproved',
  IndexTotalUnitsPending = 'index__totalUnitsPending',
  IndexUpdatedAtBlockNumber = 'index__updatedAtBlockNumber',
  IndexUpdatedAtTimestamp = 'index__updatedAtTimestamp',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Publisher = 'publisher',
  Subscriber = 'subscriber',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash'
}

export type IndexSubscribedEvent = Event & {
  __typename?: 'IndexSubscribedEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   * addresses[2] = `subscriber`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  index: Index;
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars['BigInt'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars['Bytes'];
  /**
   * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
   * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
   *
   */
  subscriber: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
  userData: Scalars['Bytes'];
};

export type IndexSubscribedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<IndexSubscribedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  index?: InputMaybe<Scalars['String']>;
  indexId?: InputMaybe<Scalars['BigInt']>;
  indexId_gt?: InputMaybe<Scalars['BigInt']>;
  indexId_gte?: InputMaybe<Scalars['BigInt']>;
  indexId_in?: InputMaybe<Array<Scalars['BigInt']>>;
  indexId_lt?: InputMaybe<Scalars['BigInt']>;
  indexId_lte?: InputMaybe<Scalars['BigInt']>;
  indexId_not?: InputMaybe<Scalars['BigInt']>;
  indexId_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  index_?: InputMaybe<Index_Filter>;
  index_contains?: InputMaybe<Scalars['String']>;
  index_contains_nocase?: InputMaybe<Scalars['String']>;
  index_ends_with?: InputMaybe<Scalars['String']>;
  index_ends_with_nocase?: InputMaybe<Scalars['String']>;
  index_gt?: InputMaybe<Scalars['String']>;
  index_gte?: InputMaybe<Scalars['String']>;
  index_in?: InputMaybe<Array<Scalars['String']>>;
  index_lt?: InputMaybe<Scalars['String']>;
  index_lte?: InputMaybe<Scalars['String']>;
  index_not?: InputMaybe<Scalars['String']>;
  index_not_contains?: InputMaybe<Scalars['String']>;
  index_not_contains_nocase?: InputMaybe<Scalars['String']>;
  index_not_ends_with?: InputMaybe<Scalars['String']>;
  index_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  index_not_in?: InputMaybe<Array<Scalars['String']>>;
  index_not_starts_with?: InputMaybe<Scalars['String']>;
  index_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  index_starts_with?: InputMaybe<Scalars['String']>;
  index_starts_with_nocase?: InputMaybe<Scalars['String']>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<IndexSubscribedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  publisher?: InputMaybe<Scalars['Bytes']>;
  publisher_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_gt?: InputMaybe<Scalars['Bytes']>;
  publisher_gte?: InputMaybe<Scalars['Bytes']>;
  publisher_in?: InputMaybe<Array<Scalars['Bytes']>>;
  publisher_lt?: InputMaybe<Scalars['Bytes']>;
  publisher_lte?: InputMaybe<Scalars['Bytes']>;
  publisher_not?: InputMaybe<Scalars['Bytes']>;
  publisher_not_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscriber?: InputMaybe<Scalars['Bytes']>;
  subscriber_contains?: InputMaybe<Scalars['Bytes']>;
  subscriber_gt?: InputMaybe<Scalars['Bytes']>;
  subscriber_gte?: InputMaybe<Scalars['Bytes']>;
  subscriber_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscriber_lt?: InputMaybe<Scalars['Bytes']>;
  subscriber_lte?: InputMaybe<Scalars['Bytes']>;
  subscriber_not?: InputMaybe<Scalars['Bytes']>;
  subscriber_not_contains?: InputMaybe<Scalars['Bytes']>;
  subscriber_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  userData?: InputMaybe<Scalars['Bytes']>;
  userData_contains?: InputMaybe<Scalars['Bytes']>;
  userData_gt?: InputMaybe<Scalars['Bytes']>;
  userData_gte?: InputMaybe<Scalars['Bytes']>;
  userData_in?: InputMaybe<Array<Scalars['Bytes']>>;
  userData_lt?: InputMaybe<Scalars['Bytes']>;
  userData_lte?: InputMaybe<Scalars['Bytes']>;
  userData_not?: InputMaybe<Scalars['Bytes']>;
  userData_not_contains?: InputMaybe<Scalars['Bytes']>;
  userData_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum IndexSubscribedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  Index = 'index',
  IndexId = 'indexId',
  IndexCreatedAtBlockNumber = 'index__createdAtBlockNumber',
  IndexCreatedAtTimestamp = 'index__createdAtTimestamp',
  IndexId = 'index__id',
  IndexIndexId = 'index__indexId',
  IndexIndexValue = 'index__indexValue',
  IndexTotalAmountDistributedUntilUpdatedAt = 'index__totalAmountDistributedUntilUpdatedAt',
  IndexTotalSubscriptionsWithUnits = 'index__totalSubscriptionsWithUnits',
  IndexTotalUnits = 'index__totalUnits',
  IndexTotalUnitsApproved = 'index__totalUnitsApproved',
  IndexTotalUnitsPending = 'index__totalUnitsPending',
  IndexUpdatedAtBlockNumber = 'index__updatedAtBlockNumber',
  IndexUpdatedAtTimestamp = 'index__updatedAtTimestamp',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Publisher = 'publisher',
  Subscriber = 'subscriber',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash',
  UserData = 'userData'
}

/**
 * IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular `Index`.
 *
 */
export type IndexSubscription = {
  __typename?: 'IndexSubscription';
  /**
   * A boolean indicating whether the `IndexSubscription` is approved.
   * Approved subscriptions don't require `subscriber` to claim tokens that are distributed from the publisher.
   *
   */
  approved: Scalars['Boolean'];
  createdAtBlockNumber: Scalars['BigInt'];
  createdAtTimestamp: Scalars['BigInt'];
  /**
   * ID composed of: subscriberAddress-publisherAddress-tokenAddress-IndexId
   *
   */
  id: Scalars['ID'];
  index: Index;
  /**
   * The previous index value - used to calculate `totalAmountReceivedUntilUpdatedAt` field as of the `index.updatedAtTimestamp`.
   * The formula to get this value is:
   * `IndexSubscription.totalAmountReceivedUntilUpdatedAt + ((index.newIndexValue - indexSubscription.indexValueUntilUpdatedAt) * indexSubscription.units)`.
   *
   */
  indexValueUntilUpdatedAt: Scalars['BigInt'];
  subscriber: Account;
  /**
   * IndexSubscription approved events on the subscription.
   *
   */
  subscriptionApprovedEvents: Array<SubscriptionApprovedEvent>;
  subscriptionDistributionClaimedEvents: Array<SubscriptionDistributionClaimedEvent>;
  subscriptionRevokedEvents: Array<SubscriptionRevokedEvent>;
  subscriptionUnitsUpdatedEvents: Array<SubscriptionUnitsUpdatedEvent>;
  /**
   * The total amount of tokens you've received via IDA until
   * `updatedAtTimestamp`/`updatedAtBlock`.
   *
   */
  totalAmountReceivedUntilUpdatedAt: Scalars['BigInt'];
  /**
   * If `units` is `0`, it indicates that the subscription is "deleted" and `subscriber` is no longer subscribed to `index`.
   *
   */
  units: Scalars['BigInt'];
  updatedAtBlockNumber: Scalars['BigInt'];
  updatedAtTimestamp: Scalars['BigInt'];
};


/**
 * IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular `Index`.
 *
 */
export type IndexSubscriptionSubscriptionApprovedEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SubscriptionApprovedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SubscriptionApprovedEvent_Filter>;
};


/**
 * IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular `Index`.
 *
 */
export type IndexSubscriptionSubscriptionDistributionClaimedEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SubscriptionDistributionClaimedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SubscriptionDistributionClaimedEvent_Filter>;
};


/**
 * IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular `Index`.
 *
 */
export type IndexSubscriptionSubscriptionRevokedEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SubscriptionRevokedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SubscriptionRevokedEvent_Filter>;
};


/**
 * IndexSubscription: A higher order entity that contains subscription data for a `subscriber` account of a particular `Index`.
 *
 */
export type IndexSubscriptionSubscriptionUnitsUpdatedEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SubscriptionUnitsUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SubscriptionUnitsUpdatedEvent_Filter>;
};

export type IndexSubscription_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<IndexSubscription_Filter>>>;
  approved?: InputMaybe<Scalars['Boolean']>;
  approved_in?: InputMaybe<Array<Scalars['Boolean']>>;
  approved_not?: InputMaybe<Scalars['Boolean']>;
  approved_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  createdAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  index?: InputMaybe<Scalars['String']>;
  indexValueUntilUpdatedAt?: InputMaybe<Scalars['BigInt']>;
  indexValueUntilUpdatedAt_gt?: InputMaybe<Scalars['BigInt']>;
  indexValueUntilUpdatedAt_gte?: InputMaybe<Scalars['BigInt']>;
  indexValueUntilUpdatedAt_in?: InputMaybe<Array<Scalars['BigInt']>>;
  indexValueUntilUpdatedAt_lt?: InputMaybe<Scalars['BigInt']>;
  indexValueUntilUpdatedAt_lte?: InputMaybe<Scalars['BigInt']>;
  indexValueUntilUpdatedAt_not?: InputMaybe<Scalars['BigInt']>;
  indexValueUntilUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  index_?: InputMaybe<Index_Filter>;
  index_contains?: InputMaybe<Scalars['String']>;
  index_contains_nocase?: InputMaybe<Scalars['String']>;
  index_ends_with?: InputMaybe<Scalars['String']>;
  index_ends_with_nocase?: InputMaybe<Scalars['String']>;
  index_gt?: InputMaybe<Scalars['String']>;
  index_gte?: InputMaybe<Scalars['String']>;
  index_in?: InputMaybe<Array<Scalars['String']>>;
  index_lt?: InputMaybe<Scalars['String']>;
  index_lte?: InputMaybe<Scalars['String']>;
  index_not?: InputMaybe<Scalars['String']>;
  index_not_contains?: InputMaybe<Scalars['String']>;
  index_not_contains_nocase?: InputMaybe<Scalars['String']>;
  index_not_ends_with?: InputMaybe<Scalars['String']>;
  index_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  index_not_in?: InputMaybe<Array<Scalars['String']>>;
  index_not_starts_with?: InputMaybe<Scalars['String']>;
  index_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  index_starts_with?: InputMaybe<Scalars['String']>;
  index_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<IndexSubscription_Filter>>>;
  subscriber?: InputMaybe<Scalars['String']>;
  subscriber_?: InputMaybe<Account_Filter>;
  subscriber_contains?: InputMaybe<Scalars['String']>;
  subscriber_contains_nocase?: InputMaybe<Scalars['String']>;
  subscriber_ends_with?: InputMaybe<Scalars['String']>;
  subscriber_ends_with_nocase?: InputMaybe<Scalars['String']>;
  subscriber_gt?: InputMaybe<Scalars['String']>;
  subscriber_gte?: InputMaybe<Scalars['String']>;
  subscriber_in?: InputMaybe<Array<Scalars['String']>>;
  subscriber_lt?: InputMaybe<Scalars['String']>;
  subscriber_lte?: InputMaybe<Scalars['String']>;
  subscriber_not?: InputMaybe<Scalars['String']>;
  subscriber_not_contains?: InputMaybe<Scalars['String']>;
  subscriber_not_contains_nocase?: InputMaybe<Scalars['String']>;
  subscriber_not_ends_with?: InputMaybe<Scalars['String']>;
  subscriber_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  subscriber_not_in?: InputMaybe<Array<Scalars['String']>>;
  subscriber_not_starts_with?: InputMaybe<Scalars['String']>;
  subscriber_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  subscriber_starts_with?: InputMaybe<Scalars['String']>;
  subscriber_starts_with_nocase?: InputMaybe<Scalars['String']>;
  subscriptionApprovedEvents_?: InputMaybe<SubscriptionApprovedEvent_Filter>;
  subscriptionDistributionClaimedEvents_?: InputMaybe<SubscriptionDistributionClaimedEvent_Filter>;
  subscriptionRevokedEvents_?: InputMaybe<SubscriptionRevokedEvent_Filter>;
  subscriptionUnitsUpdatedEvents_?: InputMaybe<SubscriptionUnitsUpdatedEvent_Filter>;
  totalAmountReceivedUntilUpdatedAt?: InputMaybe<Scalars['BigInt']>;
  totalAmountReceivedUntilUpdatedAt_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountReceivedUntilUpdatedAt_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountReceivedUntilUpdatedAt_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountReceivedUntilUpdatedAt_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountReceivedUntilUpdatedAt_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountReceivedUntilUpdatedAt_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountReceivedUntilUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  units?: InputMaybe<Scalars['BigInt']>;
  units_gt?: InputMaybe<Scalars['BigInt']>;
  units_gte?: InputMaybe<Scalars['BigInt']>;
  units_in?: InputMaybe<Array<Scalars['BigInt']>>;
  units_lt?: InputMaybe<Scalars['BigInt']>;
  units_lte?: InputMaybe<Scalars['BigInt']>;
  units_not?: InputMaybe<Scalars['BigInt']>;
  units_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum IndexSubscription_OrderBy {
  Approved = 'approved',
  CreatedAtBlockNumber = 'createdAtBlockNumber',
  CreatedAtTimestamp = 'createdAtTimestamp',
  Id = 'id',
  Index = 'index',
  IndexValueUntilUpdatedAt = 'indexValueUntilUpdatedAt',
  IndexCreatedAtBlockNumber = 'index__createdAtBlockNumber',
  IndexCreatedAtTimestamp = 'index__createdAtTimestamp',
  IndexId = 'index__id',
  IndexIndexId = 'index__indexId',
  IndexIndexValue = 'index__indexValue',
  IndexTotalAmountDistributedUntilUpdatedAt = 'index__totalAmountDistributedUntilUpdatedAt',
  IndexTotalSubscriptionsWithUnits = 'index__totalSubscriptionsWithUnits',
  IndexTotalUnits = 'index__totalUnits',
  IndexTotalUnitsApproved = 'index__totalUnitsApproved',
  IndexTotalUnitsPending = 'index__totalUnitsPending',
  IndexUpdatedAtBlockNumber = 'index__updatedAtBlockNumber',
  IndexUpdatedAtTimestamp = 'index__updatedAtTimestamp',
  Subscriber = 'subscriber',
  SubscriberCreatedAtBlockNumber = 'subscriber__createdAtBlockNumber',
  SubscriberCreatedAtTimestamp = 'subscriber__createdAtTimestamp',
  SubscriberId = 'subscriber__id',
  SubscriberIsSuperApp = 'subscriber__isSuperApp',
  SubscriberUpdatedAtBlockNumber = 'subscriber__updatedAtBlockNumber',
  SubscriberUpdatedAtTimestamp = 'subscriber__updatedAtTimestamp',
  SubscriptionApprovedEvents = 'subscriptionApprovedEvents',
  SubscriptionDistributionClaimedEvents = 'subscriptionDistributionClaimedEvents',
  SubscriptionRevokedEvents = 'subscriptionRevokedEvents',
  SubscriptionUnitsUpdatedEvents = 'subscriptionUnitsUpdatedEvents',
  TotalAmountReceivedUntilUpdatedAt = 'totalAmountReceivedUntilUpdatedAt',
  Units = 'units',
  UpdatedAtBlockNumber = 'updatedAtBlockNumber',
  UpdatedAtTimestamp = 'updatedAtTimestamp'
}

export type IndexUnitsUpdatedEvent = Event & {
  __typename?: 'IndexUnitsUpdatedEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   * addresses[2] = `subscriber`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  index: Index;
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars['BigInt'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  oldUnits: Scalars['BigInt'];
  order: Scalars['BigInt'];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars['Bytes'];
  /**
   * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
   * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
   *
   */
  subscriber: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
  units: Scalars['BigInt'];
  userData: Scalars['Bytes'];
};

export type IndexUnitsUpdatedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<IndexUnitsUpdatedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  index?: InputMaybe<Scalars['String']>;
  indexId?: InputMaybe<Scalars['BigInt']>;
  indexId_gt?: InputMaybe<Scalars['BigInt']>;
  indexId_gte?: InputMaybe<Scalars['BigInt']>;
  indexId_in?: InputMaybe<Array<Scalars['BigInt']>>;
  indexId_lt?: InputMaybe<Scalars['BigInt']>;
  indexId_lte?: InputMaybe<Scalars['BigInt']>;
  indexId_not?: InputMaybe<Scalars['BigInt']>;
  indexId_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  index_?: InputMaybe<Index_Filter>;
  index_contains?: InputMaybe<Scalars['String']>;
  index_contains_nocase?: InputMaybe<Scalars['String']>;
  index_ends_with?: InputMaybe<Scalars['String']>;
  index_ends_with_nocase?: InputMaybe<Scalars['String']>;
  index_gt?: InputMaybe<Scalars['String']>;
  index_gte?: InputMaybe<Scalars['String']>;
  index_in?: InputMaybe<Array<Scalars['String']>>;
  index_lt?: InputMaybe<Scalars['String']>;
  index_lte?: InputMaybe<Scalars['String']>;
  index_not?: InputMaybe<Scalars['String']>;
  index_not_contains?: InputMaybe<Scalars['String']>;
  index_not_contains_nocase?: InputMaybe<Scalars['String']>;
  index_not_ends_with?: InputMaybe<Scalars['String']>;
  index_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  index_not_in?: InputMaybe<Array<Scalars['String']>>;
  index_not_starts_with?: InputMaybe<Scalars['String']>;
  index_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  index_starts_with?: InputMaybe<Scalars['String']>;
  index_starts_with_nocase?: InputMaybe<Scalars['String']>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  oldUnits?: InputMaybe<Scalars['BigInt']>;
  oldUnits_gt?: InputMaybe<Scalars['BigInt']>;
  oldUnits_gte?: InputMaybe<Scalars['BigInt']>;
  oldUnits_in?: InputMaybe<Array<Scalars['BigInt']>>;
  oldUnits_lt?: InputMaybe<Scalars['BigInt']>;
  oldUnits_lte?: InputMaybe<Scalars['BigInt']>;
  oldUnits_not?: InputMaybe<Scalars['BigInt']>;
  oldUnits_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  or?: InputMaybe<Array<InputMaybe<IndexUnitsUpdatedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  publisher?: InputMaybe<Scalars['Bytes']>;
  publisher_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_gt?: InputMaybe<Scalars['Bytes']>;
  publisher_gte?: InputMaybe<Scalars['Bytes']>;
  publisher_in?: InputMaybe<Array<Scalars['Bytes']>>;
  publisher_lt?: InputMaybe<Scalars['Bytes']>;
  publisher_lte?: InputMaybe<Scalars['Bytes']>;
  publisher_not?: InputMaybe<Scalars['Bytes']>;
  publisher_not_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscriber?: InputMaybe<Scalars['Bytes']>;
  subscriber_contains?: InputMaybe<Scalars['Bytes']>;
  subscriber_gt?: InputMaybe<Scalars['Bytes']>;
  subscriber_gte?: InputMaybe<Scalars['Bytes']>;
  subscriber_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscriber_lt?: InputMaybe<Scalars['Bytes']>;
  subscriber_lte?: InputMaybe<Scalars['Bytes']>;
  subscriber_not?: InputMaybe<Scalars['Bytes']>;
  subscriber_not_contains?: InputMaybe<Scalars['Bytes']>;
  subscriber_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  units?: InputMaybe<Scalars['BigInt']>;
  units_gt?: InputMaybe<Scalars['BigInt']>;
  units_gte?: InputMaybe<Scalars['BigInt']>;
  units_in?: InputMaybe<Array<Scalars['BigInt']>>;
  units_lt?: InputMaybe<Scalars['BigInt']>;
  units_lte?: InputMaybe<Scalars['BigInt']>;
  units_not?: InputMaybe<Scalars['BigInt']>;
  units_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  userData?: InputMaybe<Scalars['Bytes']>;
  userData_contains?: InputMaybe<Scalars['Bytes']>;
  userData_gt?: InputMaybe<Scalars['Bytes']>;
  userData_gte?: InputMaybe<Scalars['Bytes']>;
  userData_in?: InputMaybe<Array<Scalars['Bytes']>>;
  userData_lt?: InputMaybe<Scalars['Bytes']>;
  userData_lte?: InputMaybe<Scalars['Bytes']>;
  userData_not?: InputMaybe<Scalars['Bytes']>;
  userData_not_contains?: InputMaybe<Scalars['Bytes']>;
  userData_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum IndexUnitsUpdatedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  Index = 'index',
  IndexId = 'indexId',
  IndexCreatedAtBlockNumber = 'index__createdAtBlockNumber',
  IndexCreatedAtTimestamp = 'index__createdAtTimestamp',
  IndexId = 'index__id',
  IndexIndexId = 'index__indexId',
  IndexIndexValue = 'index__indexValue',
  IndexTotalAmountDistributedUntilUpdatedAt = 'index__totalAmountDistributedUntilUpdatedAt',
  IndexTotalSubscriptionsWithUnits = 'index__totalSubscriptionsWithUnits',
  IndexTotalUnits = 'index__totalUnits',
  IndexTotalUnitsApproved = 'index__totalUnitsApproved',
  IndexTotalUnitsPending = 'index__totalUnitsPending',
  IndexUpdatedAtBlockNumber = 'index__updatedAtBlockNumber',
  IndexUpdatedAtTimestamp = 'index__updatedAtTimestamp',
  LogIndex = 'logIndex',
  Name = 'name',
  OldUnits = 'oldUnits',
  Order = 'order',
  Publisher = 'publisher',
  Subscriber = 'subscriber',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash',
  Units = 'units',
  UserData = 'userData'
}

export type IndexUnsubscribedEvent = Event & {
  __typename?: 'IndexUnsubscribedEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   * addresses[2] = `subscriber`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  index: Index;
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars['BigInt'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars['Bytes'];
  /**
   * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
   * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
   *
   */
  subscriber: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
  userData: Scalars['Bytes'];
};

export type IndexUnsubscribedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<IndexUnsubscribedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  index?: InputMaybe<Scalars['String']>;
  indexId?: InputMaybe<Scalars['BigInt']>;
  indexId_gt?: InputMaybe<Scalars['BigInt']>;
  indexId_gte?: InputMaybe<Scalars['BigInt']>;
  indexId_in?: InputMaybe<Array<Scalars['BigInt']>>;
  indexId_lt?: InputMaybe<Scalars['BigInt']>;
  indexId_lte?: InputMaybe<Scalars['BigInt']>;
  indexId_not?: InputMaybe<Scalars['BigInt']>;
  indexId_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  index_?: InputMaybe<Index_Filter>;
  index_contains?: InputMaybe<Scalars['String']>;
  index_contains_nocase?: InputMaybe<Scalars['String']>;
  index_ends_with?: InputMaybe<Scalars['String']>;
  index_ends_with_nocase?: InputMaybe<Scalars['String']>;
  index_gt?: InputMaybe<Scalars['String']>;
  index_gte?: InputMaybe<Scalars['String']>;
  index_in?: InputMaybe<Array<Scalars['String']>>;
  index_lt?: InputMaybe<Scalars['String']>;
  index_lte?: InputMaybe<Scalars['String']>;
  index_not?: InputMaybe<Scalars['String']>;
  index_not_contains?: InputMaybe<Scalars['String']>;
  index_not_contains_nocase?: InputMaybe<Scalars['String']>;
  index_not_ends_with?: InputMaybe<Scalars['String']>;
  index_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  index_not_in?: InputMaybe<Array<Scalars['String']>>;
  index_not_starts_with?: InputMaybe<Scalars['String']>;
  index_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  index_starts_with?: InputMaybe<Scalars['String']>;
  index_starts_with_nocase?: InputMaybe<Scalars['String']>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<IndexUnsubscribedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  publisher?: InputMaybe<Scalars['Bytes']>;
  publisher_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_gt?: InputMaybe<Scalars['Bytes']>;
  publisher_gte?: InputMaybe<Scalars['Bytes']>;
  publisher_in?: InputMaybe<Array<Scalars['Bytes']>>;
  publisher_lt?: InputMaybe<Scalars['Bytes']>;
  publisher_lte?: InputMaybe<Scalars['Bytes']>;
  publisher_not?: InputMaybe<Scalars['Bytes']>;
  publisher_not_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscriber?: InputMaybe<Scalars['Bytes']>;
  subscriber_contains?: InputMaybe<Scalars['Bytes']>;
  subscriber_gt?: InputMaybe<Scalars['Bytes']>;
  subscriber_gte?: InputMaybe<Scalars['Bytes']>;
  subscriber_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscriber_lt?: InputMaybe<Scalars['Bytes']>;
  subscriber_lte?: InputMaybe<Scalars['Bytes']>;
  subscriber_not?: InputMaybe<Scalars['Bytes']>;
  subscriber_not_contains?: InputMaybe<Scalars['Bytes']>;
  subscriber_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  userData?: InputMaybe<Scalars['Bytes']>;
  userData_contains?: InputMaybe<Scalars['Bytes']>;
  userData_gt?: InputMaybe<Scalars['Bytes']>;
  userData_gte?: InputMaybe<Scalars['Bytes']>;
  userData_in?: InputMaybe<Array<Scalars['Bytes']>>;
  userData_lt?: InputMaybe<Scalars['Bytes']>;
  userData_lte?: InputMaybe<Scalars['Bytes']>;
  userData_not?: InputMaybe<Scalars['Bytes']>;
  userData_not_contains?: InputMaybe<Scalars['Bytes']>;
  userData_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum IndexUnsubscribedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  Index = 'index',
  IndexId = 'indexId',
  IndexCreatedAtBlockNumber = 'index__createdAtBlockNumber',
  IndexCreatedAtTimestamp = 'index__createdAtTimestamp',
  IndexId = 'index__id',
  IndexIndexId = 'index__indexId',
  IndexIndexValue = 'index__indexValue',
  IndexTotalAmountDistributedUntilUpdatedAt = 'index__totalAmountDistributedUntilUpdatedAt',
  IndexTotalSubscriptionsWithUnits = 'index__totalSubscriptionsWithUnits',
  IndexTotalUnits = 'index__totalUnits',
  IndexTotalUnitsApproved = 'index__totalUnitsApproved',
  IndexTotalUnitsPending = 'index__totalUnitsPending',
  IndexUpdatedAtBlockNumber = 'index__updatedAtBlockNumber',
  IndexUpdatedAtTimestamp = 'index__updatedAtTimestamp',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Publisher = 'publisher',
  Subscriber = 'subscriber',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash',
  UserData = 'userData'
}

export type IndexUpdatedEvent = Event & {
  __typename?: 'IndexUpdatedEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  index: Index;
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars['BigInt'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  newIndexValue: Scalars['BigInt'];
  oldIndexValue: Scalars['BigInt'];
  order: Scalars['BigInt'];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  totalUnitsApproved: Scalars['BigInt'];
  totalUnitsPending: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
  userData: Scalars['Bytes'];
};

export type IndexUpdatedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<IndexUpdatedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  index?: InputMaybe<Scalars['String']>;
  indexId?: InputMaybe<Scalars['BigInt']>;
  indexId_gt?: InputMaybe<Scalars['BigInt']>;
  indexId_gte?: InputMaybe<Scalars['BigInt']>;
  indexId_in?: InputMaybe<Array<Scalars['BigInt']>>;
  indexId_lt?: InputMaybe<Scalars['BigInt']>;
  indexId_lte?: InputMaybe<Scalars['BigInt']>;
  indexId_not?: InputMaybe<Scalars['BigInt']>;
  indexId_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  index_?: InputMaybe<Index_Filter>;
  index_contains?: InputMaybe<Scalars['String']>;
  index_contains_nocase?: InputMaybe<Scalars['String']>;
  index_ends_with?: InputMaybe<Scalars['String']>;
  index_ends_with_nocase?: InputMaybe<Scalars['String']>;
  index_gt?: InputMaybe<Scalars['String']>;
  index_gte?: InputMaybe<Scalars['String']>;
  index_in?: InputMaybe<Array<Scalars['String']>>;
  index_lt?: InputMaybe<Scalars['String']>;
  index_lte?: InputMaybe<Scalars['String']>;
  index_not?: InputMaybe<Scalars['String']>;
  index_not_contains?: InputMaybe<Scalars['String']>;
  index_not_contains_nocase?: InputMaybe<Scalars['String']>;
  index_not_ends_with?: InputMaybe<Scalars['String']>;
  index_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  index_not_in?: InputMaybe<Array<Scalars['String']>>;
  index_not_starts_with?: InputMaybe<Scalars['String']>;
  index_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  index_starts_with?: InputMaybe<Scalars['String']>;
  index_starts_with_nocase?: InputMaybe<Scalars['String']>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  newIndexValue?: InputMaybe<Scalars['BigInt']>;
  newIndexValue_gt?: InputMaybe<Scalars['BigInt']>;
  newIndexValue_gte?: InputMaybe<Scalars['BigInt']>;
  newIndexValue_in?: InputMaybe<Array<Scalars['BigInt']>>;
  newIndexValue_lt?: InputMaybe<Scalars['BigInt']>;
  newIndexValue_lte?: InputMaybe<Scalars['BigInt']>;
  newIndexValue_not?: InputMaybe<Scalars['BigInt']>;
  newIndexValue_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  oldIndexValue?: InputMaybe<Scalars['BigInt']>;
  oldIndexValue_gt?: InputMaybe<Scalars['BigInt']>;
  oldIndexValue_gte?: InputMaybe<Scalars['BigInt']>;
  oldIndexValue_in?: InputMaybe<Array<Scalars['BigInt']>>;
  oldIndexValue_lt?: InputMaybe<Scalars['BigInt']>;
  oldIndexValue_lte?: InputMaybe<Scalars['BigInt']>;
  oldIndexValue_not?: InputMaybe<Scalars['BigInt']>;
  oldIndexValue_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  or?: InputMaybe<Array<InputMaybe<IndexUpdatedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  publisher?: InputMaybe<Scalars['Bytes']>;
  publisher_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_gt?: InputMaybe<Scalars['Bytes']>;
  publisher_gte?: InputMaybe<Scalars['Bytes']>;
  publisher_in?: InputMaybe<Array<Scalars['Bytes']>>;
  publisher_lt?: InputMaybe<Scalars['Bytes']>;
  publisher_lte?: InputMaybe<Scalars['Bytes']>;
  publisher_not?: InputMaybe<Scalars['Bytes']>;
  publisher_not_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  totalUnitsApproved?: InputMaybe<Scalars['BigInt']>;
  totalUnitsApproved_gt?: InputMaybe<Scalars['BigInt']>;
  totalUnitsApproved_gte?: InputMaybe<Scalars['BigInt']>;
  totalUnitsApproved_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalUnitsApproved_lt?: InputMaybe<Scalars['BigInt']>;
  totalUnitsApproved_lte?: InputMaybe<Scalars['BigInt']>;
  totalUnitsApproved_not?: InputMaybe<Scalars['BigInt']>;
  totalUnitsApproved_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalUnitsPending?: InputMaybe<Scalars['BigInt']>;
  totalUnitsPending_gt?: InputMaybe<Scalars['BigInt']>;
  totalUnitsPending_gte?: InputMaybe<Scalars['BigInt']>;
  totalUnitsPending_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalUnitsPending_lt?: InputMaybe<Scalars['BigInt']>;
  totalUnitsPending_lte?: InputMaybe<Scalars['BigInt']>;
  totalUnitsPending_not?: InputMaybe<Scalars['BigInt']>;
  totalUnitsPending_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  userData?: InputMaybe<Scalars['Bytes']>;
  userData_contains?: InputMaybe<Scalars['Bytes']>;
  userData_gt?: InputMaybe<Scalars['Bytes']>;
  userData_gte?: InputMaybe<Scalars['Bytes']>;
  userData_in?: InputMaybe<Array<Scalars['Bytes']>>;
  userData_lt?: InputMaybe<Scalars['Bytes']>;
  userData_lte?: InputMaybe<Scalars['Bytes']>;
  userData_not?: InputMaybe<Scalars['Bytes']>;
  userData_not_contains?: InputMaybe<Scalars['Bytes']>;
  userData_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum IndexUpdatedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  Index = 'index',
  IndexId = 'indexId',
  IndexCreatedAtBlockNumber = 'index__createdAtBlockNumber',
  IndexCreatedAtTimestamp = 'index__createdAtTimestamp',
  IndexId = 'index__id',
  IndexIndexId = 'index__indexId',
  IndexIndexValue = 'index__indexValue',
  IndexTotalAmountDistributedUntilUpdatedAt = 'index__totalAmountDistributedUntilUpdatedAt',
  IndexTotalSubscriptionsWithUnits = 'index__totalSubscriptionsWithUnits',
  IndexTotalUnits = 'index__totalUnits',
  IndexTotalUnitsApproved = 'index__totalUnitsApproved',
  IndexTotalUnitsPending = 'index__totalUnitsPending',
  IndexUpdatedAtBlockNumber = 'index__updatedAtBlockNumber',
  IndexUpdatedAtTimestamp = 'index__updatedAtTimestamp',
  LogIndex = 'logIndex',
  Name = 'name',
  NewIndexValue = 'newIndexValue',
  OldIndexValue = 'oldIndexValue',
  Order = 'order',
  Publisher = 'publisher',
  Timestamp = 'timestamp',
  Token = 'token',
  TotalUnitsApproved = 'totalUnitsApproved',
  TotalUnitsPending = 'totalUnitsPending',
  TransactionHash = 'transactionHash',
  UserData = 'userData'
}

export type Index_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Index_Filter>>>;
  createdAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  indexCreatedEvent?: InputMaybe<Scalars['String']>;
  indexCreatedEvent_?: InputMaybe<IndexCreatedEvent_Filter>;
  indexCreatedEvent_contains?: InputMaybe<Scalars['String']>;
  indexCreatedEvent_contains_nocase?: InputMaybe<Scalars['String']>;
  indexCreatedEvent_ends_with?: InputMaybe<Scalars['String']>;
  indexCreatedEvent_ends_with_nocase?: InputMaybe<Scalars['String']>;
  indexCreatedEvent_gt?: InputMaybe<Scalars['String']>;
  indexCreatedEvent_gte?: InputMaybe<Scalars['String']>;
  indexCreatedEvent_in?: InputMaybe<Array<Scalars['String']>>;
  indexCreatedEvent_lt?: InputMaybe<Scalars['String']>;
  indexCreatedEvent_lte?: InputMaybe<Scalars['String']>;
  indexCreatedEvent_not?: InputMaybe<Scalars['String']>;
  indexCreatedEvent_not_contains?: InputMaybe<Scalars['String']>;
  indexCreatedEvent_not_contains_nocase?: InputMaybe<Scalars['String']>;
  indexCreatedEvent_not_ends_with?: InputMaybe<Scalars['String']>;
  indexCreatedEvent_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  indexCreatedEvent_not_in?: InputMaybe<Array<Scalars['String']>>;
  indexCreatedEvent_not_starts_with?: InputMaybe<Scalars['String']>;
  indexCreatedEvent_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  indexCreatedEvent_starts_with?: InputMaybe<Scalars['String']>;
  indexCreatedEvent_starts_with_nocase?: InputMaybe<Scalars['String']>;
  indexDistributionClaimedEvents_?: InputMaybe<IndexDistributionClaimedEvent_Filter>;
  indexId?: InputMaybe<Scalars['BigInt']>;
  indexId_gt?: InputMaybe<Scalars['BigInt']>;
  indexId_gte?: InputMaybe<Scalars['BigInt']>;
  indexId_in?: InputMaybe<Array<Scalars['BigInt']>>;
  indexId_lt?: InputMaybe<Scalars['BigInt']>;
  indexId_lte?: InputMaybe<Scalars['BigInt']>;
  indexId_not?: InputMaybe<Scalars['BigInt']>;
  indexId_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  indexSubscribedEvents_?: InputMaybe<IndexSubscribedEvent_Filter>;
  indexUnitsUpdatedEvents_?: InputMaybe<IndexUnitsUpdatedEvent_Filter>;
  indexUnsubscribedEvents_?: InputMaybe<IndexUnsubscribedEvent_Filter>;
  indexUpdatedEvents_?: InputMaybe<IndexUpdatedEvent_Filter>;
  indexValue?: InputMaybe<Scalars['BigInt']>;
  indexValue_gt?: InputMaybe<Scalars['BigInt']>;
  indexValue_gte?: InputMaybe<Scalars['BigInt']>;
  indexValue_in?: InputMaybe<Array<Scalars['BigInt']>>;
  indexValue_lt?: InputMaybe<Scalars['BigInt']>;
  indexValue_lte?: InputMaybe<Scalars['BigInt']>;
  indexValue_not?: InputMaybe<Scalars['BigInt']>;
  indexValue_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  or?: InputMaybe<Array<InputMaybe<Index_Filter>>>;
  publisher?: InputMaybe<Scalars['String']>;
  publisher_?: InputMaybe<Account_Filter>;
  publisher_contains?: InputMaybe<Scalars['String']>;
  publisher_contains_nocase?: InputMaybe<Scalars['String']>;
  publisher_ends_with?: InputMaybe<Scalars['String']>;
  publisher_ends_with_nocase?: InputMaybe<Scalars['String']>;
  publisher_gt?: InputMaybe<Scalars['String']>;
  publisher_gte?: InputMaybe<Scalars['String']>;
  publisher_in?: InputMaybe<Array<Scalars['String']>>;
  publisher_lt?: InputMaybe<Scalars['String']>;
  publisher_lte?: InputMaybe<Scalars['String']>;
  publisher_not?: InputMaybe<Scalars['String']>;
  publisher_not_contains?: InputMaybe<Scalars['String']>;
  publisher_not_contains_nocase?: InputMaybe<Scalars['String']>;
  publisher_not_ends_with?: InputMaybe<Scalars['String']>;
  publisher_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  publisher_not_in?: InputMaybe<Array<Scalars['String']>>;
  publisher_not_starts_with?: InputMaybe<Scalars['String']>;
  publisher_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  publisher_starts_with?: InputMaybe<Scalars['String']>;
  publisher_starts_with_nocase?: InputMaybe<Scalars['String']>;
  subscriptions_?: InputMaybe<IndexSubscription_Filter>;
  token?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  totalAmountDistributedUntilUpdatedAt?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributedUntilUpdatedAt_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributedUntilUpdatedAt_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributedUntilUpdatedAt_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountDistributedUntilUpdatedAt_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributedUntilUpdatedAt_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributedUntilUpdatedAt_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributedUntilUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalSubscriptionsWithUnits?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_gt?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_gte?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_in?: InputMaybe<Array<Scalars['Int']>>;
  totalSubscriptionsWithUnits_lt?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_lte?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_not?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalUnits?: InputMaybe<Scalars['BigInt']>;
  totalUnitsApproved?: InputMaybe<Scalars['BigInt']>;
  totalUnitsApproved_gt?: InputMaybe<Scalars['BigInt']>;
  totalUnitsApproved_gte?: InputMaybe<Scalars['BigInt']>;
  totalUnitsApproved_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalUnitsApproved_lt?: InputMaybe<Scalars['BigInt']>;
  totalUnitsApproved_lte?: InputMaybe<Scalars['BigInt']>;
  totalUnitsApproved_not?: InputMaybe<Scalars['BigInt']>;
  totalUnitsApproved_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalUnitsPending?: InputMaybe<Scalars['BigInt']>;
  totalUnitsPending_gt?: InputMaybe<Scalars['BigInt']>;
  totalUnitsPending_gte?: InputMaybe<Scalars['BigInt']>;
  totalUnitsPending_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalUnitsPending_lt?: InputMaybe<Scalars['BigInt']>;
  totalUnitsPending_lte?: InputMaybe<Scalars['BigInt']>;
  totalUnitsPending_not?: InputMaybe<Scalars['BigInt']>;
  totalUnitsPending_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalUnits_gt?: InputMaybe<Scalars['BigInt']>;
  totalUnits_gte?: InputMaybe<Scalars['BigInt']>;
  totalUnits_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalUnits_lt?: InputMaybe<Scalars['BigInt']>;
  totalUnits_lte?: InputMaybe<Scalars['BigInt']>;
  totalUnits_not?: InputMaybe<Scalars['BigInt']>;
  totalUnits_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum Index_OrderBy {
  CreatedAtBlockNumber = 'createdAtBlockNumber',
  CreatedAtTimestamp = 'createdAtTimestamp',
  Id = 'id',
  IndexCreatedEvent = 'indexCreatedEvent',
  IndexCreatedEventBlockNumber = 'indexCreatedEvent__blockNumber',
  IndexCreatedEventGasPrice = 'indexCreatedEvent__gasPrice',
  IndexCreatedEventGasUsed = 'indexCreatedEvent__gasUsed',
  IndexCreatedEventId = 'indexCreatedEvent__id',
  IndexCreatedEventIndexId = 'indexCreatedEvent__indexId',
  IndexCreatedEventLogIndex = 'indexCreatedEvent__logIndex',
  IndexCreatedEventName = 'indexCreatedEvent__name',
  IndexCreatedEventOrder = 'indexCreatedEvent__order',
  IndexCreatedEventPublisher = 'indexCreatedEvent__publisher',
  IndexCreatedEventTimestamp = 'indexCreatedEvent__timestamp',
  IndexCreatedEventToken = 'indexCreatedEvent__token',
  IndexCreatedEventTransactionHash = 'indexCreatedEvent__transactionHash',
  IndexCreatedEventUserData = 'indexCreatedEvent__userData',
  IndexDistributionClaimedEvents = 'indexDistributionClaimedEvents',
  IndexId = 'indexId',
  IndexSubscribedEvents = 'indexSubscribedEvents',
  IndexUnitsUpdatedEvents = 'indexUnitsUpdatedEvents',
  IndexUnsubscribedEvents = 'indexUnsubscribedEvents',
  IndexUpdatedEvents = 'indexUpdatedEvents',
  IndexValue = 'indexValue',
  Publisher = 'publisher',
  PublisherCreatedAtBlockNumber = 'publisher__createdAtBlockNumber',
  PublisherCreatedAtTimestamp = 'publisher__createdAtTimestamp',
  PublisherId = 'publisher__id',
  PublisherIsSuperApp = 'publisher__isSuperApp',
  PublisherUpdatedAtBlockNumber = 'publisher__updatedAtBlockNumber',
  PublisherUpdatedAtTimestamp = 'publisher__updatedAtTimestamp',
  Subscriptions = 'subscriptions',
  Token = 'token',
  TokenCreatedAtBlockNumber = 'token__createdAtBlockNumber',
  TokenCreatedAtTimestamp = 'token__createdAtTimestamp',
  TokenDecimals = 'token__decimals',
  TokenId = 'token__id',
  TokenIsListed = 'token__isListed',
  TokenIsNativeAssetSuperToken = 'token__isNativeAssetSuperToken',
  TokenIsSuperToken = 'token__isSuperToken',
  TokenName = 'token__name',
  TokenSymbol = 'token__symbol',
  TokenUnderlyingAddress = 'token__underlyingAddress',
  TotalAmountDistributedUntilUpdatedAt = 'totalAmountDistributedUntilUpdatedAt',
  TotalSubscriptionsWithUnits = 'totalSubscriptionsWithUnits',
  TotalUnits = 'totalUnits',
  TotalUnitsApproved = 'totalUnitsApproved',
  TotalUnitsPending = 'totalUnitsPending',
  UpdatedAtBlockNumber = 'updatedAtBlockNumber',
  UpdatedAtTimestamp = 'updatedAtTimestamp'
}

export type InternalPinRequest = {
  /** The shared secret */
  items: Array<Scalars['Url']>;
  /** The shared secret */
  secret: Scalars['String'];
};

export type InternalPinResult = {
  __typename?: 'InternalPinResult';
  ipfs: Scalars['String'];
  referenceItem: Scalars['Url'];
};

export type InviteRequest = {
  invites: Array<Scalars['EthereumAddress']>;
  secret: Scalars['String'];
};

export type InvitedResult = {
  __typename?: 'InvitedResult';
  address: Scalars['EthereumAddress'];
  when?: Maybe<Scalars['DateTime']>;
};

export type JailEvent = Event & {
  __typename?: 'JailEvent';
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  app: Scalars['Bytes'];
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  reason: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
};

export type JailEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<JailEvent_Filter>>>;
  app?: InputMaybe<Scalars['Bytes']>;
  app_contains?: InputMaybe<Scalars['Bytes']>;
  app_gt?: InputMaybe<Scalars['Bytes']>;
  app_gte?: InputMaybe<Scalars['Bytes']>;
  app_in?: InputMaybe<Array<Scalars['Bytes']>>;
  app_lt?: InputMaybe<Scalars['Bytes']>;
  app_lte?: InputMaybe<Scalars['Bytes']>;
  app_not?: InputMaybe<Scalars['Bytes']>;
  app_not_contains?: InputMaybe<Scalars['Bytes']>;
  app_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<JailEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  reason?: InputMaybe<Scalars['BigInt']>;
  reason_gt?: InputMaybe<Scalars['BigInt']>;
  reason_gte?: InputMaybe<Scalars['BigInt']>;
  reason_in?: InputMaybe<Array<Scalars['BigInt']>>;
  reason_lt?: InputMaybe<Scalars['BigInt']>;
  reason_lte?: InputMaybe<Scalars['BigInt']>;
  reason_not?: InputMaybe<Scalars['BigInt']>;
  reason_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum JailEvent_OrderBy {
  Addresses = 'addresses',
  App = 'app',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Reason = 'reason',
  Timestamp = 'timestamp',
  TransactionHash = 'transactionHash'
}

export type LimitedFeeCollectModuleParams = {
  /** The collect module amount info */
  amount: ModuleFeeAmountParams;
  /** The collect module limit */
  collectLimit: Scalars['String'];
  /** Follower only */
  followerOnly: Scalars['Boolean'];
  /** The collect module recipient address */
  recipient: Scalars['EthereumAddress'];
  /** The collect module referral fee */
  referralFee: Scalars['Float'];
};

export type LimitedFeeCollectModuleSettings = {
  __typename?: 'LimitedFeeCollectModuleSettings';
  /** The collect module amount info */
  amount: ModuleFeeAmount;
  /** The collect module limit */
  collectLimit: Scalars['String'];
  contractAddress: Scalars['ContractAddress'];
  /** Follower only */
  followerOnly: Scalars['Boolean'];
  /** The collect module recipient address */
  recipient: Scalars['EthereumAddress'];
  /** The collect module referral fee */
  referralFee: Scalars['Float'];
  /** The collect modules enum */
  type: CollectModules;
};

export type LimitedTimedFeeCollectModuleParams = {
  /** The collect module amount info */
  amount: ModuleFeeAmountParams;
  /** The collect module limit */
  collectLimit: Scalars['String'];
  /** Follower only */
  followerOnly: Scalars['Boolean'];
  /** The collect module recipient address */
  recipient: Scalars['EthereumAddress'];
  /** The collect module referral fee */
  referralFee: Scalars['Float'];
};

export type LimitedTimedFeeCollectModuleSettings = {
  __typename?: 'LimitedTimedFeeCollectModuleSettings';
  /** The collect module amount info */
  amount: ModuleFeeAmount;
  /** The collect module limit */
  collectLimit: Scalars['String'];
  contractAddress: Scalars['ContractAddress'];
  /** The collect module end timestamp */
  endTimestamp: Scalars['DateTime'];
  /** Follower only */
  followerOnly: Scalars['Boolean'];
  /** The collect module recipient address */
  recipient: Scalars['EthereumAddress'];
  /** The collect module referral fee */
  referralFee: Scalars['Float'];
  /** The collect modules enum */
  type: CollectModules;
};

export type Log = {
  __typename?: 'Log';
  address: Scalars['ContractAddress'];
  blockHash: Scalars['String'];
  blockNumber: Scalars['Int'];
  data: Scalars['String'];
  logIndex: Scalars['Int'];
  removed: Scalars['Boolean'];
  topics: Array<Scalars['String']>;
  transactionHash: Scalars['TxHash'];
  transactionIndex: Scalars['Int'];
};

export type MainPostReference = Mirror | Post;

/** The Media url */
export type Media = {
  __typename?: 'Media';
  /** The alt tags for accessibility */
  altTag?: Maybe<Scalars['String']>;
  /** The cover for any video or audio you attached */
  cover?: Maybe<Scalars['Url']>;
  /** Height - will always be null on the public API */
  height?: Maybe<Scalars['Int']>;
  /** The image/audio/video mime type for the publication */
  mimeType?: Maybe<Scalars['MimeType']>;
  /** Size - will always be null on the public API */
  size?: Maybe<Scalars['Int']>;
  /** The token image nft */
  url: Scalars['Url'];
  /** Width - will always be null on the public API */
  width?: Maybe<Scalars['Int']>;
};

/** Media object output */
export type MediaOutput = {
  __typename?: 'MediaOutput';
  /** The alt tags for accessibility */
  altTag?: Maybe<Scalars['String']>;
  /** The cover for any video or audio you attached */
  cover?: Maybe<Scalars['Url']>;
  item: Scalars['Url'];
  source?: Maybe<PublicationMediaSource>;
  /** This is the mime type of media */
  type?: Maybe<Scalars['MimeType']>;
};

/** The Media Set */
export type MediaSet = {
  __typename?: 'MediaSet';
  /**
   * Medium media - will always be null on the public API
   * @deprecated should not be used will always be null - use transform function to get small media
   */
  medium?: Maybe<Media>;
  /** Original media as found on the publication metadata */
  onChain: Media;
  /** Optimized media, snapshotted and served from a CDN */
  optimized?: Maybe<Media>;
  /** On-chain or snapshotted media on a CDN */
  original: Media;
  /**
   * Small media - will always be null on the public API
   * @deprecated should not be used will always be null - use transform function to get small media
   */
  small?: Maybe<Media>;
  transformed?: Maybe<Media>;
};


/** The Media Set */
export type MediaSetTransformedArgs = {
  params: MediaTransformParams;
};

export type MediaTransformParams = {
  /** Set the transformed image's height. You can use specific size in pixels eg. 100px, a percentage eg. 50% or set as 'auto' to be set automatically. Default value is 'auto'. */
  height?: InputMaybe<Scalars['ImageSizeTransform']>;
  /** Set if you want to keep the image's original aspect ratio. True by default. If explicitly set to false, the image will stretch based on the width and height values. */
  keepAspectRatio?: InputMaybe<Scalars['Boolean']>;
  /** Set the transformed image's width. You can use specific size in pixels eg. 100px, a percentage eg. 50% or set as 'auto' to be set automatically. Default value is 'auto'. */
  width?: InputMaybe<Scalars['ImageSizeTransform']>;
};

export type MentionPublication = Comment | Post;

/** The metadata attribute input */
export type MetadataAttributeInput = {
  /** The display type */
  displayType?: InputMaybe<PublicationMetadataDisplayTypes>;
  /** The trait type - can be anything its the name it will render so include spaces */
  traitType: Scalars['String'];
  /** The value */
  value: Scalars['String'];
};

/** The metadata attribute output */
export type MetadataAttributeOutput = {
  __typename?: 'MetadataAttributeOutput';
  /** The display type */
  displayType?: Maybe<PublicationMetadataDisplayTypes>;
  /** The trait type - can be anything its the name it will render so include spaces */
  traitType?: Maybe<Scalars['String']>;
  /** The value */
  value?: Maybe<Scalars['String']>;
};

/** The metadata output */
export type MetadataOutput = {
  __typename?: 'MetadataOutput';
  /** The main focus of the publication */
  animatedUrl?: Maybe<Scalars['Url']>;
  /** The attributes */
  attributes: Array<MetadataAttributeOutput>;
  /** This is the metadata content for the publication, should be markdown */
  content?: Maybe<Scalars['Markdown']>;
  /** The content warning for the publication */
  contentWarning?: Maybe<PublicationContentWarning>;
  /** The image cover for video/music publications */
  cover?: Maybe<MediaSet>;
  /** This is the metadata description */
  description?: Maybe<Scalars['Markdown']>;
  /** The publication's encryption params in case it's encrypted */
  encryptionParams?: Maybe<EncryptionParamsOutput>;
  /** This is the image attached to the metadata and the property used to show the NFT! */
  image?: Maybe<Scalars['Url']>;
  /** The locale of the publication,  */
  locale?: Maybe<Scalars['Locale']>;
  /** The main focus of the publication */
  mainContentFocus: PublicationMainFocus;
  /** The images/audios/videos for the publication */
  media: Array<MediaSet>;
  /** The metadata name */
  name?: Maybe<Scalars['String']>;
  /** The tags for the publication */
  tags: Array<Scalars['String']>;
};

export type MintedEvent = Event & {
  __typename?: 'MintedEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `operator`
   * addresses[2] = `to`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  amount: Scalars['BigInt'];
  blockNumber: Scalars['BigInt'];
  data: Scalars['Bytes'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  operator: Scalars['Bytes'];
  operatorData: Scalars['Bytes'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  to: Scalars['Bytes'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
};

export type MintedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  and?: InputMaybe<Array<InputMaybe<MintedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  data?: InputMaybe<Scalars['Bytes']>;
  data_contains?: InputMaybe<Scalars['Bytes']>;
  data_gt?: InputMaybe<Scalars['Bytes']>;
  data_gte?: InputMaybe<Scalars['Bytes']>;
  data_in?: InputMaybe<Array<Scalars['Bytes']>>;
  data_lt?: InputMaybe<Scalars['Bytes']>;
  data_lte?: InputMaybe<Scalars['Bytes']>;
  data_not?: InputMaybe<Scalars['Bytes']>;
  data_not_contains?: InputMaybe<Scalars['Bytes']>;
  data_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  operator?: InputMaybe<Scalars['Bytes']>;
  operatorData?: InputMaybe<Scalars['Bytes']>;
  operatorData_contains?: InputMaybe<Scalars['Bytes']>;
  operatorData_gt?: InputMaybe<Scalars['Bytes']>;
  operatorData_gte?: InputMaybe<Scalars['Bytes']>;
  operatorData_in?: InputMaybe<Array<Scalars['Bytes']>>;
  operatorData_lt?: InputMaybe<Scalars['Bytes']>;
  operatorData_lte?: InputMaybe<Scalars['Bytes']>;
  operatorData_not?: InputMaybe<Scalars['Bytes']>;
  operatorData_not_contains?: InputMaybe<Scalars['Bytes']>;
  operatorData_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  operator_contains?: InputMaybe<Scalars['Bytes']>;
  operator_gt?: InputMaybe<Scalars['Bytes']>;
  operator_gte?: InputMaybe<Scalars['Bytes']>;
  operator_in?: InputMaybe<Array<Scalars['Bytes']>>;
  operator_lt?: InputMaybe<Scalars['Bytes']>;
  operator_lte?: InputMaybe<Scalars['Bytes']>;
  operator_not?: InputMaybe<Scalars['Bytes']>;
  operator_not_contains?: InputMaybe<Scalars['Bytes']>;
  operator_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  or?: InputMaybe<Array<InputMaybe<MintedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  to?: InputMaybe<Scalars['Bytes']>;
  to_contains?: InputMaybe<Scalars['Bytes']>;
  to_gt?: InputMaybe<Scalars['Bytes']>;
  to_gte?: InputMaybe<Scalars['Bytes']>;
  to_in?: InputMaybe<Array<Scalars['Bytes']>>;
  to_lt?: InputMaybe<Scalars['Bytes']>;
  to_lte?: InputMaybe<Scalars['Bytes']>;
  to_not?: InputMaybe<Scalars['Bytes']>;
  to_not_contains?: InputMaybe<Scalars['Bytes']>;
  to_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum MintedEvent_OrderBy {
  Addresses = 'addresses',
  Amount = 'amount',
  BlockNumber = 'blockNumber',
  Data = 'data',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Operator = 'operator',
  OperatorData = 'operatorData',
  Order = 'order',
  Timestamp = 'timestamp',
  To = 'to',
  Token = 'token',
  TransactionHash = 'transactionHash'
}

/** The social mirror */
export type Mirror = {
  __typename?: 'Mirror';
  /** ID of the source */
  appId?: Maybe<Scalars['Sources']>;
  bookmarked: Scalars['Boolean'];
  canComment: CanCommentResponse;
  canDecrypt: CanDecryptResponse;
  canMirror: CanMirrorResponse;
  /** The collect module */
  collectModule: CollectModule;
  /** The contract address for the collect nft.. if its null it means nobody collected yet as it lazy deployed */
  collectNftAddress?: Maybe<Scalars['ContractAddress']>;
  /** The date the post was created on */
  createdAt: Scalars['DateTime'];
  /** The data availability proofs you can fetch from */
  dataAvailabilityProofs?: Maybe<Scalars['String']>;
  hasCollectedByMe: Scalars['Boolean'];
  /** If the publication has been hidden if it has then the content and media is not available */
  hidden: Scalars['Boolean'];
  /** The internal publication id */
  id: Scalars['InternalPublicationId'];
  /** Indicates if the publication is data availability post */
  isDataAvailability: Scalars['Boolean'];
  /** Indicates if the publication is gated behind some access criteria */
  isGated: Scalars['Boolean'];
  /** The metadata for the post */
  metadata: MetadataOutput;
  /** The mirror publication */
  mirrorOf: MirrorablePublication;
  notInterested: Scalars['Boolean'];
  /** The on chain content uri could be `ipfs://` or `https` */
  onChainContentURI: Scalars['String'];
  /** The profile ref */
  profile: Profile;
  reaction?: Maybe<ReactionTypes>;
  /** The reference module */
  referenceModule?: Maybe<ReferenceModule>;
  /** The publication stats */
  stats: PublicationStats;
};


/** The social mirror */
export type MirrorBookmarkedArgs = {
  by?: InputMaybe<Scalars['ProfileId']>;
};


/** The social mirror */
export type MirrorCanCommentArgs = {
  profileId?: InputMaybe<Scalars['ProfileId']>;
};


/** The social mirror */
export type MirrorCanDecryptArgs = {
  address?: InputMaybe<Scalars['EthereumAddress']>;
  profileId?: InputMaybe<Scalars['ProfileId']>;
};


/** The social mirror */
export type MirrorCanMirrorArgs = {
  profileId?: InputMaybe<Scalars['ProfileId']>;
};


/** The social mirror */
export type MirrorHasCollectedByMeArgs = {
  isFinalisedOnChain?: InputMaybe<Scalars['Boolean']>;
};


/** The social mirror */
export type MirrorNotInterestedArgs = {
  by?: InputMaybe<Scalars['ProfileId']>;
};


/** The social mirror */
export type MirrorReactionArgs = {
  request?: InputMaybe<ReactionFieldResolverRequest>;
};

export type MirrorEvent = {
  __typename?: 'MirrorEvent';
  profile: Profile;
  timestamp: Scalars['DateTime'];
};

export type MirrorablePublication = Comment | Post;

export type ModuleFee = {
  __typename?: 'ModuleFee';
  /** The fee amount */
  amount: ModuleFeeAmount;
  /** The fee recipient */
  recipient: Scalars['EthereumAddress'];
  /** The referral fee */
  referralFee: Scalars['Float'];
};

export type ModuleFeeAmount = {
  __typename?: 'ModuleFeeAmount';
  /** The erc20 token info */
  asset: Erc20;
  /** Floating point number as string (e.g. 42.009837). It could have the entire precision of the Asset or be truncated to the last significant decimal. */
  value: Scalars['String'];
};

export type ModuleFeeAmountParams = {
  /** The currency address */
  currency: Scalars['ContractAddress'];
  /** Floating point number as string (e.g. 42.009837). It could have the entire precision of the Asset or be truncated to the last significant decimal. */
  value: Scalars['String'];
};

export type ModuleFeeParams = {
  /** The fee amount */
  amount: ModuleFeeAmountParams;
  /** The fee recipient */
  recipient: Scalars['EthereumAddress'];
  /** The referral fee */
  referralFee: Scalars['Float'];
};

export type ModuleInfo = {
  __typename?: 'ModuleInfo';
  name: Scalars['String'];
  type: Scalars['String'];
};

/** The momka validator error */
export enum MomokaValidatorError {
  BlockCantBeReadFromNode = 'BLOCK_CANT_BE_READ_FROM_NODE',
  BlockTooFar = 'BLOCK_TOO_FAR',
  CanNotConnectToBundlr = 'CAN_NOT_CONNECT_TO_BUNDLR',
  ChainSignatureAlreadyUsed = 'CHAIN_SIGNATURE_ALREADY_USED',
  DataCantBeReadFromNode = 'DATA_CANT_BE_READ_FROM_NODE',
  EventMismatch = 'EVENT_MISMATCH',
  GeneratedPublicationIdMismatch = 'GENERATED_PUBLICATION_ID_MISMATCH',
  InvalidEventTimestamp = 'INVALID_EVENT_TIMESTAMP',
  InvalidFormattedTypedData = 'INVALID_FORMATTED_TYPED_DATA',
  InvalidPointerSetNotNeeded = 'INVALID_POINTER_SET_NOT_NEEDED',
  InvalidSignatureSubmitter = 'INVALID_SIGNATURE_SUBMITTER',
  InvalidTxId = 'INVALID_TX_ID',
  InvalidTypedDataDeadlineTimestamp = 'INVALID_TYPED_DATA_DEADLINE_TIMESTAMP',
  NotClosestBlock = 'NOT_CLOSEST_BLOCK',
  NoSignatureSubmitter = 'NO_SIGNATURE_SUBMITTER',
  PointerFailedVerification = 'POINTER_FAILED_VERIFICATION',
  PotentialReorg = 'POTENTIAL_REORG',
  PublicationNonceInvalid = 'PUBLICATION_NONCE_INVALID',
  PublicationNoneDa = 'PUBLICATION_NONE_DA',
  PublicationNoPointer = 'PUBLICATION_NO_POINTER',
  PublicationSignerNotAllowed = 'PUBLICATION_SIGNER_NOT_ALLOWED',
  SimulationFailed = 'SIMULATION_FAILED',
  SimulationNodeCouldNotRun = 'SIMULATION_NODE_COULD_NOT_RUN',
  TimestampProofInvalidDaId = 'TIMESTAMP_PROOF_INVALID_DA_ID',
  TimestampProofInvalidSignature = 'TIMESTAMP_PROOF_INVALID_SIGNATURE',
  TimestampProofInvalidType = 'TIMESTAMP_PROOF_INVALID_TYPE',
  TimestampProofNotSubmitter = 'TIMESTAMP_PROOF_NOT_SUBMITTER',
  Unknown = 'UNKNOWN'
}

export type MultirecipientFeeCollectModuleParams = {
  /** The collecting cost associated with this publication. 0 for free collect. */
  amount: ModuleFeeAmountParams;
  /** The maximum number of collects for this publication. Omit for no limit. */
  collectLimit?: InputMaybe<Scalars['String']>;
  /** The end timestamp after which collecting is impossible. Omit for no expiry. */
  endTimestamp?: InputMaybe<Scalars['DateTime']>;
  /** True if only followers of publisher may collect the post. */
  followerOnly: Scalars['Boolean'];
  /** Recipient of collect fees. */
  recipients: Array<RecipientDataInput>;
  /** The referral fee associated with this publication. */
  referralFee?: InputMaybe<Scalars['Float']>;
};

export type MultirecipientFeeCollectModuleSettings = {
  __typename?: 'MultirecipientFeeCollectModuleSettings';
  /** The collect module amount info */
  amount: ModuleFeeAmount;
  /** The maximum number of collects for this publication. 0 for no limit. */
  collectLimit?: Maybe<Scalars['String']>;
  contractAddress: Scalars['ContractAddress'];
  /** The end timestamp after which collecting is impossible. 0 for no expiry. */
  endTimestamp?: Maybe<Scalars['DateTime']>;
  /** True if only followers of publisher may collect the post. */
  followerOnly: Scalars['Boolean'];
  /** Recipient of collect fees. */
  recipients: Array<RecipientDataOutput>;
  /** The referral fee associated with this publication. */
  referralFee: Scalars['Float'];
  /** The collect modules enum */
  type: CollectModules;
};

export type Mutation = {
  __typename?: 'Mutation';
  ach?: Maybe<Scalars['Void']>;
  /** Adds profile interests to the given profile */
  addProfileInterests?: Maybe<Scalars['Void']>;
  addPublicationProfileBookmark?: Maybe<Scalars['Void']>;
  addPublicationProfileNotInterested?: Maybe<Scalars['Void']>;
  addReaction?: Maybe<Scalars['Void']>;
  authenticate: AuthenticationResult;
  broadcast: RelayResult;
  broadcastDataAvailability: BroadcastDataAvailabilityUnion;
  claim: RelayResult;
  createAttachMediaData: PublicMediaResults;
  createBurnProfileTypedData: CreateBurnProfileBroadcastItemResult;
  createCollectTypedData: CreateCollectBroadcastItemResult;
  createCommentTypedData: CreateCommentBroadcastItemResult;
  createCommentViaDispatcher: RelayResult;
  createDataAvailabilityCommentTypedData: CreateCommentBroadcastItemResult;
  createDataAvailabilityCommentViaDispatcher: RelayDataAvailabilityResult;
  createDataAvailabilityMirrorTypedData: CreateMirrorBroadcastItemResult;
  createDataAvailabilityMirrorViaDispatcher: RelayDataAvailabilityResult;
  createDataAvailabilityPostTypedData: CreatePostBroadcastItemResult;
  createDataAvailabilityPostViaDispatcher: RelayDataAvailabilityResult;
  createFollowTypedData: CreateFollowBroadcastItemResult;
  createMirrorTypedData: CreateMirrorBroadcastItemResult;
  createMirrorViaDispatcher: RelayResult;
  /** Create a new NFT gallery */
  createNftGallery: Scalars['NftGalleryId'];
  createPostTypedData: CreatePostBroadcastItemResult;
  createPostViaDispatcher: RelayResult;
  createProfile: RelayResult;
  createSetDefaultProfileTypedData: SetDefaultProfileBroadcastItemResult;
  createSetDispatcherTypedData: CreateSetDispatcherBroadcastItemResult;
  createSetFollowModuleTypedData: CreateSetFollowModuleBroadcastItemResult;
  createSetFollowNFTUriTypedData: CreateSetFollowNftUriBroadcastItemResult;
  createSetFollowNFTUriViaDispatcher: RelayResult;
  createSetProfileImageURITypedData: CreateSetProfileImageUriBroadcastItemResult;
  createSetProfileImageURIViaDispatcher: RelayResult;
  createSetProfileMetadataTypedData: CreateSetProfileMetadataUriBroadcastItemResult;
  createSetProfileMetadataViaDispatcher: RelayResult;
  createToggleFollowTypedData: CreateToggleFollowBroadcastItemResult;
  createUnfollowTypedData: CreateUnfollowBroadcastItemResult;
  /** Delete an NFT Gallery */
  deleteNftGallery?: Maybe<Scalars['Void']>;
  dismissRecommendedProfiles?: Maybe<Scalars['Void']>;
  dss?: Maybe<Scalars['Void']>;
  gci?: Maybe<Scalars['Void']>;
  gcr?: Maybe<Scalars['Void']>;
  gdi?: Maybe<Scalars['Void']>;
  hel?: Maybe<Scalars['Void']>;
  hidePublication?: Maybe<Scalars['Void']>;
  idKitPhoneVerifyWebhook: IdKitPhoneVerifyWebhookResultStatusType;
  in?: Maybe<Scalars['Void']>;
  invite?: Maybe<Scalars['Void']>;
  nni?: Maybe<Scalars['Void']>;
  nnv?: Maybe<Scalars['Void']>;
  proxyAction: Scalars['ProxyActionId'];
  refresh: AuthenticationResult;
  /** Removes profile interests from the given profile */
  removeProfileInterests?: Maybe<Scalars['Void']>;
  removePublicationProfileBookmark?: Maybe<Scalars['Void']>;
  removePublicationProfileNotInterested?: Maybe<Scalars['Void']>;
  removeReaction?: Maybe<Scalars['Void']>;
  reportPublication?: Maybe<Scalars['Void']>;
  /** Update the name of an NFT gallery */
  updateNftGalleryInfo?: Maybe<Scalars['Void']>;
  /** Add and/or remove NFTs to a gallery */
  updateNftGalleryItems?: Maybe<Scalars['Void']>;
  /** Update the order of NFTs in a gallery */
  updateNftGalleryOrder?: Maybe<Scalars['Void']>;
};


export type MutationAchArgs = {
  request: AchRequest;
};


export type MutationAddProfileInterestsArgs = {
  request: AddProfileInterestsRequest;
};


export type MutationAddPublicationProfileBookmarkArgs = {
  request: PublicationProfileBookmarkRequest;
};


export type MutationAddPublicationProfileNotInterestedArgs = {
  request: PublicationProfileNotInterestedRequest;
};


export type MutationAddReactionArgs = {
  request: ReactionRequest;
};


export type MutationAuthenticateArgs = {
  request: SignedAuthChallenge;
};


export type MutationBroadcastArgs = {
  request: BroadcastRequest;
};


export type MutationBroadcastDataAvailabilityArgs = {
  request: BroadcastRequest;
};


export type MutationClaimArgs = {
  request: ClaimHandleRequest;
};


export type MutationCreateAttachMediaDataArgs = {
  request: PublicMediaRequest;
};


export type MutationCreateBurnProfileTypedDataArgs = {
  options?: InputMaybe<TypedDataOptions>;
  request: BurnProfileRequest;
};


export type MutationCreateCollectTypedDataArgs = {
  options?: InputMaybe<TypedDataOptions>;
  request: CreateCollectRequest;
};


export type MutationCreateCommentTypedDataArgs = {
  options?: InputMaybe<TypedDataOptions>;
  request: CreatePublicCommentRequest;
};


export type MutationCreateCommentViaDispatcherArgs = {
  request: CreatePublicCommentRequest;
};


export type MutationCreateDataAvailabilityCommentTypedDataArgs = {
  request: CreateDataAvailabilityCommentRequest;
};


export type MutationCreateDataAvailabilityCommentViaDispatcherArgs = {
  request: CreateDataAvailabilityCommentRequest;
};


export type MutationCreateDataAvailabilityMirrorTypedDataArgs = {
  request: CreateDataAvailabilityMirrorRequest;
};


export type MutationCreateDataAvailabilityMirrorViaDispatcherArgs = {
  request: CreateDataAvailabilityMirrorRequest;
};


export type MutationCreateDataAvailabilityPostTypedDataArgs = {
  request: CreateDataAvailabilityPostRequest;
};


export type MutationCreateDataAvailabilityPostViaDispatcherArgs = {
  request: CreateDataAvailabilityPostRequest;
};


export type MutationCreateFollowTypedDataArgs = {
  options?: InputMaybe<TypedDataOptions>;
  request: FollowRequest;
};


export type MutationCreateMirrorTypedDataArgs = {
  options?: InputMaybe<TypedDataOptions>;
  request: CreateMirrorRequest;
};


export type MutationCreateMirrorViaDispatcherArgs = {
  request: CreateMirrorRequest;
};


export type MutationCreateNftGalleryArgs = {
  request: NftGalleryCreateRequest;
};


export type MutationCreatePostTypedDataArgs = {
  options?: InputMaybe<TypedDataOptions>;
  request: CreatePublicPostRequest;
};


export type MutationCreatePostViaDispatcherArgs = {
  request: CreatePublicPostRequest;
};


export type MutationCreateProfileArgs = {
  request: CreateProfileRequest;
};


export type MutationCreateSetDefaultProfileTypedDataArgs = {
  options?: InputMaybe<TypedDataOptions>;
  request: CreateSetDefaultProfileRequest;
};


export type MutationCreateSetDispatcherTypedDataArgs = {
  options?: InputMaybe<TypedDataOptions>;
  request: SetDispatcherRequest;
};


export type MutationCreateSetFollowModuleTypedDataArgs = {
  options?: InputMaybe<TypedDataOptions>;
  request: CreateSetFollowModuleRequest;
};


export type MutationCreateSetFollowNftUriTypedDataArgs = {
  options?: InputMaybe<TypedDataOptions>;
  request: CreateSetFollowNftUriRequest;
};


export type MutationCreateSetFollowNftUriViaDispatcherArgs = {
  request: CreateSetFollowNftUriRequest;
};


export type MutationCreateSetProfileImageUriTypedDataArgs = {
  options?: InputMaybe<TypedDataOptions>;
  request: UpdateProfileImageRequest;
};


export type MutationCreateSetProfileImageUriViaDispatcherArgs = {
  request: UpdateProfileImageRequest;
};


export type MutationCreateSetProfileMetadataTypedDataArgs = {
  options?: InputMaybe<TypedDataOptions>;
  request: CreatePublicSetProfileMetadataUriRequest;
};


export type MutationCreateSetProfileMetadataViaDispatcherArgs = {
  request: CreatePublicSetProfileMetadataUriRequest;
};


export type MutationCreateToggleFollowTypedDataArgs = {
  options?: InputMaybe<TypedDataOptions>;
  request: CreateToggleFollowRequest;
};


export type MutationCreateUnfollowTypedDataArgs = {
  options?: InputMaybe<TypedDataOptions>;
  request: UnfollowRequest;
};


export type MutationDeleteNftGalleryArgs = {
  request: NftGalleryDeleteRequest;
};


export type MutationDismissRecommendedProfilesArgs = {
  request: DismissRecommendedProfilesRequest;
};


export type MutationDssArgs = {
  request: PrfRequest;
};


export type MutationGciArgs = {
  request: GciRequest;
};


export type MutationGcrArgs = {
  request: GcrRequest;
};


export type MutationGdiArgs = {
  request: GddRequest;
};


export type MutationHelArgs = {
  request: HelRequest;
};


export type MutationHidePublicationArgs = {
  request: HidePublicationRequest;
};


export type MutationIdKitPhoneVerifyWebhookArgs = {
  request: IdKitPhoneVerifyWebhookRequest;
};


export type MutationInArgs = {
  request: InRequest;
};


export type MutationInviteArgs = {
  request: InviteRequest;
};


export type MutationNniArgs = {
  request: NniRequest;
};


export type MutationNnvArgs = {
  request: NnvRequest;
};


export type MutationProxyActionArgs = {
  request: ProxyActionRequest;
};


export type MutationRefreshArgs = {
  request: RefreshRequest;
};


export type MutationRemoveProfileInterestsArgs = {
  request: RemoveProfileInterestsRequest;
};


export type MutationRemovePublicationProfileBookmarkArgs = {
  request: PublicationProfileBookmarkRequest;
};


export type MutationRemovePublicationProfileNotInterestedArgs = {
  request: PublicationProfileNotInterestedRequest;
};


export type MutationRemoveReactionArgs = {
  request: ReactionRequest;
};


export type MutationReportPublicationArgs = {
  request: ReportPublicationRequest;
};


export type MutationUpdateNftGalleryInfoArgs = {
  request: NftGalleryUpdateInfoRequest;
};


export type MutationUpdateNftGalleryItemsArgs = {
  request: NftGalleryUpdateItemsRequest;
};


export type MutationUpdateNftGalleryOrderArgs = {
  request: NftGalleryUpdateItemOrderRequest;
};

export type MutualFollowersProfilesQueryRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  /** The profile id your viewing */
  viewingProfileId: Scalars['ProfileId'];
  /** The profile id you want the result to come back as your viewing from */
  yourProfileId: Scalars['ProfileId'];
};

/** The nft type */
export type Nft = {
  __typename?: 'NFT';
  /** aka "1"  */
  chainId: Scalars['ChainId'];
  /** aka "CryptoKitties"  */
  collectionName: Scalars['String'];
  /** aka "https://api.criptokitt..."  */
  contentURI: Scalars['String'];
  /** aka 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e  */
  contractAddress: Scalars['ContractAddress'];
  /** aka us CryptoKitties */
  contractName: Scalars['String'];
  /** aka "Hey cutie! I m Beard Coffee. ....  */
  description: Scalars['String'];
  /** aka "ERC721"  */
  ercType: Scalars['String'];
  /** aka "Beard Coffee"  */
  name: Scalars['String'];
  /** aka "{ uri:"https://ipfs....", metaType:"image/png" }"  */
  originalContent: NftContent;
  /** aka { address: 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e, amount:"2" }  */
  owners: Array<Owner>;
  /** aka RARI */
  symbol: Scalars['String'];
  /** aka "13"  */
  tokenId: Scalars['String'];
};

/** The NFT content uri */
export type NftContent = {
  __typename?: 'NFTContent';
  /** The animated url */
  animatedUrl?: Maybe<Scalars['String']>;
  /** The meta type content */
  metaType: Scalars['String'];
  /** The token uri  nft */
  uri: Scalars['String'];
};

export type NftData = {
  /** Id of the nft ownership challenge */
  id: Scalars['NftOwnershipId'];
  /** The signature */
  signature: Scalars['Signature'];
};

/** NFT search query */
export type NftSearchRequest = {
  /** Chain IDs to search. Supports Ethereum and Polygon. If omitted, it will search in both chains */
  chainIds?: InputMaybe<Array<Scalars['ChainId']>>;
  cursor?: InputMaybe<Scalars['Cursor']>;
  /** Exclude follower NFTs from the search */
  excludeFollowers?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  /** Ethereum address of the owner. If unknown you can also search by profile ID */
  ownerAddress?: InputMaybe<Scalars['EthereumAddress']>;
  /** Profile ID of the owner */
  profileId?: InputMaybe<Scalars['ProfileId']>;
  /** Search query. Has to be part of a collection name */
  query: Scalars['String'];
};

export type NfTsRequest = {
  /** Chain Ids */
  chainIds?: InputMaybe<Array<Scalars['ChainId']>>;
  /** Filter by contract address */
  contractAddress?: InputMaybe<Scalars['ContractAddress']>;
  cursor?: InputMaybe<Scalars['Cursor']>;
  /** Exclude filtered collection addresses from the search. Cannot be used together ith `includeCollections` */
  excludeCollections?: InputMaybe<Array<NftCollectionInput>>;
  /** Exclude follower NFTs from the search. */
  excludeFollowers?: InputMaybe<Scalars['Boolean']>;
  /** Include only filtered collection addresses in the search. Overrides `contractAddress` */
  includeCollections?: InputMaybe<Array<NftCollectionInput>>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  /** Filter by owner address */
  ownerAddress: Scalars['EthereumAddress'];
};

/** Paginated nft results */
export type NfTsResult = {
  __typename?: 'NFTsResult';
  items: Array<Nft>;
  pageInfo: PaginatedResultInfo;
};

export type NewCollectNotification = {
  __typename?: 'NewCollectNotification';
  collectedPublication: Publication;
  createdAt: Scalars['DateTime'];
  notificationId: Scalars['NotificationId'];
  wallet: Wallet;
};

export type NewCommentNotification = {
  __typename?: 'NewCommentNotification';
  comment: Comment;
  createdAt: Scalars['DateTime'];
  notificationId: Scalars['NotificationId'];
  /** The profile */
  profile: Profile;
};

export type NewFollowerNotification = {
  __typename?: 'NewFollowerNotification';
  createdAt: Scalars['DateTime'];
  isFollowedByMe: Scalars['Boolean'];
  notificationId: Scalars['NotificationId'];
  wallet: Wallet;
};

export type NewMentionNotification = {
  __typename?: 'NewMentionNotification';
  createdAt: Scalars['DateTime'];
  mentionPublication: MentionPublication;
  notificationId: Scalars['NotificationId'];
};

export type NewMirrorNotification = {
  __typename?: 'NewMirrorNotification';
  createdAt: Scalars['DateTime'];
  notificationId: Scalars['NotificationId'];
  /** The profile */
  profile: Profile;
  publication: MirrorablePublication;
};

export type NewPicEvent = Event & {
  __typename?: 'NewPICEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `pic` (new Patrician In Charge)
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  /**
   * The bond the new PIC staked in order to claim the position.
   *
   */
  bond: Scalars['BigInt'];
  /**
   * The flowrate at which the bond is streamed back to the PIC.
   *
   */
  exitRate: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  /**
   * The address of the new Patrician In Charge (PIC).
   *
   */
  pic: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  /**
   * The address of the `token` (supertoken) the PIC is posting a bond for.
   *
   */
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
};

export type NewPicEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<NewPicEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  bond?: InputMaybe<Scalars['BigInt']>;
  bond_gt?: InputMaybe<Scalars['BigInt']>;
  bond_gte?: InputMaybe<Scalars['BigInt']>;
  bond_in?: InputMaybe<Array<Scalars['BigInt']>>;
  bond_lt?: InputMaybe<Scalars['BigInt']>;
  bond_lte?: InputMaybe<Scalars['BigInt']>;
  bond_not?: InputMaybe<Scalars['BigInt']>;
  bond_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  exitRate?: InputMaybe<Scalars['BigInt']>;
  exitRate_gt?: InputMaybe<Scalars['BigInt']>;
  exitRate_gte?: InputMaybe<Scalars['BigInt']>;
  exitRate_in?: InputMaybe<Array<Scalars['BigInt']>>;
  exitRate_lt?: InputMaybe<Scalars['BigInt']>;
  exitRate_lte?: InputMaybe<Scalars['BigInt']>;
  exitRate_not?: InputMaybe<Scalars['BigInt']>;
  exitRate_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<NewPicEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  pic?: InputMaybe<Scalars['Bytes']>;
  pic_contains?: InputMaybe<Scalars['Bytes']>;
  pic_gt?: InputMaybe<Scalars['Bytes']>;
  pic_gte?: InputMaybe<Scalars['Bytes']>;
  pic_in?: InputMaybe<Array<Scalars['Bytes']>>;
  pic_lt?: InputMaybe<Scalars['Bytes']>;
  pic_lte?: InputMaybe<Scalars['Bytes']>;
  pic_not?: InputMaybe<Scalars['Bytes']>;
  pic_not_contains?: InputMaybe<Scalars['Bytes']>;
  pic_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum NewPicEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  Bond = 'bond',
  ExitRate = 'exitRate',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Pic = 'pic',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash'
}

export type NewReactionNotification = {
  __typename?: 'NewReactionNotification';
  createdAt: Scalars['DateTime'];
  notificationId: Scalars['NotificationId'];
  /** The profile */
  profile: Profile;
  publication: Publication;
  reaction: ReactionTypes;
};

export type Nfi = {
  c: Scalars['ContractAddress'];
  i: Scalars['ChainId'];
};

/** NFT collection filtering input */
export type NftCollectionInput = {
  /** The chain id that the collection exists in */
  chainId: Scalars['ChainId'];
  /** Filter by NFT collection contract address */
  contractAddress: Scalars['ContractAddress'];
};

/** The NFT gallery input */
export type NftGalleriesRequest = {
  /** The profile id */
  profileId: Scalars['ProfileId'];
};

/** The NFT gallery */
export type NftGallery = {
  __typename?: 'NftGallery';
  /** The creation date */
  createdAt: Scalars['DateTime'];
  /** The NFT gallery id */
  id: Scalars['NftGalleryId'];
  /** The NFTs in the gallery */
  items: Array<Nft>;
  /** The NFT gallery name */
  name: Scalars['String'];
  /** The owning profile id */
  profileId: Scalars['ProfileId'];
  /** The last update date */
  updatedAt: Scalars['DateTime'];
};

/** The input for creating a new NFT gallery */
export type NftGalleryCreateRequest = {
  /** The NFTs in the gallery */
  items: Array<NftInput>;
  /** The name of the NFT gallery */
  name: Scalars['NftGalleryName'];
  /** The owner profile id */
  profileId: Scalars['ProfileId'];
};

/** The input for deleting gallery */
export type NftGalleryDeleteRequest = {
  /** The NFT gallery id */
  galleryId: Scalars['NftGalleryId'];
  /** The profile id of the gallery owner */
  profileId: Scalars['ProfileId'];
};

/** The input for updating NFT gallery name */
export type NftGalleryUpdateInfoRequest = {
  /** The NFT gallery id */
  galleryId: Scalars['NftGalleryId'];
  /** The name of the NFT gallery */
  name: Scalars['NftGalleryName'];
  /** The profile id of the gallery owner */
  profileId: Scalars['ProfileId'];
};

/** The input for reordering gallery items */
export type NftGalleryUpdateItemOrderRequest = {
  /** The NFT gallery id */
  galleryId: Scalars['NftGalleryId'];
  /** The profile id of the gallery owner */
  profileId: Scalars['ProfileId'];
  /** The order of the NFTs in the gallery */
  updates: Array<NftUpdateItemOrder>;
};

/** The input for adding/removing gallery items */
export type NftGalleryUpdateItemsRequest = {
  /** The NFT gallery id */
  galleryId: Scalars['NftGalleryId'];
  /** The profile id of the gallery owner */
  profileId: Scalars['ProfileId'];
  /** The contents of the NFT gallery */
  toAdd?: InputMaybe<Array<NftInput>>;
  /** The contents of the NFT gallery */
  toRemove?: InputMaybe<Array<NftInput>>;
};

/** The NFT image */
export type NftImage = {
  __typename?: 'NftImage';
  /** The token image nft */
  chainId: Scalars['Int'];
  /** The contract address */
  contractAddress: Scalars['ContractAddress'];
  /** The token id of the nft */
  tokenId: Scalars['String'];
  /** The token image nft */
  uri: Scalars['Url'];
  /** If the NFT is verified */
  verified: Scalars['Boolean'];
};

/** The NFT input for gallery */
export type NftInput = {
  /** The chain ID of the NFT */
  chainId: Scalars['ChainId'];
  /** The contract address of the NFT */
  contractAddress: Scalars['ContractAddress'];
  /** The token ID of the NFT */
  tokenId: Scalars['String'];
};

export type NftOwnershipChallenge = {
  /** Chain Id */
  chainId: Scalars['ChainId'];
  /** ContractAddress for nft */
  contractAddress: Scalars['ContractAddress'];
  /** Token id for NFT */
  tokenId: Scalars['String'];
};

export type NftOwnershipChallengeRequest = {
  /** The wallet address which owns the NFT */
  ethereumAddress: Scalars['EthereumAddress'];
  nfts: Array<NftOwnershipChallenge>;
};

/** NFT ownership challenge result */
export type NftOwnershipChallengeResult = {
  __typename?: 'NftOwnershipChallengeResult';
  /** Id of the nft ownership challenge */
  id: Scalars['NftOwnershipId'];
  text: Scalars['String'];
  /** Timeout of the validation */
  timeout: Scalars['TimestampScalar'];
};

export type NftOwnershipInput = {
  /** The NFT chain id */
  chainID: Scalars['ChainId'];
  /** The NFT collection's ethereum address */
  contractAddress: Scalars['ContractAddress'];
  /** The unlocker contract type */
  contractType: ContractType;
  /** The optional token ID(s) to check for ownership */
  tokenIds?: InputMaybe<Array<Scalars['TokenId']>>;
};

export type NftOwnershipOutput = {
  __typename?: 'NftOwnershipOutput';
  /** The NFT chain id */
  chainID: Scalars['ChainId'];
  /** The NFT collection's ethereum address */
  contractAddress: Scalars['ContractAddress'];
  /** The unlocker contract type */
  contractType: ContractType;
  /** The optional token ID(s) to check for ownership */
  tokenIds?: Maybe<Array<Scalars['TokenId']>>;
};

/** The input for updating the order of a NFT gallery item */
export type NftUpdateItemOrder = {
  /** The chain ID of the NFT */
  chainId: Scalars['ChainId'];
  /** The contract address of the NFT */
  contractAddress: Scalars['ContractAddress'];
  /** The new order of the NFT in the gallery */
  newOrder: Scalars['Int'];
  /** The token ID of the NFT */
  tokenId: Scalars['String'];
};

export type NniRequest = {
  n: Array<Nfi>;
  secret: Scalars['String'];
};

export type NnvRequest = {
  n: Array<Nfi>;
  secret: Scalars['String'];
};

export type Notification = NewCollectNotification | NewCommentNotification | NewFollowerNotification | NewMentionNotification | NewMirrorNotification | NewReactionNotification;

export type NotificationRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  customFilters?: InputMaybe<Array<CustomFiltersTypes>>;
  highSignalFilter?: InputMaybe<Scalars['Boolean']>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  /** The notification types */
  notificationTypes?: InputMaybe<Array<NotificationTypes>>;
  /** The profile id */
  profileId: Scalars['ProfileId'];
  /** The App Id */
  sources?: InputMaybe<Array<Scalars['Sources']>>;
};

/** The notification filter types */
export enum NotificationTypes {
  CollectedComment = 'COLLECTED_COMMENT',
  CollectedPost = 'COLLECTED_POST',
  CommentedComment = 'COMMENTED_COMMENT',
  CommentedPost = 'COMMENTED_POST',
  Followed = 'FOLLOWED',
  MentionComment = 'MENTION_COMMENT',
  MentionPost = 'MENTION_POST',
  MirroredComment = 'MIRRORED_COMMENT',
  MirroredPost = 'MIRRORED_POST',
  ReactionComment = 'REACTION_COMMENT',
  ReactionPost = 'REACTION_POST'
}

export type OnChainIdentity = {
  __typename?: 'OnChainIdentity';
  /** The ens information */
  ens?: Maybe<EnsOnChainIdentity>;
  /** The POH status */
  proofOfHumanity: Scalars['Boolean'];
  /** The sybil dot org information */
  sybilDotOrg: SybilDotOrgIdentity;
  /** The worldcoin identity */
  worldcoin: WorldcoinIdentity;
};

export type OrConditionInput = {
  /** The list of conditions to apply OR to. You can only use nested boolean conditions at the root level. */
  criteria: Array<AccessConditionInput>;
};

export type OrConditionOutput = {
  __typename?: 'OrConditionOutput';
  /** The list of conditions to apply OR to. You can only use nested boolean conditions at the root level. */
  criteria: Array<AccessConditionOutput>;
};

/** Defines the order direction, either ascending or descending */
export enum OrderDirection {
  Asc = 'asc',
  Desc = 'desc'
}

/** The nft type */
export type Owner = {
  __typename?: 'Owner';
  /** aka 0x057Ec652A4F150f7FF94f089A38008f49a0DF88e  */
  address: Scalars['EthereumAddress'];
  /** number of tokens owner */
  amount: Scalars['Float'];
};

export type PppConfigurationChangedEvent = Event & {
  __typename?: 'PPPConfigurationChangedEvent';
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  /**
   * The address of the governance contract the event was emitted from.
   *
   */
  governanceAddress: Scalars['Bytes'];
  host: Scalars['Bytes'];
  id: Scalars['ID'];
  isKeySet: Scalars['Boolean'];
  liquidationPeriod: Scalars['BigInt'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  patricianPeriod: Scalars['BigInt'];
  superToken: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
};

export type PppConfigurationChangedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<PppConfigurationChangedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  governanceAddress?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_contains?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_gt?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_gte?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_in?: InputMaybe<Array<Scalars['Bytes']>>;
  governanceAddress_lt?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_lte?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not_contains?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  host?: InputMaybe<Scalars['Bytes']>;
  host_contains?: InputMaybe<Scalars['Bytes']>;
  host_gt?: InputMaybe<Scalars['Bytes']>;
  host_gte?: InputMaybe<Scalars['Bytes']>;
  host_in?: InputMaybe<Array<Scalars['Bytes']>>;
  host_lt?: InputMaybe<Scalars['Bytes']>;
  host_lte?: InputMaybe<Scalars['Bytes']>;
  host_not?: InputMaybe<Scalars['Bytes']>;
  host_not_contains?: InputMaybe<Scalars['Bytes']>;
  host_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  isKeySet?: InputMaybe<Scalars['Boolean']>;
  isKeySet_in?: InputMaybe<Array<Scalars['Boolean']>>;
  isKeySet_not?: InputMaybe<Scalars['Boolean']>;
  isKeySet_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  liquidationPeriod?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_gt?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_gte?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_in?: InputMaybe<Array<Scalars['BigInt']>>;
  liquidationPeriod_lt?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_lte?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_not?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<PppConfigurationChangedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  patricianPeriod?: InputMaybe<Scalars['BigInt']>;
  patricianPeriod_gt?: InputMaybe<Scalars['BigInt']>;
  patricianPeriod_gte?: InputMaybe<Scalars['BigInt']>;
  patricianPeriod_in?: InputMaybe<Array<Scalars['BigInt']>>;
  patricianPeriod_lt?: InputMaybe<Scalars['BigInt']>;
  patricianPeriod_lte?: InputMaybe<Scalars['BigInt']>;
  patricianPeriod_not?: InputMaybe<Scalars['BigInt']>;
  patricianPeriod_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  superToken?: InputMaybe<Scalars['Bytes']>;
  superToken_contains?: InputMaybe<Scalars['Bytes']>;
  superToken_gt?: InputMaybe<Scalars['Bytes']>;
  superToken_gte?: InputMaybe<Scalars['Bytes']>;
  superToken_in?: InputMaybe<Array<Scalars['Bytes']>>;
  superToken_lt?: InputMaybe<Scalars['Bytes']>;
  superToken_lte?: InputMaybe<Scalars['Bytes']>;
  superToken_not?: InputMaybe<Scalars['Bytes']>;
  superToken_not_contains?: InputMaybe<Scalars['Bytes']>;
  superToken_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum PppConfigurationChangedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  GovernanceAddress = 'governanceAddress',
  Host = 'host',
  Id = 'id',
  IsKeySet = 'isKeySet',
  LiquidationPeriod = 'liquidationPeriod',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  PatricianPeriod = 'patricianPeriod',
  SuperToken = 'superToken',
  Timestamp = 'timestamp',
  TransactionHash = 'transactionHash'
}

/** The paginated wallet result */
export type PaginatedAllPublicationsTagsResult = {
  __typename?: 'PaginatedAllPublicationsTagsResult';
  items: Array<TagResult>;
  pageInfo: PaginatedResultInfo;
};

/** The paginated feed result */
export type PaginatedFeedResult = {
  __typename?: 'PaginatedFeedResult';
  items: Array<FeedItem>;
  pageInfo: PaginatedResultInfo;
};

/** The paginated followers result */
export type PaginatedFollowersResult = {
  __typename?: 'PaginatedFollowersResult';
  items: Array<Follower>;
  pageInfo: PaginatedResultInfo;
};

export type PaginatedFollowingResult = {
  __typename?: 'PaginatedFollowingResult';
  items: Array<Following>;
  pageInfo: PaginatedResultInfo;
};

/** The paginated for you result */
export type PaginatedForYouResult = {
  __typename?: 'PaginatedForYouResult';
  items: Array<Publication>;
  pageInfo: PaginatedResultInfo;
};

/** The paginated notification result */
export type PaginatedNotificationResult = {
  __typename?: 'PaginatedNotificationResult';
  items: Array<Notification>;
  pageInfo: PaginatedResultInfo;
};

/** The paginated wallet result */
export type PaginatedProfilePublicationsForSaleResult = {
  __typename?: 'PaginatedProfilePublicationsForSaleResult';
  items: Array<PublicationForSale>;
  pageInfo: PaginatedResultInfo;
};

/** The paginated profile result */
export type PaginatedProfileResult = {
  __typename?: 'PaginatedProfileResult';
  items: Array<Profile>;
  pageInfo: PaginatedResultInfo;
};

/** The paginated publication result */
export type PaginatedPublicationResult = {
  __typename?: 'PaginatedPublicationResult';
  items: Array<Publication>;
  pageInfo: PaginatedResultInfo;
};

/** The paginated result info */
export type PaginatedResultInfo = {
  __typename?: 'PaginatedResultInfo';
  /** Cursor to query next results */
  next?: Maybe<Scalars['Cursor']>;
  /** Cursor to query the actual results */
  prev?: Maybe<Scalars['Cursor']>;
  /**
   * The total number of entities the pagination iterates over. If its null then its not been worked out due to it being an expensive query and not really needed for the client. All main counters are in counter tables to allow them to be faster fetching.
   * @deprecated Total counts is expensive and in dynamic nature of queries it slows stuff down. Most the time you do not need this you can just use the `next` property to see if there is more data. This will be removed soon. The only use case anyone is using this right now is on notification query, this should be changed to query the notifications and cache the last notification id. You can then keep checking if the id changes you know more notifications.
   */
  totalCount?: Maybe<Scalars['Int']>;
};

/** The paginated result */
export type PaginatedTimelineResult = {
  __typename?: 'PaginatedTimelineResult';
  items: Array<Publication>;
  pageInfo: PaginatedResultInfo;
};

/** The paginated wallet result */
export type PaginatedWhoCollectedResult = {
  __typename?: 'PaginatedWhoCollectedResult';
  items: Array<Wallet>;
  pageInfo: PaginatedResultInfo;
};

export type PaginatedWhoReactedResult = {
  __typename?: 'PaginatedWhoReactedResult';
  items: Array<WhoReactedResult>;
  pageInfo: PaginatedResultInfo;
};

export type PendingApprovalFollowsRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
};

/** The paginated follow result */
export type PendingApproveFollowsResult = {
  __typename?: 'PendingApproveFollowsResult';
  items: Array<Profile>;
  pageInfo: PaginatedResultInfo;
};

/** The social post */
export type Post = {
  __typename?: 'Post';
  /** ID of the source */
  appId?: Maybe<Scalars['Sources']>;
  bookmarked: Scalars['Boolean'];
  canComment: CanCommentResponse;
  canDecrypt: CanDecryptResponse;
  canMirror: CanMirrorResponse;
  /** The collect module */
  collectModule: CollectModule;
  /** The contract address for the collect nft.. if its null it means nobody collected yet as it lazy deployed */
  collectNftAddress?: Maybe<Scalars['ContractAddress']>;
  /**
   * Who collected it, this is used for timeline results and like this for better caching for the client
   * @deprecated use `feed` query, timeline query will be killed on the 15th November. This includes this field.
   */
  collectedBy?: Maybe<Wallet>;
  /** The date the post was created on */
  createdAt: Scalars['DateTime'];
  /** The data availability proofs you can fetch from */
  dataAvailabilityProofs?: Maybe<Scalars['String']>;
  hasCollectedByMe: Scalars['Boolean'];
  /** If the publication has been hidden if it has then the content and media is not available */
  hidden: Scalars['Boolean'];
  /** The internal publication id */
  id: Scalars['InternalPublicationId'];
  /** Indicates if the publication is data availability post */
  isDataAvailability: Scalars['Boolean'];
  /** Indicates if the publication is gated behind some access criteria */
  isGated: Scalars['Boolean'];
  /** The metadata for the post */
  metadata: MetadataOutput;
  mirrors: Array<Scalars['InternalPublicationId']>;
  notInterested: Scalars['Boolean'];
  /** The on chain content uri could be `ipfs://` or `https` */
  onChainContentURI: Scalars['String'];
  /** The profile ref */
  profile: Profile;
  reaction?: Maybe<ReactionTypes>;
  /** The reference module */
  referenceModule?: Maybe<ReferenceModule>;
  /** The publication stats */
  stats: PublicationStats;
};


/** The social post */
export type PostBookmarkedArgs = {
  by?: InputMaybe<Scalars['ProfileId']>;
};


/** The social post */
export type PostCanCommentArgs = {
  profileId?: InputMaybe<Scalars['ProfileId']>;
};


/** The social post */
export type PostCanDecryptArgs = {
  address?: InputMaybe<Scalars['EthereumAddress']>;
  profileId?: InputMaybe<Scalars['ProfileId']>;
};


/** The social post */
export type PostCanMirrorArgs = {
  profileId?: InputMaybe<Scalars['ProfileId']>;
};


/** The social post */
export type PostHasCollectedByMeArgs = {
  isFinalisedOnChain?: InputMaybe<Scalars['Boolean']>;
};


/** The social post */
export type PostMirrorsArgs = {
  by?: InputMaybe<Scalars['ProfileId']>;
};


/** The social post */
export type PostNotInterestedArgs = {
  by?: InputMaybe<Scalars['ProfileId']>;
};


/** The social post */
export type PostReactionArgs = {
  request?: InputMaybe<ReactionFieldResolverRequest>;
};

export type PrfRequest = {
  dd: Scalars['Boolean'];
  hhh: Scalars['String'];
  secret: Scalars['String'];
  ss: Scalars['Boolean'];
};

export type PrfResponse = {
  __typename?: 'PrfResponse';
  dd: Scalars['Boolean'];
  ss: Scalars['Boolean'];
};

export type PriRequest = {
  hhh: Scalars['String'];
  secret: Scalars['String'];
};

/** The Profile */
export type Profile = {
  __typename?: 'Profile';
  /** Optionals param to add extra attributes on the metadata */
  attributes?: Maybe<Array<Attribute>>;
  /** Bio of the profile */
  bio?: Maybe<Scalars['String']>;
  /** The cover picture for the profile */
  coverPicture?: Maybe<ProfileMedia>;
  /** The dispatcher */
  dispatcher?: Maybe<Dispatcher>;
  /** The follow module */
  followModule?: Maybe<FollowModule>;
  /** Follow nft address */
  followNftAddress?: Maybe<Scalars['ContractAddress']>;
  /** The profile handle */
  handle: Scalars['Handle'];
  /** The profile id */
  id: Scalars['ProfileId'];
  /** The profile interests */
  interests?: Maybe<Array<Scalars['ProfileInterest']>>;
  invitedBy?: Maybe<Profile>;
  /** Is the profile default */
  isDefault: Scalars['Boolean'];
  isFollowedByMe: Scalars['Boolean'];
  isFollowing: Scalars['Boolean'];
  /** Metadata url */
  metadata?: Maybe<Scalars['Url']>;
  /** Name of the profile */
  name?: Maybe<Scalars['String']>;
  /** The on chain identity */
  onChainIdentity: OnChainIdentity;
  /** Who owns the profile */
  ownedBy: Scalars['EthereumAddress'];
  /** The picture for the profile */
  picture?: Maybe<ProfileMedia>;
  /** Profile stats */
  stats: ProfileStats;
};


/** The Profile */
export type ProfileIsFollowedByMeArgs = {
  isFinalisedOnChain?: InputMaybe<Scalars['Boolean']>;
};


/** The Profile */
export type ProfileIsFollowingArgs = {
  who?: InputMaybe<Scalars['ProfileId']>;
};

export type ProfileFollowModuleBeenRedeemedRequest = {
  followProfileId: Scalars['ProfileId'];
  redeemingProfileId: Scalars['ProfileId'];
};

export type ProfileFollowModuleRedeemParams = {
  /** The profile id to use to follow this profile */
  profileId: Scalars['ProfileId'];
};

export type ProfileFollowModuleSettings = {
  __typename?: 'ProfileFollowModuleSettings';
  contractAddress: Scalars['ContractAddress'];
  /** The follow module enum */
  type: FollowModules;
};

export type ProfileFollowRevenueQueryRequest = {
  /** The profile id */
  profileId: Scalars['ProfileId'];
};

export type ProfileGuardianRequest = {
  profileId: Scalars['ProfileId'];
};

export type ProfileGuardianResult = {
  __typename?: 'ProfileGuardianResult';
  disablingProtectionTimestamp?: Maybe<Scalars['DateTime']>;
  protected: Scalars['Boolean'];
};

export type ProfileMedia = MediaSet | NftImage;

export type ProfileOnChainIdentityRequest = {
  profileIds: Array<Scalars['ProfileId']>;
};

/** Condition that signifies if address has access to profile */
export type ProfileOwnershipInput = {
  /** The profile id */
  profileId: Scalars['ProfileId'];
};

/** Condition that signifies if address has access to profile */
export type ProfileOwnershipOutput = {
  __typename?: 'ProfileOwnershipOutput';
  /** The profile id */
  profileId: Scalars['ProfileId'];
};

export type ProfilePublicationRevenueQueryRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  metadata?: InputMaybe<PublicationMetadataFilters>;
  /** The profile id */
  profileId: Scalars['ProfileId'];
  /** The App Id */
  sources?: InputMaybe<Array<Scalars['Sources']>>;
  /** The revenue types */
  types?: InputMaybe<Array<PublicationTypes>>;
};

/** The paginated revenue result */
export type ProfilePublicationRevenueResult = {
  __typename?: 'ProfilePublicationRevenueResult';
  items: Array<PublicationRevenue>;
  pageInfo: PaginatedResultInfo;
};

export type ProfilePublicationsForSaleRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  metadata?: InputMaybe<PublicationMetadataFilters>;
  /** Profile id */
  profileId: Scalars['ProfileId'];
  /** The App Id */
  sources?: InputMaybe<Array<Scalars['Sources']>>;
};

export type ProfileQueryRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  /** The handles for the profile */
  handles?: InputMaybe<Array<Scalars['Handle']>>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  /** The ethereum addresses */
  ownedBy?: InputMaybe<Array<Scalars['EthereumAddress']>>;
  /** The profile ids */
  profileIds?: InputMaybe<Array<Scalars['ProfileId']>>;
  /** The mirrored publication id */
  whoMirroredPublicationId?: InputMaybe<Scalars['InternalPublicationId']>;
};

/** Profile search results */
export type ProfileSearchResult = {
  __typename?: 'ProfileSearchResult';
  items: Array<Profile>;
  pageInfo: PaginatedResultInfo;
  type: SearchRequestTypes;
};

/** profile sort criteria */
export enum ProfileSortCriteria {
  CreatedOn = 'CREATED_ON',
  LatestCreated = 'LATEST_CREATED',
  MostCollects = 'MOST_COLLECTS',
  MostComments = 'MOST_COMMENTS',
  MostFollowers = 'MOST_FOLLOWERS',
  MostMirrors = 'MOST_MIRRORS',
  MostPosts = 'MOST_POSTS',
  MostPublication = 'MOST_PUBLICATION'
}

/** The Profile Stats */
export type ProfileStats = {
  __typename?: 'ProfileStats';
  commentsTotal: Scalars['Int'];
  id: Scalars['ProfileId'];
  mirrorsTotal: Scalars['Int'];
  postsTotal: Scalars['Int'];
  publicationsTotal: Scalars['Int'];
  /** Total collects count */
  totalCollects: Scalars['Int'];
  /** Total comment count */
  totalComments: Scalars['Int'];
  /** Total follower count */
  totalFollowers: Scalars['Int'];
  /** Total following count (remember the wallet follows not profile so will be same for every profile they own) */
  totalFollowing: Scalars['Int'];
  /** Total mirror count */
  totalMirrors: Scalars['Int'];
  /** Total post count */
  totalPosts: Scalars['Int'];
  /** Total publication count */
  totalPublications: Scalars['Int'];
};


/** The Profile Stats */
export type ProfileStatsCommentsTotalArgs = {
  forSources: Array<Scalars['Sources']>;
};


/** The Profile Stats */
export type ProfileStatsMirrorsTotalArgs = {
  forSources: Array<Scalars['Sources']>;
};


/** The Profile Stats */
export type ProfileStatsPostsTotalArgs = {
  forSources: Array<Scalars['Sources']>;
};


/** The Profile Stats */
export type ProfileStatsPublicationsTotalArgs = {
  forSources: Array<Scalars['Sources']>;
};

/** The provider-specific encryption params */
export type ProviderSpecificParamsOutput = {
  __typename?: 'ProviderSpecificParamsOutput';
  /** The encryption key */
  encryptionKey: Scalars['ContentEncryptionKey'];
};

export type ProxyActionError = {
  __typename?: 'ProxyActionError';
  lastKnownTxId?: Maybe<Scalars['TxId']>;
  reason: Scalars['String'];
};

export type ProxyActionQueued = {
  __typename?: 'ProxyActionQueued';
  queuedAt: Scalars['DateTime'];
};

export type ProxyActionRequest = {
  collect?: InputMaybe<CollectProxyAction>;
  follow?: InputMaybe<FollowProxyAction>;
};

export type ProxyActionStatusResult = {
  __typename?: 'ProxyActionStatusResult';
  status: ProxyActionStatusTypes;
  txHash: Scalars['TxHash'];
  txId: Scalars['TxId'];
};

export type ProxyActionStatusResultUnion = ProxyActionError | ProxyActionQueued | ProxyActionStatusResult;

/** The proxy action status */
export enum ProxyActionStatusTypes {
  Complete = 'COMPLETE',
  Minting = 'MINTING',
  Transferring = 'TRANSFERRING'
}

export type PublicMediaRequest = {
  /** The alt tags for accessibility */
  altTag?: InputMaybe<Scalars['String']>;
  /** The cover for any video or audio you attached */
  cover?: InputMaybe<Scalars['Url']>;
  /** Pre calculated cid of the file to push */
  itemCid: Scalars['IpfsCid'];
  /** This is the mime type of media */
  type?: InputMaybe<Scalars['MimeType']>;
};

/** The response to upload the attached file */
export type PublicMediaResults = {
  __typename?: 'PublicMediaResults';
  /** ipfs uri to add on the metadata */
  media: MediaOutput;
  /** Signed url to push the file */
  signedUrl: Scalars['String'];
};

export type Publication = Comment | Mirror | Post;

/** The publication content warning */
export enum PublicationContentWarning {
  Nsfw = 'NSFW',
  Sensitive = 'SENSITIVE',
  Spoiler = 'SPOILER'
}

export type PublicationForSale = Comment | Post;

export type PublicationForYouRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  for: Scalars['ProfileId'];
  limit?: InputMaybe<Scalars['LimitScalar']>;
};

/** The publication main focus */
export enum PublicationMainFocus {
  Article = 'ARTICLE',
  Audio = 'AUDIO',
  Embed = 'EMBED',
  Image = 'IMAGE',
  Link = 'LINK',
  TextOnly = 'TEXT_ONLY',
  Video = 'VIDEO'
}

/** The source of the media */
export enum PublicationMediaSource {
  Lens = 'LENS'
}

/** Publication metadata content warning filters */
export type PublicationMetadataContentWarningFilter = {
  /** By default all content warnings will be hidden you can include them in your query by adding them to this array. */
  includeOneOf?: InputMaybe<Array<PublicationContentWarning>>;
};

/** The publication metadata display types */
export enum PublicationMetadataDisplayTypes {
  Date = 'date',
  Number = 'number',
  String = 'string'
}

/** Publication metadata filters */
export type PublicationMetadataFilters = {
  contentWarning?: InputMaybe<PublicationMetadataContentWarningFilter>;
  /** IOS 639-1 language code aka en or it and ISO 3166-1 alpha-2 region code aka US or IT aka en-US or it-IT. You can just filter on language if you wish. */
  locale?: InputMaybe<Scalars['Locale']>;
  mainContentFocus?: InputMaybe<Array<PublicationMainFocus>>;
  tags?: InputMaybe<PublicationMetadataTagsFilter>;
};

/** The metadata attribute input */
export type PublicationMetadataMediaInput = {
  /** The alt tags for accessibility */
  altTag?: InputMaybe<Scalars['String']>;
  /** The cover for any video or audio you attached */
  cover?: InputMaybe<Scalars['Url']>;
  item: Scalars['Url'];
  source?: InputMaybe<PublicationMediaSource>;
  /** This is the mime type of media */
  type?: InputMaybe<Scalars['MimeType']>;
};

export type PublicationMetadataStatus = {
  __typename?: 'PublicationMetadataStatus';
  /** If metadata validation failed it will put a reason why here */
  reason?: Maybe<Scalars['String']>;
  status: PublicationMetadataStatusType;
};

/** publication metadata status type */
export enum PublicationMetadataStatusType {
  MetadataValidationFailed = 'METADATA_VALIDATION_FAILED',
  NotFound = 'NOT_FOUND',
  Pending = 'PENDING',
  Success = 'SUCCESS'
}

/** Publication metadata tag filter */
export type PublicationMetadataTagsFilter = {
  /** Needs to match all */
  all?: InputMaybe<Array<Scalars['String']>>;
  /** Needs to only match one of */
  oneOf?: InputMaybe<Array<Scalars['String']>>;
};

export type PublicationMetadataV1Input = {
  /**
   * A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV,
   *       and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
   *       Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas,
   *       WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.
   */
  animation_url?: InputMaybe<Scalars['Url']>;
  /**  This is the appId the content belongs to */
  appId?: InputMaybe<Scalars['Sources']>;
  /**  These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item. */
  attributes: Array<MetadataAttributeInput>;
  /** The content of a publication. If this is blank `media` must be defined or its out of spec */
  content?: InputMaybe<Scalars['Markdown']>;
  /** A human-readable description of the item. */
  description?: InputMaybe<Scalars['Markdown']>;
  /**
   * This is the URL that will appear below the asset's image on OpenSea and others etc
   *       and will allow users to leave OpenSea and view the item on the site.
   */
  external_url?: InputMaybe<Scalars['Url']>;
  /** legacy to support OpenSea will store any NFT image here. */
  image?: InputMaybe<Scalars['Url']>;
  /** This is the mime type of the image. This is used if your uploading more advanced cover images as sometimes ipfs does not emit the content header so this solves that */
  imageMimeType?: InputMaybe<Scalars['MimeType']>;
  /**  This is lens supported attached media items to the publication */
  media?: InputMaybe<Array<PublicationMetadataMediaInput>>;
  /** The metadata id can be anything but if your uploading to ipfs you will want it to be random.. using uuid could be an option! */
  metadata_id: Scalars['String'];
  /** Name of the item. */
  name: Scalars['String'];
  /** Signed metadata to validate the owner */
  signatureContext?: InputMaybe<PublicationSignatureContextInput>;
  /** The metadata version. (1.0.0 | 2.0.0) */
  version: Scalars['String'];
};

export type PublicationMetadataV2Input = {
  /**
   * A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV,
   *       and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
   *       Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas,
   *       WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.
   */
  animation_url?: InputMaybe<Scalars['Url']>;
  /**  This is the appId the content belongs to */
  appId?: InputMaybe<Scalars['Sources']>;
  /**  These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item. */
  attributes: Array<MetadataAttributeInput>;
  /** The content of a publication. If this is blank `media` must be defined or its out of spec */
  content?: InputMaybe<Scalars['Markdown']>;
  /** Ability to add a content warning */
  contentWarning?: InputMaybe<PublicationContentWarning>;
  /** A human-readable description of the item. */
  description?: InputMaybe<Scalars['Markdown']>;
  /**
   * This is the URL that will appear below the asset's image on OpenSea and others etc
   *       and will allow users to leave OpenSea and view the item on the site.
   */
  external_url?: InputMaybe<Scalars['Url']>;
  /** legacy to support OpenSea will store any NFT image here. */
  image?: InputMaybe<Scalars['Url']>;
  /** This is the mime type of the image. This is used if your uploading more advanced cover images as sometimes ipfs does not emit the content header so this solves that */
  imageMimeType?: InputMaybe<Scalars['MimeType']>;
  /** IOS 639-1 language code aka en or it and ISO 3166-1 alpha-2 region code aka US or IT aka en-US or it-IT */
  locale: Scalars['Locale'];
  /** Main content focus that for this publication */
  mainContentFocus: PublicationMainFocus;
  /**  This is lens supported attached media items to the publication */
  media?: InputMaybe<Array<PublicationMetadataMediaInput>>;
  /** The metadata id can be anything but if your uploading to ipfs you will want it to be random.. using uuid could be an option! */
  metadata_id: Scalars['String'];
  /** Name of the item. */
  name: Scalars['String'];
  /** Signed metadata to validate the owner */
  signatureContext?: InputMaybe<PublicationSignatureContextInput>;
  /** Ability to tag your publication */
  tags?: InputMaybe<Array<Scalars['String']>>;
  /** The metadata version. (1.0.0 | 2.0.0) */
  version: Scalars['String'];
};

export type PublicationProfileBookmarkRequest = {
  /** Profile id to perform the action */
  profileId: Scalars['ProfileId'];
  /** The internal publication id */
  publicationId: Scalars['InternalPublicationId'];
};

export type PublicationProfileNotInterestedRequest = {
  /** Profile id to perform the action */
  profileId: Scalars['ProfileId'];
  /** The internal publication id */
  publicationId: Scalars['InternalPublicationId'];
};

export type PublicationQueryRequest = {
  /** The publication id */
  publicationId?: InputMaybe<Scalars['InternalPublicationId']>;
  /** The tx hash */
  txHash?: InputMaybe<Scalars['TxHash']>;
};

/** Publication reporting fraud subreason */
export enum PublicationReportingFraudSubreason {
  Impersonation = 'IMPERSONATION',
  Scam = 'SCAM'
}

/** Publication reporting illegal subreason */
export enum PublicationReportingIllegalSubreason {
  AnimalAbuse = 'ANIMAL_ABUSE',
  DirectThreat = 'DIRECT_THREAT',
  HumanAbuse = 'HUMAN_ABUSE',
  ThreatIndividual = 'THREAT_INDIVIDUAL',
  Violence = 'VIOLENCE'
}

/** Publication reporting reason */
export enum PublicationReportingReason {
  Fraud = 'FRAUD',
  Illegal = 'ILLEGAL',
  Sensitive = 'SENSITIVE',
  Spam = 'SPAM'
}

/** Publication reporting sensitive subreason */
export enum PublicationReportingSensitiveSubreason {
  Nsfw = 'NSFW',
  Offensive = 'OFFENSIVE'
}

/** Publication reporting spam subreason */
export enum PublicationReportingSpamSubreason {
  FakeEngagement = 'FAKE_ENGAGEMENT',
  LowSignal = 'LOW_SIGNAL',
  ManipulationAlgo = 'MANIPULATION_ALGO',
  Misleading = 'MISLEADING',
  MisuseHashtags = 'MISUSE_HASHTAGS',
  Repetitive = 'REPETITIVE',
  SomethingElse = 'SOMETHING_ELSE',
  Unrelated = 'UNRELATED'
}

/** The social comment */
export type PublicationRevenue = {
  __typename?: 'PublicationRevenue';
  publication: Publication;
  revenue: RevenueAggregate;
};

export type PublicationRevenueQueryRequest = {
  /** The publication id */
  publicationId: Scalars['InternalPublicationId'];
};

/** Publication search results */
export type PublicationSearchResult = {
  __typename?: 'PublicationSearchResult';
  items: Array<PublicationSearchResultItem>;
  pageInfo: PaginatedResultInfo;
  type: SearchRequestTypes;
};

export type PublicationSearchResultItem = Comment | Post;

export type PublicationSignatureContextInput = {
  signature: Scalars['String'];
};

/** Publication sort criteria */
export enum PublicationSortCriteria {
  CuratedProfiles = 'CURATED_PROFILES',
  Latest = 'LATEST',
  TopCollected = 'TOP_COLLECTED',
  TopCommented = 'TOP_COMMENTED',
  TopMirrored = 'TOP_MIRRORED'
}

/** The publication stats */
export type PublicationStats = {
  __typename?: 'PublicationStats';
  commentsTotal: Scalars['Int'];
  /** The publication id */
  id: Scalars['InternalPublicationId'];
  /** The total amount of collects */
  totalAmountOfCollects: Scalars['Int'];
  /** The total amount of comments */
  totalAmountOfComments: Scalars['Int'];
  /** The total amount of mirrors */
  totalAmountOfMirrors: Scalars['Int'];
  /** The total amount of bookmarks */
  totalBookmarks: Scalars['Int'];
  /** The total amount of upvotes */
  totalDownvotes: Scalars['Int'];
  /** The total amount of downvotes */
  totalUpvotes: Scalars['Int'];
};


/** The publication stats */
export type PublicationStatsCommentsTotalArgs = {
  customFilters?: InputMaybe<Array<CustomFiltersTypes>>;
  forSources?: InputMaybe<Array<Scalars['Sources']>>;
};

/** The publication types */
export enum PublicationTypes {
  Comment = 'COMMENT',
  Mirror = 'MIRROR',
  Post = 'POST'
}

export type PublicationValidateMetadataResult = {
  __typename?: 'PublicationValidateMetadataResult';
  /** If `valid` is false it will put a reason why here */
  reason?: Maybe<Scalars['String']>;
  valid: Scalars['Boolean'];
};

export type PublicationsProfileBookmarkedQueryRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  metadata?: InputMaybe<PublicationMetadataFilters>;
  /** Profile id */
  profileId: Scalars['ProfileId'];
  /** The App Id */
  sources?: InputMaybe<Array<Scalars['Sources']>>;
};

export type PublicationsQueryRequest = {
  /** The ethereum address */
  collectedBy?: InputMaybe<Scalars['EthereumAddress']>;
  /** The publication id you wish to get comments for */
  commentsOf?: InputMaybe<Scalars['InternalPublicationId']>;
  /** The comment ordering type - only used when you use commentsOf */
  commentsOfOrdering?: InputMaybe<CommentOrderingTypes>;
  /** The comment ranking filter, you can use  - only used when you use commentsOf + commentsOfOrdering=ranking */
  commentsRankingFilter?: InputMaybe<CommentRankingFilter>;
  cursor?: InputMaybe<Scalars['Cursor']>;
  customFilters?: InputMaybe<Array<CustomFiltersTypes>>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  metadata?: InputMaybe<PublicationMetadataFilters>;
  /** Profile id */
  profileId?: InputMaybe<Scalars['ProfileId']>;
  /** Profile ids */
  profileIds?: InputMaybe<Array<Scalars['ProfileId']>>;
  /** The publication id */
  publicationIds?: InputMaybe<Array<Scalars['InternalPublicationId']>>;
  /** The publication types you want to query */
  publicationTypes?: InputMaybe<Array<PublicationTypes>>;
  /** The App Id */
  sources?: InputMaybe<Array<Scalars['Sources']>>;
};

export type Query = {
  __typename?: 'Query';
  /** Access to subgraph metadata */
  _meta?: Maybe<_Meta_>;
  account?: Maybe<Account>;
  accountTokenSnapshot?: Maybe<AccountTokenSnapshot>;
  accountTokenSnapshotLog?: Maybe<AccountTokenSnapshotLog>;
  accountTokenSnapshotLogs: Array<AccountTokenSnapshotLog>;
  accountTokenSnapshots: Array<AccountTokenSnapshot>;
  accounts: Array<Account>;
  agreementClassRegisteredEvent?: Maybe<AgreementClassRegisteredEvent>;
  agreementClassRegisteredEvents: Array<AgreementClassRegisteredEvent>;
  agreementClassUpdatedEvent?: Maybe<AgreementClassUpdatedEvent>;
  agreementClassUpdatedEvents: Array<AgreementClassUpdatedEvent>;
  agreementLiquidatedByEvent?: Maybe<AgreementLiquidatedByEvent>;
  agreementLiquidatedByEvents: Array<AgreementLiquidatedByEvent>;
  agreementLiquidatedV2Event?: Maybe<AgreementLiquidatedV2Event>;
  agreementLiquidatedV2Events: Array<AgreementLiquidatedV2Event>;
  allPublicationsTags: PaginatedAllPublicationsTagsResult;
  alreadyInvited: Scalars['Boolean'];
  appRegisteredEvent?: Maybe<AppRegisteredEvent>;
  appRegisteredEvents: Array<AppRegisteredEvent>;
  approvedModuleAllowanceAmount: Array<ApprovedAllowanceAmount>;
  bondIncreasedEvent?: Maybe<BondIncreasedEvent>;
  bondIncreasedEvents: Array<BondIncreasedEvent>;
  burnedEvent?: Maybe<BurnedEvent>;
  burnedEvents: Array<BurnedEvent>;
  cfav1LiquidationPeriodChangedEvent?: Maybe<CfAv1LiquidationPeriodChangedEvent>;
  cfav1LiquidationPeriodChangedEvents: Array<CfAv1LiquidationPeriodChangedEvent>;
  challenge: AuthChallengeResult;
  claimableHandles: ClaimableHandles;
  claimableStatus: ClaimStatus;
  configChangedEvent?: Maybe<ConfigChangedEvent>;
  configChangedEvents: Array<ConfigChangedEvent>;
  cur: Array<Scalars['String']>;
  customSuperTokenCreatedEvent?: Maybe<CustomSuperTokenCreatedEvent>;
  customSuperTokenCreatedEvents: Array<CustomSuperTokenCreatedEvent>;
  dataAvailabilitySubmitters: DataAvailabilitySubmittersResult;
  dataAvailabilitySummary: DataAvailabilitySummaryResult;
  dataAvailabilityTransaction?: Maybe<DataAvailabilityTransactionUnion>;
  dataAvailabilityTransactions: DataAvailabilityTransactionsResult;
  defaultProfile?: Maybe<Profile>;
  doesFollow: Array<DoesFollowResponse>;
  enabledModuleCurrencies: Array<Erc20>;
  enabledModules: EnabledModules;
  event?: Maybe<Event>;
  events: Array<Event>;
  exitRateChangedEvent?: Maybe<ExitRateChangedEvent>;
  exitRateChangedEvents: Array<ExitRateChangedEvent>;
  exploreProfiles: ExploreProfileResult;
  explorePublications: ExplorePublicationResult;
  feed: PaginatedFeedResult;
  feedHighlights: PaginatedTimelineResult;
  flowOperator?: Maybe<FlowOperator>;
  flowOperatorUpdatedEvent?: Maybe<FlowOperatorUpdatedEvent>;
  flowOperatorUpdatedEvents: Array<FlowOperatorUpdatedEvent>;
  flowOperators: Array<FlowOperator>;
  flowUpdatedEvent?: Maybe<FlowUpdatedEvent>;
  flowUpdatedEvents: Array<FlowUpdatedEvent>;
  followerNftOwnedTokenIds?: Maybe<FollowerNftOwnedTokenIds>;
  followers: PaginatedFollowersResult;
  following: PaginatedFollowingResult;
  /** Get publications recommended for you - will only return posts for now */
  forYou: PaginatedForYouResult;
  gct: Array<Scalars['String']>;
  gdm: Array<Scalars['Url']>;
  generateModuleCurrencyApprovalData: GenerateModuleCurrencyApproval;
  globalProtocolStats: GlobalProtocolStats;
  governanceReplacedEvent?: Maybe<GovernanceReplacedEvent>;
  governanceReplacedEvents: Array<GovernanceReplacedEvent>;
  hasTxHashBeenIndexed: TransactionResult;
  index?: Maybe<Index>;
  indexCreatedEvent?: Maybe<IndexCreatedEvent>;
  indexCreatedEvents: Array<IndexCreatedEvent>;
  indexDistributionClaimedEvent?: Maybe<IndexDistributionClaimedEvent>;
  indexDistributionClaimedEvents: Array<IndexDistributionClaimedEvent>;
  indexSubscribedEvent?: Maybe<IndexSubscribedEvent>;
  indexSubscribedEvents: Array<IndexSubscribedEvent>;
  indexSubscription?: Maybe<IndexSubscription>;
  indexSubscriptions: Array<IndexSubscription>;
  indexUnitsUpdatedEvent?: Maybe<IndexUnitsUpdatedEvent>;
  indexUnitsUpdatedEvents: Array<IndexUnitsUpdatedEvent>;
  indexUnsubscribedEvent?: Maybe<IndexUnsubscribedEvent>;
  indexUnsubscribedEvents: Array<IndexUnsubscribedEvent>;
  indexUpdatedEvent?: Maybe<IndexUpdatedEvent>;
  indexUpdatedEvents: Array<IndexUpdatedEvent>;
  indexes: Array<Index>;
  internalPin: Array<InternalPinResult>;
  intotal: Scalars['Int'];
  invited: Array<InvitedResult>;
  invitesLeft: Scalars['Int'];
  isIDKitPhoneVerified: Scalars['Boolean'];
  iss: PrfResponse;
  jailEvent?: Maybe<JailEvent>;
  jailEvents: Array<JailEvent>;
  mintedEvent?: Maybe<MintedEvent>;
  mintedEvents: Array<MintedEvent>;
  mutualFollowersProfiles: PaginatedProfileResult;
  newPICEvent?: Maybe<NewPicEvent>;
  newPICEvents: Array<NewPicEvent>;
  /** Get all NFT galleries for a profile */
  nftGalleries: Array<NftGallery>;
  nftOwnershipChallenge: NftOwnershipChallengeResult;
  /** Get the NFTs that the given wallet or profileId owns. Only supports Ethereum and Polygon NFTs. Note excludeFollowers is set to true by default, so the result will not include Lens Follower NFTs unless explicitly requested. */
  nfts: NfTsResult;
  notifications: PaginatedNotificationResult;
  pendingApprovalFollows: PendingApproveFollowsResult;
  ping: Scalars['String'];
  pppconfigurationChangedEvent?: Maybe<PppConfigurationChangedEvent>;
  pppconfigurationChangedEvents: Array<PppConfigurationChangedEvent>;
  profile?: Maybe<Profile>;
  profileFollowModuleBeenRedeemed: Scalars['Boolean'];
  profileFollowRevenue: FollowRevenueResult;
  profileGuardianInformation: ProfileGuardianResult;
  /** Get the list of profile interests */
  profileInterests: Array<Scalars['ProfileInterest']>;
  profileOnChainIdentity: Array<OnChainIdentity>;
  profilePublicationRevenue: ProfilePublicationRevenueResult;
  profilePublicationsForSale: PaginatedProfilePublicationsForSaleResult;
  profiles: PaginatedProfileResult;
  proxyActionStatus: ProxyActionStatusResultUnion;
  publication?: Maybe<Publication>;
  publicationMetadataStatus: PublicationMetadataStatus;
  publicationRevenue?: Maybe<PublicationRevenue>;
  publications: PaginatedPublicationResult;
  publicationsProfileBookmarks: PaginatedPublicationResult;
  recommendedProfiles: Array<Profile>;
  rel?: Maybe<Scalars['Void']>;
  relayQueues: Array<RelayQueueResult>;
  resolverEntries: Array<ResolverEntry>;
  resolverEntry?: Maybe<ResolverEntry>;
  rewardAddressChangedEvent?: Maybe<RewardAddressChangedEvent>;
  rewardAddressChangedEvents: Array<RewardAddressChangedEvent>;
  roleAdminChangedEvent?: Maybe<RoleAdminChangedEvent>;
  roleAdminChangedEvents: Array<RoleAdminChangedEvent>;
  roleGrantedEvent?: Maybe<RoleGrantedEvent>;
  roleGrantedEvents: Array<RoleGrantedEvent>;
  roleRevokedEvent?: Maybe<RoleRevokedEvent>;
  roleRevokedEvents: Array<RoleRevokedEvent>;
  search: SearchResult;
  /** Search for NFTs in a wallet by collection name. Supports Polygon and Ethereum and searches in both by default. */
  searchNfts: NfTsResult;
  sentEvent?: Maybe<SentEvent>;
  sentEvents: Array<SentEvent>;
  setEvent?: Maybe<SetEvent>;
  setEvents: Array<SetEvent>;
  sfmeta?: Maybe<SfMeta>;
  sfmetas: Array<SfMeta>;
  stream?: Maybe<Stream>;
  streamPeriod?: Maybe<StreamPeriod>;
  streamPeriods: Array<StreamPeriod>;
  streamRevision?: Maybe<StreamRevision>;
  streamRevisions: Array<StreamRevision>;
  streams: Array<Stream>;
  subscriptionApprovedEvent?: Maybe<SubscriptionApprovedEvent>;
  subscriptionApprovedEvents: Array<SubscriptionApprovedEvent>;
  subscriptionDistributionClaimedEvent?: Maybe<SubscriptionDistributionClaimedEvent>;
  subscriptionDistributionClaimedEvents: Array<SubscriptionDistributionClaimedEvent>;
  subscriptionRevokedEvent?: Maybe<SubscriptionRevokedEvent>;
  subscriptionRevokedEvents: Array<SubscriptionRevokedEvent>;
  subscriptionUnitsUpdatedEvent?: Maybe<SubscriptionUnitsUpdatedEvent>;
  subscriptionUnitsUpdatedEvents: Array<SubscriptionUnitsUpdatedEvent>;
  superTokenCreatedEvent?: Maybe<SuperTokenCreatedEvent>;
  superTokenCreatedEvents: Array<SuperTokenCreatedEvent>;
  superTokenFactoryUpdatedEvent?: Maybe<SuperTokenFactoryUpdatedEvent>;
  superTokenFactoryUpdatedEvents: Array<SuperTokenFactoryUpdatedEvent>;
  superTokenLogicCreatedEvent?: Maybe<SuperTokenLogicCreatedEvent>;
  superTokenLogicCreatedEvents: Array<SuperTokenLogicCreatedEvent>;
  superTokenLogicUpdatedEvent?: Maybe<SuperTokenLogicUpdatedEvent>;
  superTokenLogicUpdatedEvents: Array<SuperTokenLogicUpdatedEvent>;
  superTokenMinimumDepositChangedEvent?: Maybe<SuperTokenMinimumDepositChangedEvent>;
  superTokenMinimumDepositChangedEvents: Array<SuperTokenMinimumDepositChangedEvent>;
  token?: Maybe<Token>;
  tokenDowngradedEvent?: Maybe<TokenDowngradedEvent>;
  tokenDowngradedEvents: Array<TokenDowngradedEvent>;
  tokenGovernanceConfig?: Maybe<TokenGovernanceConfig>;
  tokenGovernanceConfigs: Array<TokenGovernanceConfig>;
  tokenStatistic?: Maybe<TokenStatistic>;
  tokenStatisticLog?: Maybe<TokenStatisticLog>;
  tokenStatisticLogs: Array<TokenStatisticLog>;
  tokenStatistics: Array<TokenStatistic>;
  tokenUpgradedEvent?: Maybe<TokenUpgradedEvent>;
  tokenUpgradedEvents: Array<TokenUpgradedEvent>;
  tokens: Array<Token>;
  transferEvent?: Maybe<TransferEvent>;
  transferEvents: Array<TransferEvent>;
  trustedForwarderChangedEvent?: Maybe<TrustedForwarderChangedEvent>;
  trustedForwarderChangedEvents: Array<TrustedForwarderChangedEvent>;
  txIdToTxHash: Scalars['TxHash'];
  unknownEnabledModules: EnabledModules;
  userSigNonces: UserSigNonces;
  validatePublicationMetadata: PublicationValidateMetadataResult;
  verify: Scalars['Boolean'];
  whoCollectedPublication: PaginatedWhoCollectedResult;
  whoReactedPublication: PaginatedWhoReactedResult;
};


export type Query_MetaArgs = {
  block?: InputMaybe<Block_Height>;
};


export type QueryAccountArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryAccountTokenSnapshotArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryAccountTokenSnapshotLogArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryAccountTokenSnapshotLogsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenSnapshotLog_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountTokenSnapshotLog_Filter>;
};


export type QueryAccountTokenSnapshotsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenSnapshot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountTokenSnapshot_Filter>;
};


export type QueryAccountsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Account_Filter>;
};


export type QueryAgreementClassRegisteredEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryAgreementClassRegisteredEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AgreementClassRegisteredEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AgreementClassRegisteredEvent_Filter>;
};


export type QueryAgreementClassUpdatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryAgreementClassUpdatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AgreementClassUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AgreementClassUpdatedEvent_Filter>;
};


export type QueryAgreementLiquidatedByEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryAgreementLiquidatedByEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AgreementLiquidatedByEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AgreementLiquidatedByEvent_Filter>;
};


export type QueryAgreementLiquidatedV2EventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryAgreementLiquidatedV2EventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AgreementLiquidatedV2Event_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AgreementLiquidatedV2Event_Filter>;
};


export type QueryAllPublicationsTagsArgs = {
  request: AllPublicationsTagsRequest;
};


export type QueryAlreadyInvitedArgs = {
  request: AlreadyInvitedCheckRequest;
};


export type QueryAppRegisteredEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryAppRegisteredEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AppRegisteredEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AppRegisteredEvent_Filter>;
};


export type QueryApprovedModuleAllowanceAmountArgs = {
  request: ApprovedModuleAllowanceAmountRequest;
};


export type QueryBondIncreasedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryBondIncreasedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<BondIncreasedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<BondIncreasedEvent_Filter>;
};


export type QueryBurnedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryBurnedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<BurnedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<BurnedEvent_Filter>;
};


export type QueryCfav1LiquidationPeriodChangedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryCfav1LiquidationPeriodChangedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<CfAv1LiquidationPeriodChangedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<CfAv1LiquidationPeriodChangedEvent_Filter>;
};


export type QueryChallengeArgs = {
  request: ChallengeRequest;
};


export type QueryConfigChangedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryConfigChangedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ConfigChangedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<ConfigChangedEvent_Filter>;
};


export type QueryCurArgs = {
  request: CurRequest;
};


export type QueryCustomSuperTokenCreatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryCustomSuperTokenCreatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<CustomSuperTokenCreatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<CustomSuperTokenCreatedEvent_Filter>;
};


export type QueryDataAvailabilityTransactionArgs = {
  request: DataAvailabilityTransactionRequest;
};


export type QueryDataAvailabilityTransactionsArgs = {
  request?: InputMaybe<DataAvailabilityTransactionsRequest>;
};


export type QueryDefaultProfileArgs = {
  request: DefaultProfileRequest;
};


export type QueryDoesFollowArgs = {
  request: DoesFollowRequest;
};


export type QueryEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Event_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Event_Filter>;
};


export type QueryExitRateChangedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryExitRateChangedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ExitRateChangedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<ExitRateChangedEvent_Filter>;
};


export type QueryExploreProfilesArgs = {
  request: ExploreProfilesRequest;
};


export type QueryExplorePublicationsArgs = {
  request: ExplorePublicationRequest;
};


export type QueryFeedArgs = {
  request: FeedRequest;
};


export type QueryFeedHighlightsArgs = {
  request: FeedHighlightsRequest;
};


export type QueryFlowOperatorArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryFlowOperatorUpdatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryFlowOperatorUpdatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<FlowOperatorUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<FlowOperatorUpdatedEvent_Filter>;
};


export type QueryFlowOperatorsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<FlowOperator_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<FlowOperator_Filter>;
};


export type QueryFlowUpdatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryFlowUpdatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<FlowUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<FlowUpdatedEvent_Filter>;
};


export type QueryFollowerNftOwnedTokenIdsArgs = {
  request: FollowerNftOwnedTokenIdsRequest;
};


export type QueryFollowersArgs = {
  request: FollowersRequest;
};


export type QueryFollowingArgs = {
  request: FollowingRequest;
};


export type QueryForYouArgs = {
  request: PublicationForYouRequest;
};


export type QueryGctArgs = {
  request: GctRequest;
};


export type QueryGdmArgs = {
  request: GdmRequest;
};


export type QueryGenerateModuleCurrencyApprovalDataArgs = {
  request: GenerateModuleCurrencyApprovalDataRequest;
};


export type QueryGlobalProtocolStatsArgs = {
  request?: InputMaybe<GlobalProtocolStatsRequest>;
};


export type QueryGovernanceReplacedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryGovernanceReplacedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<GovernanceReplacedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<GovernanceReplacedEvent_Filter>;
};


export type QueryHasTxHashBeenIndexedArgs = {
  request: HasTxHashBeenIndexedRequest;
};


export type QueryIndexArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryIndexCreatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryIndexCreatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexCreatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<IndexCreatedEvent_Filter>;
};


export type QueryIndexDistributionClaimedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryIndexDistributionClaimedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexDistributionClaimedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<IndexDistributionClaimedEvent_Filter>;
};


export type QueryIndexSubscribedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryIndexSubscribedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexSubscribedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<IndexSubscribedEvent_Filter>;
};


export type QueryIndexSubscriptionArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryIndexSubscriptionsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexSubscription_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<IndexSubscription_Filter>;
};


export type QueryIndexUnitsUpdatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryIndexUnitsUpdatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexUnitsUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<IndexUnitsUpdatedEvent_Filter>;
};


export type QueryIndexUnsubscribedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryIndexUnsubscribedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexUnsubscribedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<IndexUnsubscribedEvent_Filter>;
};


export type QueryIndexUpdatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryIndexUpdatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<IndexUpdatedEvent_Filter>;
};


export type QueryIndexesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Index_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Index_Filter>;
};


export type QueryInternalPinArgs = {
  request: InternalPinRequest;
};


export type QueryIntotalArgs = {
  request: InTotalRequest;
};


export type QueryIssArgs = {
  request: PriRequest;
};


export type QueryJailEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryJailEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<JailEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<JailEvent_Filter>;
};


export type QueryMintedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryMintedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<MintedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<MintedEvent_Filter>;
};


export type QueryMutualFollowersProfilesArgs = {
  request: MutualFollowersProfilesQueryRequest;
};


export type QueryNewPicEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryNewPicEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<NewPicEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<NewPicEvent_Filter>;
};


export type QueryNftGalleriesArgs = {
  request: NftGalleriesRequest;
};


export type QueryNftOwnershipChallengeArgs = {
  request: NftOwnershipChallengeRequest;
};


export type QueryNftsArgs = {
  request: NfTsRequest;
};


export type QueryNotificationsArgs = {
  request: NotificationRequest;
};


export type QueryPendingApprovalFollowsArgs = {
  request: PendingApprovalFollowsRequest;
};


export type QueryPppconfigurationChangedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryPppconfigurationChangedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PppConfigurationChangedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PppConfigurationChangedEvent_Filter>;
};


export type QueryProfileArgs = {
  request: SingleProfileQueryRequest;
};


export type QueryProfileFollowModuleBeenRedeemedArgs = {
  request: ProfileFollowModuleBeenRedeemedRequest;
};


export type QueryProfileFollowRevenueArgs = {
  request: ProfileFollowRevenueQueryRequest;
};


export type QueryProfileGuardianInformationArgs = {
  request: ProfileGuardianRequest;
};


export type QueryProfileOnChainIdentityArgs = {
  request: ProfileOnChainIdentityRequest;
};


export type QueryProfilePublicationRevenueArgs = {
  request: ProfilePublicationRevenueQueryRequest;
};


export type QueryProfilePublicationsForSaleArgs = {
  request: ProfilePublicationsForSaleRequest;
};


export type QueryProfilesArgs = {
  request: ProfileQueryRequest;
};


export type QueryProxyActionStatusArgs = {
  proxyActionId: Scalars['ProxyActionId'];
};


export type QueryPublicationArgs = {
  request: PublicationQueryRequest;
};


export type QueryPublicationMetadataStatusArgs = {
  request: GetPublicationMetadataStatusRequest;
};


export type QueryPublicationRevenueArgs = {
  request: PublicationRevenueQueryRequest;
};


export type QueryPublicationsArgs = {
  request: PublicationsQueryRequest;
};


export type QueryPublicationsProfileBookmarksArgs = {
  request: PublicationsProfileBookmarkedQueryRequest;
};


export type QueryRecommendedProfilesArgs = {
  options?: InputMaybe<RecommendedProfileOptions>;
};


export type QueryRelArgs = {
  request: RelRequest;
};


export type QueryResolverEntriesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ResolverEntry_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<ResolverEntry_Filter>;
};


export type QueryResolverEntryArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryRewardAddressChangedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryRewardAddressChangedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<RewardAddressChangedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<RewardAddressChangedEvent_Filter>;
};


export type QueryRoleAdminChangedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryRoleAdminChangedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<RoleAdminChangedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<RoleAdminChangedEvent_Filter>;
};


export type QueryRoleGrantedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryRoleGrantedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<RoleGrantedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<RoleGrantedEvent_Filter>;
};


export type QueryRoleRevokedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryRoleRevokedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<RoleRevokedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<RoleRevokedEvent_Filter>;
};


export type QuerySearchArgs = {
  request: SearchQueryRequest;
};


export type QuerySearchNftsArgs = {
  request: NftSearchRequest;
};


export type QuerySentEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QuerySentEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SentEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SentEvent_Filter>;
};


export type QuerySetEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QuerySetEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SetEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SetEvent_Filter>;
};


export type QuerySfmetaArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QuerySfmetasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SfMeta_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SfMeta_Filter>;
};


export type QueryStreamArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryStreamPeriodArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryStreamPeriodsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StreamPeriod_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<StreamPeriod_Filter>;
};


export type QueryStreamRevisionArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryStreamRevisionsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StreamRevision_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<StreamRevision_Filter>;
};


export type QueryStreamsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Stream_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Stream_Filter>;
};


export type QuerySubscriptionApprovedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QuerySubscriptionApprovedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SubscriptionApprovedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SubscriptionApprovedEvent_Filter>;
};


export type QuerySubscriptionDistributionClaimedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QuerySubscriptionDistributionClaimedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SubscriptionDistributionClaimedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SubscriptionDistributionClaimedEvent_Filter>;
};


export type QuerySubscriptionRevokedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QuerySubscriptionRevokedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SubscriptionRevokedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SubscriptionRevokedEvent_Filter>;
};


export type QuerySubscriptionUnitsUpdatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QuerySubscriptionUnitsUpdatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SubscriptionUnitsUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SubscriptionUnitsUpdatedEvent_Filter>;
};


export type QuerySuperTokenCreatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QuerySuperTokenCreatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SuperTokenCreatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SuperTokenCreatedEvent_Filter>;
};


export type QuerySuperTokenFactoryUpdatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QuerySuperTokenFactoryUpdatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SuperTokenFactoryUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SuperTokenFactoryUpdatedEvent_Filter>;
};


export type QuerySuperTokenLogicCreatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QuerySuperTokenLogicCreatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SuperTokenLogicCreatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SuperTokenLogicCreatedEvent_Filter>;
};


export type QuerySuperTokenLogicUpdatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QuerySuperTokenLogicUpdatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SuperTokenLogicUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SuperTokenLogicUpdatedEvent_Filter>;
};


export type QuerySuperTokenMinimumDepositChangedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QuerySuperTokenMinimumDepositChangedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SuperTokenMinimumDepositChangedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SuperTokenMinimumDepositChangedEvent_Filter>;
};


export type QueryTokenArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryTokenDowngradedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryTokenDowngradedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenDowngradedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenDowngradedEvent_Filter>;
};


export type QueryTokenGovernanceConfigArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryTokenGovernanceConfigsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenGovernanceConfig_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenGovernanceConfig_Filter>;
};


export type QueryTokenStatisticArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryTokenStatisticLogArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryTokenStatisticLogsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenStatisticLog_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenStatisticLog_Filter>;
};


export type QueryTokenStatisticsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenStatistic_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenStatistic_Filter>;
};


export type QueryTokenUpgradedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryTokenUpgradedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenUpgradedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenUpgradedEvent_Filter>;
};


export type QueryTokensArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Token_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Token_Filter>;
};


export type QueryTransferEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryTransferEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TransferEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TransferEvent_Filter>;
};


export type QueryTrustedForwarderChangedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type QueryTrustedForwarderChangedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TrustedForwarderChangedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TrustedForwarderChangedEvent_Filter>;
};


export type QueryTxIdToTxHashArgs = {
  txId: Scalars['TxId'];
};


export type QueryValidatePublicationMetadataArgs = {
  request: ValidatePublicationMetadataRequest;
};


export type QueryVerifyArgs = {
  request: VerifyRequest;
};


export type QueryWhoCollectedPublicationArgs = {
  request: WhoCollectedPublicationRequest;
};


export type QueryWhoReactedPublicationArgs = {
  request: WhoReactedPublicationRequest;
};

export type ReactionEvent = {
  __typename?: 'ReactionEvent';
  profile: Profile;
  reaction: ReactionTypes;
  timestamp: Scalars['DateTime'];
};

export type ReactionFieldResolverRequest = {
  /** Profile id */
  profileId?: InputMaybe<Scalars['ProfileId']>;
};

export type ReactionRequest = {
  /** Profile id to perform the action */
  profileId: Scalars['ProfileId'];
  /** The internal publication id */
  publicationId: Scalars['InternalPublicationId'];
  /** The reaction */
  reaction: ReactionTypes;
};

/** Reaction types */
export enum ReactionTypes {
  Downvote = 'DOWNVOTE',
  Upvote = 'UPVOTE'
}

export type RecipientDataInput = {
  /** Recipient of collect fees. */
  recipient: Scalars['EthereumAddress'];
  /** Split %, should be between 0.01 and 100. Up to 2 decimal points supported. All % should add up to 100 */
  split: Scalars['Float'];
};

export type RecipientDataOutput = {
  __typename?: 'RecipientDataOutput';
  /** Recipient of collect fees. */
  recipient: Scalars['EthereumAddress'];
  /** Split %, should be between 0.01 and 100. Up to 2 decimal points supported. All % should add up to 100 */
  split: Scalars['Float'];
};

export type RecommendedProfileOptions = {
  /** If you wish to turn ML off */
  disableML?: InputMaybe<Scalars['Boolean']>;
  /** The more advanced who to follow you should pass this in */
  profileId?: InputMaybe<Scalars['ProfileId']>;
  /** If you wish to shuffle the results */
  shuffle?: InputMaybe<Scalars['Boolean']>;
};

export type ReferenceModule = DegreesOfSeparationReferenceModuleSettings | FollowOnlyReferenceModuleSettings | UnknownReferenceModuleSettings;

export type ReferenceModuleParams = {
  /** The degrees of separation reference module */
  degreesOfSeparationReferenceModule?: InputMaybe<DegreesOfSeparationReferenceModuleParams>;
  /** The follower only reference module */
  followerOnlyReferenceModule?: InputMaybe<Scalars['Boolean']>;
  /** A unknown reference module */
  unknownReferenceModule?: InputMaybe<UnknownReferenceModuleParams>;
};

/** The reference module types */
export enum ReferenceModules {
  DegreesOfSeparationReferenceModule = 'DegreesOfSeparationReferenceModule',
  FollowerOnlyReferenceModule = 'FollowerOnlyReferenceModule',
  UnknownReferenceModule = 'UnknownReferenceModule'
}

/** The refresh request */
export type RefreshRequest = {
  /** The refresh token */
  refreshToken: Scalars['Jwt'];
};

export type RelRequest = {
  ethereumAddress: Scalars['EthereumAddress'];
  secret: Scalars['String'];
};

export type RelayDataAvailabilityResult = CreateDataAvailabilityPublicationResult | RelayError;

export type RelayError = {
  __typename?: 'RelayError';
  reason: RelayErrorReasons;
};

/** Relay error reason */
export enum RelayErrorReasons {
  Expired = 'EXPIRED',
  HandleTaken = 'HANDLE_TAKEN',
  NotAllowed = 'NOT_ALLOWED',
  Rejected = 'REJECTED',
  WrongWalletSigned = 'WRONG_WALLET_SIGNED'
}

/** The  */
export type RelayQueueResult = {
  __typename?: 'RelayQueueResult';
  /** The address of the relay */
  address: Scalars['EthereumAddress'];
  /** The queue on the relay */
  queue: Scalars['Float'];
  /** The relayer name */
  relayer: RelayRoleKey;
};

export type RelayResult = RelayError | RelayerResult;

/** The relay role key */
export enum RelayRoleKey {
  CreateProfile = 'CREATE_PROFILE',
  Dispatcher_1 = 'DISPATCHER_1',
  Dispatcher_2 = 'DISPATCHER_2',
  Dispatcher_3 = 'DISPATCHER_3',
  Dispatcher_4 = 'DISPATCHER_4',
  Dispatcher_5 = 'DISPATCHER_5',
  Dispatcher_6 = 'DISPATCHER_6',
  Dispatcher_7 = 'DISPATCHER_7',
  Dispatcher_8 = 'DISPATCHER_8',
  Dispatcher_9 = 'DISPATCHER_9',
  Dispatcher_10 = 'DISPATCHER_10',
  ProxyActionCollect_1 = 'PROXY_ACTION_COLLECT_1',
  ProxyActionCollect_2 = 'PROXY_ACTION_COLLECT_2',
  ProxyActionCollect_3 = 'PROXY_ACTION_COLLECT_3',
  ProxyActionCollect_4 = 'PROXY_ACTION_COLLECT_4',
  ProxyActionCollect_5 = 'PROXY_ACTION_COLLECT_5',
  ProxyActionCollect_6 = 'PROXY_ACTION_COLLECT_6',
  ProxyActionFollow_1 = 'PROXY_ACTION_FOLLOW_1',
  ProxyActionFollow_2 = 'PROXY_ACTION_FOLLOW_2',
  ProxyActionFollow_3 = 'PROXY_ACTION_FOLLOW_3',
  ProxyActionFollow_4 = 'PROXY_ACTION_FOLLOW_4',
  ProxyActionFollow_5 = 'PROXY_ACTION_FOLLOW_5',
  ProxyActionFollow_6 = 'PROXY_ACTION_FOLLOW_6',
  ProxyActionFollow_7 = 'PROXY_ACTION_FOLLOW_7',
  ProxyActionFollow_8 = 'PROXY_ACTION_FOLLOW_8',
  ProxyActionFollow_9 = 'PROXY_ACTION_FOLLOW_9',
  ProxyActionFollow_10 = 'PROXY_ACTION_FOLLOW_10',
  WithSig_1 = 'WITH_SIG_1',
  WithSig_2 = 'WITH_SIG_2',
  WithSig_3 = 'WITH_SIG_3',
  ZkRelayer_1 = 'ZK_RELAYER_1'
}

/** The relayer result */
export type RelayerResult = {
  __typename?: 'RelayerResult';
  /** The tx hash - you should use the `txId` as your identifier as gas prices can be upgraded meaning txHash will change */
  txHash: Scalars['TxHash'];
  /** The tx id */
  txId: Scalars['TxId'];
};

/** The request object to remove interests from a profile */
export type RemoveProfileInterestsRequest = {
  /** The profile interest to add */
  interests: Array<Scalars['ProfileInterest']>;
  /** The profileId to add interests to */
  profileId: Scalars['ProfileId'];
};

export type ReportPublicationRequest = {
  additionalComments?: InputMaybe<Scalars['String']>;
  publicationId: Scalars['InternalPublicationId'];
  reason: ReportingReasonInputParams;
};

export type ReportingReasonInputParams = {
  fraudReason?: InputMaybe<FraudReasonInputParams>;
  illegalReason?: InputMaybe<IllegalReasonInputParams>;
  sensitiveReason?: InputMaybe<SensitiveReasonInputParams>;
  spamReason?: InputMaybe<SpamReasonInputParams>;
};

export type ReservedClaimableHandle = {
  __typename?: 'ReservedClaimableHandle';
  expiry: Scalars['DateTime'];
  handle: Scalars['Handle'];
  id: Scalars['HandleClaimIdScalar'];
  source: Scalars['String'];
};

export type ResolverEntry = {
  __typename?: 'ResolverEntry';
  createdAtBlockNumber: Scalars['BigInt'];
  createdAtTimestamp: Scalars['BigInt'];
  /**
   * ID: the keccak256 hash of the set name
   *
   */
  id: Scalars['ID'];
  isListed: Scalars['Boolean'];
  isToken: Scalars['Boolean'];
  setEvents: Array<SetEvent>;
  targetAddress: Scalars['Bytes'];
  updatedAtBlockNumber: Scalars['BigInt'];
  updatedAtTimestamp: Scalars['BigInt'];
};


export type ResolverEntrySetEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SetEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SetEvent_Filter>;
};

export type ResolverEntry_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<ResolverEntry_Filter>>>;
  createdAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  isListed?: InputMaybe<Scalars['Boolean']>;
  isListed_in?: InputMaybe<Array<Scalars['Boolean']>>;
  isListed_not?: InputMaybe<Scalars['Boolean']>;
  isListed_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  isToken?: InputMaybe<Scalars['Boolean']>;
  isToken_in?: InputMaybe<Array<Scalars['Boolean']>>;
  isToken_not?: InputMaybe<Scalars['Boolean']>;
  isToken_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  or?: InputMaybe<Array<InputMaybe<ResolverEntry_Filter>>>;
  setEvents_?: InputMaybe<SetEvent_Filter>;
  targetAddress?: InputMaybe<Scalars['Bytes']>;
  targetAddress_contains?: InputMaybe<Scalars['Bytes']>;
  targetAddress_gt?: InputMaybe<Scalars['Bytes']>;
  targetAddress_gte?: InputMaybe<Scalars['Bytes']>;
  targetAddress_in?: InputMaybe<Array<Scalars['Bytes']>>;
  targetAddress_lt?: InputMaybe<Scalars['Bytes']>;
  targetAddress_lte?: InputMaybe<Scalars['Bytes']>;
  targetAddress_not?: InputMaybe<Scalars['Bytes']>;
  targetAddress_not_contains?: InputMaybe<Scalars['Bytes']>;
  targetAddress_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  updatedAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum ResolverEntry_OrderBy {
  CreatedAtBlockNumber = 'createdAtBlockNumber',
  CreatedAtTimestamp = 'createdAtTimestamp',
  Id = 'id',
  IsListed = 'isListed',
  IsToken = 'isToken',
  SetEvents = 'setEvents',
  TargetAddress = 'targetAddress',
  UpdatedAtBlockNumber = 'updatedAtBlockNumber',
  UpdatedAtTimestamp = 'updatedAtTimestamp'
}

export type RevenueAggregate = {
  __typename?: 'RevenueAggregate';
  total: Erc20Amount;
};

export type RevertCollectModuleSettings = {
  __typename?: 'RevertCollectModuleSettings';
  contractAddress: Scalars['ContractAddress'];
  /** The collect modules enum */
  type: CollectModules;
};

export type RevertFollowModuleSettings = {
  __typename?: 'RevertFollowModuleSettings';
  contractAddress: Scalars['ContractAddress'];
  /** The follow module enum */
  type: FollowModules;
};

export type RewardAddressChangedEvent = Event & {
  __typename?: 'RewardAddressChangedEvent';
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  /**
   * The address of the governance contract the event was emitted from.
   *
   */
  governanceAddress: Scalars['Bytes'];
  host: Scalars['Bytes'];
  id: Scalars['ID'];
  isKeySet: Scalars['Boolean'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  rewardAddress: Scalars['Bytes'];
  superToken: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
};

export type RewardAddressChangedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<RewardAddressChangedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  governanceAddress?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_contains?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_gt?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_gte?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_in?: InputMaybe<Array<Scalars['Bytes']>>;
  governanceAddress_lt?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_lte?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not_contains?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  host?: InputMaybe<Scalars['Bytes']>;
  host_contains?: InputMaybe<Scalars['Bytes']>;
  host_gt?: InputMaybe<Scalars['Bytes']>;
  host_gte?: InputMaybe<Scalars['Bytes']>;
  host_in?: InputMaybe<Array<Scalars['Bytes']>>;
  host_lt?: InputMaybe<Scalars['Bytes']>;
  host_lte?: InputMaybe<Scalars['Bytes']>;
  host_not?: InputMaybe<Scalars['Bytes']>;
  host_not_contains?: InputMaybe<Scalars['Bytes']>;
  host_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  isKeySet?: InputMaybe<Scalars['Boolean']>;
  isKeySet_in?: InputMaybe<Array<Scalars['Boolean']>>;
  isKeySet_not?: InputMaybe<Scalars['Boolean']>;
  isKeySet_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<RewardAddressChangedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  rewardAddress?: InputMaybe<Scalars['Bytes']>;
  rewardAddress_contains?: InputMaybe<Scalars['Bytes']>;
  rewardAddress_gt?: InputMaybe<Scalars['Bytes']>;
  rewardAddress_gte?: InputMaybe<Scalars['Bytes']>;
  rewardAddress_in?: InputMaybe<Array<Scalars['Bytes']>>;
  rewardAddress_lt?: InputMaybe<Scalars['Bytes']>;
  rewardAddress_lte?: InputMaybe<Scalars['Bytes']>;
  rewardAddress_not?: InputMaybe<Scalars['Bytes']>;
  rewardAddress_not_contains?: InputMaybe<Scalars['Bytes']>;
  rewardAddress_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  superToken?: InputMaybe<Scalars['Bytes']>;
  superToken_contains?: InputMaybe<Scalars['Bytes']>;
  superToken_gt?: InputMaybe<Scalars['Bytes']>;
  superToken_gte?: InputMaybe<Scalars['Bytes']>;
  superToken_in?: InputMaybe<Array<Scalars['Bytes']>>;
  superToken_lt?: InputMaybe<Scalars['Bytes']>;
  superToken_lte?: InputMaybe<Scalars['Bytes']>;
  superToken_not?: InputMaybe<Scalars['Bytes']>;
  superToken_not_contains?: InputMaybe<Scalars['Bytes']>;
  superToken_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum RewardAddressChangedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  GovernanceAddress = 'governanceAddress',
  Host = 'host',
  Id = 'id',
  IsKeySet = 'isKeySet',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  RewardAddress = 'rewardAddress',
  SuperToken = 'superToken',
  Timestamp = 'timestamp',
  TransactionHash = 'transactionHash'
}

export type RoleAdminChangedEvent = Event & {
  __typename?: 'RoleAdminChangedEvent';
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  newAdminRole: Scalars['Bytes'];
  order: Scalars['BigInt'];
  previousAdminRole: Scalars['Bytes'];
  role: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
};

export type RoleAdminChangedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<RoleAdminChangedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  newAdminRole?: InputMaybe<Scalars['Bytes']>;
  newAdminRole_contains?: InputMaybe<Scalars['Bytes']>;
  newAdminRole_gt?: InputMaybe<Scalars['Bytes']>;
  newAdminRole_gte?: InputMaybe<Scalars['Bytes']>;
  newAdminRole_in?: InputMaybe<Array<Scalars['Bytes']>>;
  newAdminRole_lt?: InputMaybe<Scalars['Bytes']>;
  newAdminRole_lte?: InputMaybe<Scalars['Bytes']>;
  newAdminRole_not?: InputMaybe<Scalars['Bytes']>;
  newAdminRole_not_contains?: InputMaybe<Scalars['Bytes']>;
  newAdminRole_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  or?: InputMaybe<Array<InputMaybe<RoleAdminChangedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  previousAdminRole?: InputMaybe<Scalars['Bytes']>;
  previousAdminRole_contains?: InputMaybe<Scalars['Bytes']>;
  previousAdminRole_gt?: InputMaybe<Scalars['Bytes']>;
  previousAdminRole_gte?: InputMaybe<Scalars['Bytes']>;
  previousAdminRole_in?: InputMaybe<Array<Scalars['Bytes']>>;
  previousAdminRole_lt?: InputMaybe<Scalars['Bytes']>;
  previousAdminRole_lte?: InputMaybe<Scalars['Bytes']>;
  previousAdminRole_not?: InputMaybe<Scalars['Bytes']>;
  previousAdminRole_not_contains?: InputMaybe<Scalars['Bytes']>;
  previousAdminRole_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  role?: InputMaybe<Scalars['Bytes']>;
  role_contains?: InputMaybe<Scalars['Bytes']>;
  role_gt?: InputMaybe<Scalars['Bytes']>;
  role_gte?: InputMaybe<Scalars['Bytes']>;
  role_in?: InputMaybe<Array<Scalars['Bytes']>>;
  role_lt?: InputMaybe<Scalars['Bytes']>;
  role_lte?: InputMaybe<Scalars['Bytes']>;
  role_not?: InputMaybe<Scalars['Bytes']>;
  role_not_contains?: InputMaybe<Scalars['Bytes']>;
  role_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum RoleAdminChangedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  NewAdminRole = 'newAdminRole',
  Order = 'order',
  PreviousAdminRole = 'previousAdminRole',
  Role = 'role',
  Timestamp = 'timestamp',
  TransactionHash = 'transactionHash'
}

export type RoleGrantedEvent = Event & {
  __typename?: 'RoleGrantedEvent';
  account: Scalars['Bytes'];
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  role: Scalars['Bytes'];
  sender: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
};

export type RoleGrantedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['Bytes']>;
  account_contains?: InputMaybe<Scalars['Bytes']>;
  account_gt?: InputMaybe<Scalars['Bytes']>;
  account_gte?: InputMaybe<Scalars['Bytes']>;
  account_in?: InputMaybe<Array<Scalars['Bytes']>>;
  account_lt?: InputMaybe<Scalars['Bytes']>;
  account_lte?: InputMaybe<Scalars['Bytes']>;
  account_not?: InputMaybe<Scalars['Bytes']>;
  account_not_contains?: InputMaybe<Scalars['Bytes']>;
  account_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<RoleGrantedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<RoleGrantedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  role?: InputMaybe<Scalars['Bytes']>;
  role_contains?: InputMaybe<Scalars['Bytes']>;
  role_gt?: InputMaybe<Scalars['Bytes']>;
  role_gte?: InputMaybe<Scalars['Bytes']>;
  role_in?: InputMaybe<Array<Scalars['Bytes']>>;
  role_lt?: InputMaybe<Scalars['Bytes']>;
  role_lte?: InputMaybe<Scalars['Bytes']>;
  role_not?: InputMaybe<Scalars['Bytes']>;
  role_not_contains?: InputMaybe<Scalars['Bytes']>;
  role_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  sender?: InputMaybe<Scalars['Bytes']>;
  sender_contains?: InputMaybe<Scalars['Bytes']>;
  sender_gt?: InputMaybe<Scalars['Bytes']>;
  sender_gte?: InputMaybe<Scalars['Bytes']>;
  sender_in?: InputMaybe<Array<Scalars['Bytes']>>;
  sender_lt?: InputMaybe<Scalars['Bytes']>;
  sender_lte?: InputMaybe<Scalars['Bytes']>;
  sender_not?: InputMaybe<Scalars['Bytes']>;
  sender_not_contains?: InputMaybe<Scalars['Bytes']>;
  sender_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum RoleGrantedEvent_OrderBy {
  Account = 'account',
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Role = 'role',
  Sender = 'sender',
  Timestamp = 'timestamp',
  TransactionHash = 'transactionHash'
}

export type RoleRevokedEvent = Event & {
  __typename?: 'RoleRevokedEvent';
  account: Scalars['Bytes'];
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  role: Scalars['Bytes'];
  sender: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
};

export type RoleRevokedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['Bytes']>;
  account_contains?: InputMaybe<Scalars['Bytes']>;
  account_gt?: InputMaybe<Scalars['Bytes']>;
  account_gte?: InputMaybe<Scalars['Bytes']>;
  account_in?: InputMaybe<Array<Scalars['Bytes']>>;
  account_lt?: InputMaybe<Scalars['Bytes']>;
  account_lte?: InputMaybe<Scalars['Bytes']>;
  account_not?: InputMaybe<Scalars['Bytes']>;
  account_not_contains?: InputMaybe<Scalars['Bytes']>;
  account_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<RoleRevokedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<RoleRevokedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  role?: InputMaybe<Scalars['Bytes']>;
  role_contains?: InputMaybe<Scalars['Bytes']>;
  role_gt?: InputMaybe<Scalars['Bytes']>;
  role_gte?: InputMaybe<Scalars['Bytes']>;
  role_in?: InputMaybe<Array<Scalars['Bytes']>>;
  role_lt?: InputMaybe<Scalars['Bytes']>;
  role_lte?: InputMaybe<Scalars['Bytes']>;
  role_not?: InputMaybe<Scalars['Bytes']>;
  role_not_contains?: InputMaybe<Scalars['Bytes']>;
  role_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  sender?: InputMaybe<Scalars['Bytes']>;
  sender_contains?: InputMaybe<Scalars['Bytes']>;
  sender_gt?: InputMaybe<Scalars['Bytes']>;
  sender_gte?: InputMaybe<Scalars['Bytes']>;
  sender_in?: InputMaybe<Array<Scalars['Bytes']>>;
  sender_lt?: InputMaybe<Scalars['Bytes']>;
  sender_lte?: InputMaybe<Scalars['Bytes']>;
  sender_not?: InputMaybe<Scalars['Bytes']>;
  sender_not_contains?: InputMaybe<Scalars['Bytes']>;
  sender_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum RoleRevokedEvent_OrderBy {
  Account = 'account',
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Role = 'role',
  Sender = 'sender',
  Timestamp = 'timestamp',
  TransactionHash = 'transactionHash'
}

export type SfMeta = {
  __typename?: 'SFMeta';
  blockNumber: Scalars['BigInt'];
  /**
   * The branch the current deployment is coming from.
   *
   */
  branch: Scalars['String'];
  /**
   * Whether the branch is feature/dev/v1.
   *
   */
  configuration: Scalars['String'];
  /**
   * The id is the commit hash.
   *
   */
  id: Scalars['ID'];
  timestamp: Scalars['BigInt'];
};

export type SfMeta_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<SfMeta_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  branch?: InputMaybe<Scalars['String']>;
  branch_contains?: InputMaybe<Scalars['String']>;
  branch_contains_nocase?: InputMaybe<Scalars['String']>;
  branch_ends_with?: InputMaybe<Scalars['String']>;
  branch_ends_with_nocase?: InputMaybe<Scalars['String']>;
  branch_gt?: InputMaybe<Scalars['String']>;
  branch_gte?: InputMaybe<Scalars['String']>;
  branch_in?: InputMaybe<Array<Scalars['String']>>;
  branch_lt?: InputMaybe<Scalars['String']>;
  branch_lte?: InputMaybe<Scalars['String']>;
  branch_not?: InputMaybe<Scalars['String']>;
  branch_not_contains?: InputMaybe<Scalars['String']>;
  branch_not_contains_nocase?: InputMaybe<Scalars['String']>;
  branch_not_ends_with?: InputMaybe<Scalars['String']>;
  branch_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  branch_not_in?: InputMaybe<Array<Scalars['String']>>;
  branch_not_starts_with?: InputMaybe<Scalars['String']>;
  branch_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  branch_starts_with?: InputMaybe<Scalars['String']>;
  branch_starts_with_nocase?: InputMaybe<Scalars['String']>;
  configuration?: InputMaybe<Scalars['String']>;
  configuration_contains?: InputMaybe<Scalars['String']>;
  configuration_contains_nocase?: InputMaybe<Scalars['String']>;
  configuration_ends_with?: InputMaybe<Scalars['String']>;
  configuration_ends_with_nocase?: InputMaybe<Scalars['String']>;
  configuration_gt?: InputMaybe<Scalars['String']>;
  configuration_gte?: InputMaybe<Scalars['String']>;
  configuration_in?: InputMaybe<Array<Scalars['String']>>;
  configuration_lt?: InputMaybe<Scalars['String']>;
  configuration_lte?: InputMaybe<Scalars['String']>;
  configuration_not?: InputMaybe<Scalars['String']>;
  configuration_not_contains?: InputMaybe<Scalars['String']>;
  configuration_not_contains_nocase?: InputMaybe<Scalars['String']>;
  configuration_not_ends_with?: InputMaybe<Scalars['String']>;
  configuration_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  configuration_not_in?: InputMaybe<Array<Scalars['String']>>;
  configuration_not_starts_with?: InputMaybe<Scalars['String']>;
  configuration_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  configuration_starts_with?: InputMaybe<Scalars['String']>;
  configuration_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  or?: InputMaybe<Array<InputMaybe<SfMeta_Filter>>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum SfMeta_OrderBy {
  BlockNumber = 'blockNumber',
  Branch = 'branch',
  Configuration = 'configuration',
  Id = 'id',
  Timestamp = 'timestamp'
}

/** The gated publication access criteria scalar operators */
export enum ScalarOperator {
  Equal = 'EQUAL',
  GreaterThan = 'GREATER_THAN',
  GreaterThanOrEqual = 'GREATER_THAN_OR_EQUAL',
  LessThan = 'LESS_THAN',
  LessThanOrEqual = 'LESS_THAN_OR_EQUAL',
  NotEqual = 'NOT_EQUAL'
}

export type SearchQueryRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  customFilters?: InputMaybe<Array<CustomFiltersTypes>>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  /** The search term */
  query: Scalars['Search'];
  /** The App Id */
  sources?: InputMaybe<Array<Scalars['Sources']>>;
  type: SearchRequestTypes;
};

/** Search request types */
export enum SearchRequestTypes {
  Profile = 'PROFILE',
  Publication = 'PUBLICATION'
}

export type SearchResult = ProfileSearchResult | PublicationSearchResult;

export type SensitiveReasonInputParams = {
  reason: PublicationReportingReason;
  subreason: PublicationReportingSensitiveSubreason;
};

export type SentEvent = Event & {
  __typename?: 'SentEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `operator`
   * addresses[2] = `from`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  amount: Scalars['BigInt'];
  blockNumber: Scalars['BigInt'];
  data: Scalars['Bytes'];
  from: Scalars['Bytes'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  operator: Scalars['Bytes'];
  operatorData: Scalars['Bytes'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  to: Scalars['Bytes'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
};

export type SentEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  and?: InputMaybe<Array<InputMaybe<SentEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  data?: InputMaybe<Scalars['Bytes']>;
  data_contains?: InputMaybe<Scalars['Bytes']>;
  data_gt?: InputMaybe<Scalars['Bytes']>;
  data_gte?: InputMaybe<Scalars['Bytes']>;
  data_in?: InputMaybe<Array<Scalars['Bytes']>>;
  data_lt?: InputMaybe<Scalars['Bytes']>;
  data_lte?: InputMaybe<Scalars['Bytes']>;
  data_not?: InputMaybe<Scalars['Bytes']>;
  data_not_contains?: InputMaybe<Scalars['Bytes']>;
  data_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  from?: InputMaybe<Scalars['Bytes']>;
  from_contains?: InputMaybe<Scalars['Bytes']>;
  from_gt?: InputMaybe<Scalars['Bytes']>;
  from_gte?: InputMaybe<Scalars['Bytes']>;
  from_in?: InputMaybe<Array<Scalars['Bytes']>>;
  from_lt?: InputMaybe<Scalars['Bytes']>;
  from_lte?: InputMaybe<Scalars['Bytes']>;
  from_not?: InputMaybe<Scalars['Bytes']>;
  from_not_contains?: InputMaybe<Scalars['Bytes']>;
  from_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  operator?: InputMaybe<Scalars['Bytes']>;
  operatorData?: InputMaybe<Scalars['Bytes']>;
  operatorData_contains?: InputMaybe<Scalars['Bytes']>;
  operatorData_gt?: InputMaybe<Scalars['Bytes']>;
  operatorData_gte?: InputMaybe<Scalars['Bytes']>;
  operatorData_in?: InputMaybe<Array<Scalars['Bytes']>>;
  operatorData_lt?: InputMaybe<Scalars['Bytes']>;
  operatorData_lte?: InputMaybe<Scalars['Bytes']>;
  operatorData_not?: InputMaybe<Scalars['Bytes']>;
  operatorData_not_contains?: InputMaybe<Scalars['Bytes']>;
  operatorData_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  operator_contains?: InputMaybe<Scalars['Bytes']>;
  operator_gt?: InputMaybe<Scalars['Bytes']>;
  operator_gte?: InputMaybe<Scalars['Bytes']>;
  operator_in?: InputMaybe<Array<Scalars['Bytes']>>;
  operator_lt?: InputMaybe<Scalars['Bytes']>;
  operator_lte?: InputMaybe<Scalars['Bytes']>;
  operator_not?: InputMaybe<Scalars['Bytes']>;
  operator_not_contains?: InputMaybe<Scalars['Bytes']>;
  operator_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  or?: InputMaybe<Array<InputMaybe<SentEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  to?: InputMaybe<Scalars['Bytes']>;
  to_contains?: InputMaybe<Scalars['Bytes']>;
  to_gt?: InputMaybe<Scalars['Bytes']>;
  to_gte?: InputMaybe<Scalars['Bytes']>;
  to_in?: InputMaybe<Array<Scalars['Bytes']>>;
  to_lt?: InputMaybe<Scalars['Bytes']>;
  to_lte?: InputMaybe<Scalars['Bytes']>;
  to_not?: InputMaybe<Scalars['Bytes']>;
  to_not_contains?: InputMaybe<Scalars['Bytes']>;
  to_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum SentEvent_OrderBy {
  Addresses = 'addresses',
  Amount = 'amount',
  BlockNumber = 'blockNumber',
  Data = 'data',
  From = 'from',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Operator = 'operator',
  OperatorData = 'operatorData',
  Order = 'order',
  Timestamp = 'timestamp',
  To = 'to',
  Token = 'token',
  TransactionHash = 'transactionHash'
}

/** The broadcast item */
export type SetDefaultProfileBroadcastItemResult = {
  __typename?: 'SetDefaultProfileBroadcastItemResult';
  /** The date the broadcast item expiries */
  expiresAt: Scalars['DateTime'];
  /** This broadcast item ID */
  id: Scalars['BroadcastId'];
  /** The typed data */
  typedData: SetDefaultProfileEip712TypedData;
};

/** The default profile eip 712 typed data */
export type SetDefaultProfileEip712TypedData = {
  __typename?: 'SetDefaultProfileEIP712TypedData';
  /** The typed data domain */
  domain: Eip712TypedDataDomain;
  /** The types */
  types: SetDefaultProfileEip712TypedDataTypes;
  /** The values */
  value: SetDefaultProfileEip712TypedDataValue;
};

/** The default profile eip 712 typed data types */
export type SetDefaultProfileEip712TypedDataTypes = {
  __typename?: 'SetDefaultProfileEIP712TypedDataTypes';
  SetDefaultProfileWithSig: Array<Eip712TypedDataField>;
};

/** The default profile eip 712 typed data value */
export type SetDefaultProfileEip712TypedDataValue = {
  __typename?: 'SetDefaultProfileEIP712TypedDataValue';
  deadline: Scalars['UnixTimestamp'];
  nonce: Scalars['Nonce'];
  profileId: Scalars['ProfileId'];
  wallet: Scalars['EthereumAddress'];
};

export type SetDispatcherRequest = {
  /** The dispatcher address - they can post, comment, mirror, set follow module, change your profile picture on your behalf, if left as none it will use the built in dispatcher address. */
  dispatcher?: InputMaybe<Scalars['EthereumAddress']>;
  /** If you want to enable or disable it */
  enable?: InputMaybe<Scalars['Boolean']>;
  /** The profile id */
  profileId: Scalars['ProfileId'];
};

export type SetEvent = Event & {
  __typename?: 'SetEvent';
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  /**
   * Because the name property is indexed, the
   * returned value will be a keccak256 hash
   * of the string.
   *
   */
  hashedName: Scalars['Bytes'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  resolverEntry: ResolverEntry;
  target: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
};

export type SetEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<SetEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  hashedName?: InputMaybe<Scalars['Bytes']>;
  hashedName_contains?: InputMaybe<Scalars['Bytes']>;
  hashedName_gt?: InputMaybe<Scalars['Bytes']>;
  hashedName_gte?: InputMaybe<Scalars['Bytes']>;
  hashedName_in?: InputMaybe<Array<Scalars['Bytes']>>;
  hashedName_lt?: InputMaybe<Scalars['Bytes']>;
  hashedName_lte?: InputMaybe<Scalars['Bytes']>;
  hashedName_not?: InputMaybe<Scalars['Bytes']>;
  hashedName_not_contains?: InputMaybe<Scalars['Bytes']>;
  hashedName_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<SetEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  resolverEntry?: InputMaybe<Scalars['String']>;
  resolverEntry_?: InputMaybe<ResolverEntry_Filter>;
  resolverEntry_contains?: InputMaybe<Scalars['String']>;
  resolverEntry_contains_nocase?: InputMaybe<Scalars['String']>;
  resolverEntry_ends_with?: InputMaybe<Scalars['String']>;
  resolverEntry_ends_with_nocase?: InputMaybe<Scalars['String']>;
  resolverEntry_gt?: InputMaybe<Scalars['String']>;
  resolverEntry_gte?: InputMaybe<Scalars['String']>;
  resolverEntry_in?: InputMaybe<Array<Scalars['String']>>;
  resolverEntry_lt?: InputMaybe<Scalars['String']>;
  resolverEntry_lte?: InputMaybe<Scalars['String']>;
  resolverEntry_not?: InputMaybe<Scalars['String']>;
  resolverEntry_not_contains?: InputMaybe<Scalars['String']>;
  resolverEntry_not_contains_nocase?: InputMaybe<Scalars['String']>;
  resolverEntry_not_ends_with?: InputMaybe<Scalars['String']>;
  resolverEntry_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  resolverEntry_not_in?: InputMaybe<Array<Scalars['String']>>;
  resolverEntry_not_starts_with?: InputMaybe<Scalars['String']>;
  resolverEntry_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  resolverEntry_starts_with?: InputMaybe<Scalars['String']>;
  resolverEntry_starts_with_nocase?: InputMaybe<Scalars['String']>;
  target?: InputMaybe<Scalars['Bytes']>;
  target_contains?: InputMaybe<Scalars['Bytes']>;
  target_gt?: InputMaybe<Scalars['Bytes']>;
  target_gte?: InputMaybe<Scalars['Bytes']>;
  target_in?: InputMaybe<Array<Scalars['Bytes']>>;
  target_lt?: InputMaybe<Scalars['Bytes']>;
  target_lte?: InputMaybe<Scalars['Bytes']>;
  target_not?: InputMaybe<Scalars['Bytes']>;
  target_not_contains?: InputMaybe<Scalars['Bytes']>;
  target_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum SetEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  HashedName = 'hashedName',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  ResolverEntry = 'resolverEntry',
  ResolverEntryCreatedAtBlockNumber = 'resolverEntry__createdAtBlockNumber',
  ResolverEntryCreatedAtTimestamp = 'resolverEntry__createdAtTimestamp',
  ResolverEntryId = 'resolverEntry__id',
  ResolverEntryIsListed = 'resolverEntry__isListed',
  ResolverEntryIsToken = 'resolverEntry__isToken',
  ResolverEntryTargetAddress = 'resolverEntry__targetAddress',
  ResolverEntryUpdatedAtBlockNumber = 'resolverEntry__updatedAtBlockNumber',
  ResolverEntryUpdatedAtTimestamp = 'resolverEntry__updatedAtTimestamp',
  Target = 'target',
  Timestamp = 'timestamp',
  TransactionHash = 'transactionHash'
}

/** The signed auth challenge */
export type SignedAuthChallenge = {
  /** The ethereum address you signed the signature with */
  address: Scalars['EthereumAddress'];
  /** The signature */
  signature: Scalars['Signature'];
};

export type SimpleCollectModuleParams = {
  /** The collect module limit */
  collectLimit?: InputMaybe<Scalars['String']>;
  /** The timestamp that this collect module will expire */
  endTimestamp?: InputMaybe<Scalars['DateTime']>;
  /** The collect module fee params */
  fee?: InputMaybe<ModuleFeeParams>;
  /** Collectible by followers only */
  followerOnly: Scalars['Boolean'];
};

export type SimpleCollectModuleSettings = {
  __typename?: 'SimpleCollectModuleSettings';
  /** The maximum number of collects for this publication. 0 for no limit. */
  collectLimit?: Maybe<Scalars['String']>;
  contractAddress: Scalars['ContractAddress'];
  /** The end timestamp after which collecting is impossible. 0 for no expiry. */
  endTimestamp?: Maybe<Scalars['DateTime']>;
  /** The collect module fee params */
  fee?: Maybe<ModuleFee>;
  /** True if only followers of publisher may collect the post. */
  followerOnly: Scalars['Boolean'];
  /** The collect modules enum */
  type: CollectModules;
};

export type SingleProfileQueryRequest = {
  /** The handle for the profile */
  handle?: InputMaybe<Scalars['Handle']>;
  /** The profile id */
  profileId?: InputMaybe<Scalars['ProfileId']>;
};

export type SpamReasonInputParams = {
  reason: PublicationReportingReason;
  subreason: PublicationReportingSpamSubreason;
};

/**
 * Stream: A higher order entity that represents the lifetime of a stream between a `sender` and a `receiver`.
 * A account can start a stream, update the flow rate, but when they close it, it is considered "dead".
 * The next stream you create with the same `sender` and `receiver` will create a new stream entity.
 * Therefore, multiple stream entities can be created between the same `sender` and `receiver`.
 *
 */
export type Stream = {
  __typename?: 'Stream';
  createdAtBlockNumber: Scalars['BigInt'];
  createdAtTimestamp: Scalars['BigInt'];
  currentFlowRate: Scalars['BigInt'];
  deposit: Scalars['BigInt'];
  flowUpdatedEvents: Array<FlowUpdatedEvent>;
  /**
   * ID composed of: senderAddress-receiverAddress-tokenAddress-revisionIndex
   *
   */
  id: Scalars['ID'];
  receiver: Account;
  sender: Account;
  streamPeriods: Array<StreamPeriod>;
  /**
   * The amount streamed until `updatedAtTimestamp`/`updatedAtBlock`.
   * The formula to get the current streamed amount is:
   * `streamedUntilUpdatedAt + ((currentTime in seconds) - updatedAtTimestamp) * currentFlowRate`.
   *
   */
  streamedUntilUpdatedAt: Scalars['BigInt'];
  token: Token;
  updatedAtBlockNumber: Scalars['BigInt'];
  updatedAtTimestamp: Scalars['BigInt'];
  /**
   * The `userData` stored on the Stream is the last `userData` that was set in a `FlowUpdatedEvent`,
   * for this particular stream. To see the historical `userData` for this stream, you can query the `flowUpdatedEvents` field.
   *
   */
  userData: Scalars['Bytes'];
};


/**
 * Stream: A higher order entity that represents the lifetime of a stream between a `sender` and a `receiver`.
 * A account can start a stream, update the flow rate, but when they close it, it is considered "dead".
 * The next stream you create with the same `sender` and `receiver` will create a new stream entity.
 * Therefore, multiple stream entities can be created between the same `sender` and `receiver`.
 *
 */
export type StreamFlowUpdatedEventsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<FlowUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<FlowUpdatedEvent_Filter>;
};


/**
 * Stream: A higher order entity that represents the lifetime of a stream between a `sender` and a `receiver`.
 * A account can start a stream, update the flow rate, but when they close it, it is considered "dead".
 * The next stream you create with the same `sender` and `receiver` will create a new stream entity.
 * Therefore, multiple stream entities can be created between the same `sender` and `receiver`.
 *
 */
export type StreamStreamPeriodsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StreamPeriod_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<StreamPeriod_Filter>;
};

/**
 * StreamPeriod: A higher order entity that represents a period of time in a Stream with a constant flowRate.
 *
 */
export type StreamPeriod = {
  __typename?: 'StreamPeriod';
  deposit: Scalars['BigInt'];
  flowRate: Scalars['BigInt'];
  /**
   * ID composed of: streamId - periodRevisionIndex
   *
   */
  id: Scalars['ID'];
  receiver: Account;
  sender: Account;
  startedAtBlockNumber: Scalars['BigInt'];
  startedAtEvent: FlowUpdatedEvent;
  startedAtTimestamp: Scalars['BigInt'];
  stoppedAtBlockNumber?: Maybe<Scalars['BigInt']>;
  stoppedAtEvent?: Maybe<FlowUpdatedEvent>;
  /**
   * Following values are null until the StreamPeriod is terminated
   *
   */
  stoppedAtTimestamp?: Maybe<Scalars['BigInt']>;
  stream: Stream;
  token: Token;
  totalAmountStreamed?: Maybe<Scalars['BigInt']>;
};

export type StreamPeriod_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<StreamPeriod_Filter>>>;
  deposit?: InputMaybe<Scalars['BigInt']>;
  deposit_gt?: InputMaybe<Scalars['BigInt']>;
  deposit_gte?: InputMaybe<Scalars['BigInt']>;
  deposit_in?: InputMaybe<Array<Scalars['BigInt']>>;
  deposit_lt?: InputMaybe<Scalars['BigInt']>;
  deposit_lte?: InputMaybe<Scalars['BigInt']>;
  deposit_not?: InputMaybe<Scalars['BigInt']>;
  deposit_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  flowRate?: InputMaybe<Scalars['BigInt']>;
  flowRate_gt?: InputMaybe<Scalars['BigInt']>;
  flowRate_gte?: InputMaybe<Scalars['BigInt']>;
  flowRate_in?: InputMaybe<Array<Scalars['BigInt']>>;
  flowRate_lt?: InputMaybe<Scalars['BigInt']>;
  flowRate_lte?: InputMaybe<Scalars['BigInt']>;
  flowRate_not?: InputMaybe<Scalars['BigInt']>;
  flowRate_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  or?: InputMaybe<Array<InputMaybe<StreamPeriod_Filter>>>;
  receiver?: InputMaybe<Scalars['String']>;
  receiver_?: InputMaybe<Account_Filter>;
  receiver_contains?: InputMaybe<Scalars['String']>;
  receiver_contains_nocase?: InputMaybe<Scalars['String']>;
  receiver_ends_with?: InputMaybe<Scalars['String']>;
  receiver_ends_with_nocase?: InputMaybe<Scalars['String']>;
  receiver_gt?: InputMaybe<Scalars['String']>;
  receiver_gte?: InputMaybe<Scalars['String']>;
  receiver_in?: InputMaybe<Array<Scalars['String']>>;
  receiver_lt?: InputMaybe<Scalars['String']>;
  receiver_lte?: InputMaybe<Scalars['String']>;
  receiver_not?: InputMaybe<Scalars['String']>;
  receiver_not_contains?: InputMaybe<Scalars['String']>;
  receiver_not_contains_nocase?: InputMaybe<Scalars['String']>;
  receiver_not_ends_with?: InputMaybe<Scalars['String']>;
  receiver_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  receiver_not_in?: InputMaybe<Array<Scalars['String']>>;
  receiver_not_starts_with?: InputMaybe<Scalars['String']>;
  receiver_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  receiver_starts_with?: InputMaybe<Scalars['String']>;
  receiver_starts_with_nocase?: InputMaybe<Scalars['String']>;
  sender?: InputMaybe<Scalars['String']>;
  sender_?: InputMaybe<Account_Filter>;
  sender_contains?: InputMaybe<Scalars['String']>;
  sender_contains_nocase?: InputMaybe<Scalars['String']>;
  sender_ends_with?: InputMaybe<Scalars['String']>;
  sender_ends_with_nocase?: InputMaybe<Scalars['String']>;
  sender_gt?: InputMaybe<Scalars['String']>;
  sender_gte?: InputMaybe<Scalars['String']>;
  sender_in?: InputMaybe<Array<Scalars['String']>>;
  sender_lt?: InputMaybe<Scalars['String']>;
  sender_lte?: InputMaybe<Scalars['String']>;
  sender_not?: InputMaybe<Scalars['String']>;
  sender_not_contains?: InputMaybe<Scalars['String']>;
  sender_not_contains_nocase?: InputMaybe<Scalars['String']>;
  sender_not_ends_with?: InputMaybe<Scalars['String']>;
  sender_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  sender_not_in?: InputMaybe<Array<Scalars['String']>>;
  sender_not_starts_with?: InputMaybe<Scalars['String']>;
  sender_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  sender_starts_with?: InputMaybe<Scalars['String']>;
  sender_starts_with_nocase?: InputMaybe<Scalars['String']>;
  startedAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  startedAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  startedAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  startedAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  startedAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  startedAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  startedAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  startedAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  startedAtEvent?: InputMaybe<Scalars['String']>;
  startedAtEvent_?: InputMaybe<FlowUpdatedEvent_Filter>;
  startedAtEvent_contains?: InputMaybe<Scalars['String']>;
  startedAtEvent_contains_nocase?: InputMaybe<Scalars['String']>;
  startedAtEvent_ends_with?: InputMaybe<Scalars['String']>;
  startedAtEvent_ends_with_nocase?: InputMaybe<Scalars['String']>;
  startedAtEvent_gt?: InputMaybe<Scalars['String']>;
  startedAtEvent_gte?: InputMaybe<Scalars['String']>;
  startedAtEvent_in?: InputMaybe<Array<Scalars['String']>>;
  startedAtEvent_lt?: InputMaybe<Scalars['String']>;
  startedAtEvent_lte?: InputMaybe<Scalars['String']>;
  startedAtEvent_not?: InputMaybe<Scalars['String']>;
  startedAtEvent_not_contains?: InputMaybe<Scalars['String']>;
  startedAtEvent_not_contains_nocase?: InputMaybe<Scalars['String']>;
  startedAtEvent_not_ends_with?: InputMaybe<Scalars['String']>;
  startedAtEvent_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  startedAtEvent_not_in?: InputMaybe<Array<Scalars['String']>>;
  startedAtEvent_not_starts_with?: InputMaybe<Scalars['String']>;
  startedAtEvent_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  startedAtEvent_starts_with?: InputMaybe<Scalars['String']>;
  startedAtEvent_starts_with_nocase?: InputMaybe<Scalars['String']>;
  startedAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  startedAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  startedAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  startedAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  startedAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  startedAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  startedAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  startedAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  stoppedAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  stoppedAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  stoppedAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  stoppedAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  stoppedAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  stoppedAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  stoppedAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  stoppedAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  stoppedAtEvent?: InputMaybe<Scalars['String']>;
  stoppedAtEvent_?: InputMaybe<FlowUpdatedEvent_Filter>;
  stoppedAtEvent_contains?: InputMaybe<Scalars['String']>;
  stoppedAtEvent_contains_nocase?: InputMaybe<Scalars['String']>;
  stoppedAtEvent_ends_with?: InputMaybe<Scalars['String']>;
  stoppedAtEvent_ends_with_nocase?: InputMaybe<Scalars['String']>;
  stoppedAtEvent_gt?: InputMaybe<Scalars['String']>;
  stoppedAtEvent_gte?: InputMaybe<Scalars['String']>;
  stoppedAtEvent_in?: InputMaybe<Array<Scalars['String']>>;
  stoppedAtEvent_lt?: InputMaybe<Scalars['String']>;
  stoppedAtEvent_lte?: InputMaybe<Scalars['String']>;
  stoppedAtEvent_not?: InputMaybe<Scalars['String']>;
  stoppedAtEvent_not_contains?: InputMaybe<Scalars['String']>;
  stoppedAtEvent_not_contains_nocase?: InputMaybe<Scalars['String']>;
  stoppedAtEvent_not_ends_with?: InputMaybe<Scalars['String']>;
  stoppedAtEvent_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  stoppedAtEvent_not_in?: InputMaybe<Array<Scalars['String']>>;
  stoppedAtEvent_not_starts_with?: InputMaybe<Scalars['String']>;
  stoppedAtEvent_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  stoppedAtEvent_starts_with?: InputMaybe<Scalars['String']>;
  stoppedAtEvent_starts_with_nocase?: InputMaybe<Scalars['String']>;
  stoppedAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  stoppedAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  stoppedAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  stoppedAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  stoppedAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  stoppedAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  stoppedAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  stoppedAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  stream?: InputMaybe<Scalars['String']>;
  stream_?: InputMaybe<Stream_Filter>;
  stream_contains?: InputMaybe<Scalars['String']>;
  stream_contains_nocase?: InputMaybe<Scalars['String']>;
  stream_ends_with?: InputMaybe<Scalars['String']>;
  stream_ends_with_nocase?: InputMaybe<Scalars['String']>;
  stream_gt?: InputMaybe<Scalars['String']>;
  stream_gte?: InputMaybe<Scalars['String']>;
  stream_in?: InputMaybe<Array<Scalars['String']>>;
  stream_lt?: InputMaybe<Scalars['String']>;
  stream_lte?: InputMaybe<Scalars['String']>;
  stream_not?: InputMaybe<Scalars['String']>;
  stream_not_contains?: InputMaybe<Scalars['String']>;
  stream_not_contains_nocase?: InputMaybe<Scalars['String']>;
  stream_not_ends_with?: InputMaybe<Scalars['String']>;
  stream_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  stream_not_in?: InputMaybe<Array<Scalars['String']>>;
  stream_not_starts_with?: InputMaybe<Scalars['String']>;
  stream_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  stream_starts_with?: InputMaybe<Scalars['String']>;
  stream_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  totalAmountStreamed?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamed_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamed_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountStreamed_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamed_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamed_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum StreamPeriod_OrderBy {
  Deposit = 'deposit',
  FlowRate = 'flowRate',
  Id = 'id',
  Receiver = 'receiver',
  ReceiverCreatedAtBlockNumber = 'receiver__createdAtBlockNumber',
  ReceiverCreatedAtTimestamp = 'receiver__createdAtTimestamp',
  ReceiverId = 'receiver__id',
  ReceiverIsSuperApp = 'receiver__isSuperApp',
  ReceiverUpdatedAtBlockNumber = 'receiver__updatedAtBlockNumber',
  ReceiverUpdatedAtTimestamp = 'receiver__updatedAtTimestamp',
  Sender = 'sender',
  SenderCreatedAtBlockNumber = 'sender__createdAtBlockNumber',
  SenderCreatedAtTimestamp = 'sender__createdAtTimestamp',
  SenderId = 'sender__id',
  SenderIsSuperApp = 'sender__isSuperApp',
  SenderUpdatedAtBlockNumber = 'sender__updatedAtBlockNumber',
  SenderUpdatedAtTimestamp = 'sender__updatedAtTimestamp',
  StartedAtBlockNumber = 'startedAtBlockNumber',
  StartedAtEvent = 'startedAtEvent',
  StartedAtEventBlockNumber = 'startedAtEvent__blockNumber',
  StartedAtEventDeposit = 'startedAtEvent__deposit',
  StartedAtEventFlowOperator = 'startedAtEvent__flowOperator',
  StartedAtEventFlowRate = 'startedAtEvent__flowRate',
  StartedAtEventGasPrice = 'startedAtEvent__gasPrice',
  StartedAtEventGasUsed = 'startedAtEvent__gasUsed',
  StartedAtEventId = 'startedAtEvent__id',
  StartedAtEventLogIndex = 'startedAtEvent__logIndex',
  StartedAtEventName = 'startedAtEvent__name',
  StartedAtEventOldFlowRate = 'startedAtEvent__oldFlowRate',
  StartedAtEventOrder = 'startedAtEvent__order',
  StartedAtEventReceiver = 'startedAtEvent__receiver',
  StartedAtEventSender = 'startedAtEvent__sender',
  StartedAtEventTimestamp = 'startedAtEvent__timestamp',
  StartedAtEventToken = 'startedAtEvent__token',
  StartedAtEventTotalAmountStreamedUntilTimestamp = 'startedAtEvent__totalAmountStreamedUntilTimestamp',
  StartedAtEventTotalReceiverFlowRate = 'startedAtEvent__totalReceiverFlowRate',
  StartedAtEventTotalSenderFlowRate = 'startedAtEvent__totalSenderFlowRate',
  StartedAtEventTransactionHash = 'startedAtEvent__transactionHash',
  StartedAtEventType = 'startedAtEvent__type',
  StartedAtEventUserData = 'startedAtEvent__userData',
  StartedAtTimestamp = 'startedAtTimestamp',
  StoppedAtBlockNumber = 'stoppedAtBlockNumber',
  StoppedAtEvent = 'stoppedAtEvent',
  StoppedAtEventBlockNumber = 'stoppedAtEvent__blockNumber',
  StoppedAtEventDeposit = 'stoppedAtEvent__deposit',
  StoppedAtEventFlowOperator = 'stoppedAtEvent__flowOperator',
  StoppedAtEventFlowRate = 'stoppedAtEvent__flowRate',
  StoppedAtEventGasPrice = 'stoppedAtEvent__gasPrice',
  StoppedAtEventGasUsed = 'stoppedAtEvent__gasUsed',
  StoppedAtEventId = 'stoppedAtEvent__id',
  StoppedAtEventLogIndex = 'stoppedAtEvent__logIndex',
  StoppedAtEventName = 'stoppedAtEvent__name',
  StoppedAtEventOldFlowRate = 'stoppedAtEvent__oldFlowRate',
  StoppedAtEventOrder = 'stoppedAtEvent__order',
  StoppedAtEventReceiver = 'stoppedAtEvent__receiver',
  StoppedAtEventSender = 'stoppedAtEvent__sender',
  StoppedAtEventTimestamp = 'stoppedAtEvent__timestamp',
  StoppedAtEventToken = 'stoppedAtEvent__token',
  StoppedAtEventTotalAmountStreamedUntilTimestamp = 'stoppedAtEvent__totalAmountStreamedUntilTimestamp',
  StoppedAtEventTotalReceiverFlowRate = 'stoppedAtEvent__totalReceiverFlowRate',
  StoppedAtEventTotalSenderFlowRate = 'stoppedAtEvent__totalSenderFlowRate',
  StoppedAtEventTransactionHash = 'stoppedAtEvent__transactionHash',
  StoppedAtEventType = 'stoppedAtEvent__type',
  StoppedAtEventUserData = 'stoppedAtEvent__userData',
  StoppedAtTimestamp = 'stoppedAtTimestamp',
  Stream = 'stream',
  StreamCreatedAtBlockNumber = 'stream__createdAtBlockNumber',
  StreamCreatedAtTimestamp = 'stream__createdAtTimestamp',
  StreamCurrentFlowRate = 'stream__currentFlowRate',
  StreamDeposit = 'stream__deposit',
  StreamId = 'stream__id',
  StreamStreamedUntilUpdatedAt = 'stream__streamedUntilUpdatedAt',
  StreamUpdatedAtBlockNumber = 'stream__updatedAtBlockNumber',
  StreamUpdatedAtTimestamp = 'stream__updatedAtTimestamp',
  StreamUserData = 'stream__userData',
  Token = 'token',
  TokenCreatedAtBlockNumber = 'token__createdAtBlockNumber',
  TokenCreatedAtTimestamp = 'token__createdAtTimestamp',
  TokenDecimals = 'token__decimals',
  TokenId = 'token__id',
  TokenIsListed = 'token__isListed',
  TokenIsNativeAssetSuperToken = 'token__isNativeAssetSuperToken',
  TokenIsSuperToken = 'token__isSuperToken',
  TokenName = 'token__name',
  TokenSymbol = 'token__symbol',
  TokenUnderlyingAddress = 'token__underlyingAddress',
  TotalAmountStreamed = 'totalAmountStreamed'
}

export type StreamRevision = {
  __typename?: 'StreamRevision';
  /**
   * ID composed of: keccak256(abi.encode(sender,receiver))-tokenAddress
   *
   */
  id: Scalars['ID'];
  /**
   * The "most recently alive" stream between a sender and receiver.
   * Note: The `revisionIndex` property may not be the same as the `revisionIndex` of `mostRecentStream`. Which means `mostRecentStream` has been closed and no new stream has been opened.
   *
   */
  mostRecentStream: Stream;
  periodRevisionIndex: Scalars['Int'];
  revisionIndex: Scalars['Int'];
};

export type StreamRevision_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<StreamRevision_Filter>>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  mostRecentStream?: InputMaybe<Scalars['String']>;
  mostRecentStream_?: InputMaybe<Stream_Filter>;
  mostRecentStream_contains?: InputMaybe<Scalars['String']>;
  mostRecentStream_contains_nocase?: InputMaybe<Scalars['String']>;
  mostRecentStream_ends_with?: InputMaybe<Scalars['String']>;
  mostRecentStream_ends_with_nocase?: InputMaybe<Scalars['String']>;
  mostRecentStream_gt?: InputMaybe<Scalars['String']>;
  mostRecentStream_gte?: InputMaybe<Scalars['String']>;
  mostRecentStream_in?: InputMaybe<Array<Scalars['String']>>;
  mostRecentStream_lt?: InputMaybe<Scalars['String']>;
  mostRecentStream_lte?: InputMaybe<Scalars['String']>;
  mostRecentStream_not?: InputMaybe<Scalars['String']>;
  mostRecentStream_not_contains?: InputMaybe<Scalars['String']>;
  mostRecentStream_not_contains_nocase?: InputMaybe<Scalars['String']>;
  mostRecentStream_not_ends_with?: InputMaybe<Scalars['String']>;
  mostRecentStream_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  mostRecentStream_not_in?: InputMaybe<Array<Scalars['String']>>;
  mostRecentStream_not_starts_with?: InputMaybe<Scalars['String']>;
  mostRecentStream_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  mostRecentStream_starts_with?: InputMaybe<Scalars['String']>;
  mostRecentStream_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<StreamRevision_Filter>>>;
  periodRevisionIndex?: InputMaybe<Scalars['Int']>;
  periodRevisionIndex_gt?: InputMaybe<Scalars['Int']>;
  periodRevisionIndex_gte?: InputMaybe<Scalars['Int']>;
  periodRevisionIndex_in?: InputMaybe<Array<Scalars['Int']>>;
  periodRevisionIndex_lt?: InputMaybe<Scalars['Int']>;
  periodRevisionIndex_lte?: InputMaybe<Scalars['Int']>;
  periodRevisionIndex_not?: InputMaybe<Scalars['Int']>;
  periodRevisionIndex_not_in?: InputMaybe<Array<Scalars['Int']>>;
  revisionIndex?: InputMaybe<Scalars['Int']>;
  revisionIndex_gt?: InputMaybe<Scalars['Int']>;
  revisionIndex_gte?: InputMaybe<Scalars['Int']>;
  revisionIndex_in?: InputMaybe<Array<Scalars['Int']>>;
  revisionIndex_lt?: InputMaybe<Scalars['Int']>;
  revisionIndex_lte?: InputMaybe<Scalars['Int']>;
  revisionIndex_not?: InputMaybe<Scalars['Int']>;
  revisionIndex_not_in?: InputMaybe<Array<Scalars['Int']>>;
};

export enum StreamRevision_OrderBy {
  Id = 'id',
  MostRecentStream = 'mostRecentStream',
  MostRecentStreamCreatedAtBlockNumber = 'mostRecentStream__createdAtBlockNumber',
  MostRecentStreamCreatedAtTimestamp = 'mostRecentStream__createdAtTimestamp',
  MostRecentStreamCurrentFlowRate = 'mostRecentStream__currentFlowRate',
  MostRecentStreamDeposit = 'mostRecentStream__deposit',
  MostRecentStreamId = 'mostRecentStream__id',
  MostRecentStreamStreamedUntilUpdatedAt = 'mostRecentStream__streamedUntilUpdatedAt',
  MostRecentStreamUpdatedAtBlockNumber = 'mostRecentStream__updatedAtBlockNumber',
  MostRecentStreamUpdatedAtTimestamp = 'mostRecentStream__updatedAtTimestamp',
  MostRecentStreamUserData = 'mostRecentStream__userData',
  PeriodRevisionIndex = 'periodRevisionIndex',
  RevisionIndex = 'revisionIndex'
}

export type Stream_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Stream_Filter>>>;
  createdAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  currentFlowRate?: InputMaybe<Scalars['BigInt']>;
  currentFlowRate_gt?: InputMaybe<Scalars['BigInt']>;
  currentFlowRate_gte?: InputMaybe<Scalars['BigInt']>;
  currentFlowRate_in?: InputMaybe<Array<Scalars['BigInt']>>;
  currentFlowRate_lt?: InputMaybe<Scalars['BigInt']>;
  currentFlowRate_lte?: InputMaybe<Scalars['BigInt']>;
  currentFlowRate_not?: InputMaybe<Scalars['BigInt']>;
  currentFlowRate_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  deposit?: InputMaybe<Scalars['BigInt']>;
  deposit_gt?: InputMaybe<Scalars['BigInt']>;
  deposit_gte?: InputMaybe<Scalars['BigInt']>;
  deposit_in?: InputMaybe<Array<Scalars['BigInt']>>;
  deposit_lt?: InputMaybe<Scalars['BigInt']>;
  deposit_lte?: InputMaybe<Scalars['BigInt']>;
  deposit_not?: InputMaybe<Scalars['BigInt']>;
  deposit_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  flowUpdatedEvents_?: InputMaybe<FlowUpdatedEvent_Filter>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  or?: InputMaybe<Array<InputMaybe<Stream_Filter>>>;
  receiver?: InputMaybe<Scalars['String']>;
  receiver_?: InputMaybe<Account_Filter>;
  receiver_contains?: InputMaybe<Scalars['String']>;
  receiver_contains_nocase?: InputMaybe<Scalars['String']>;
  receiver_ends_with?: InputMaybe<Scalars['String']>;
  receiver_ends_with_nocase?: InputMaybe<Scalars['String']>;
  receiver_gt?: InputMaybe<Scalars['String']>;
  receiver_gte?: InputMaybe<Scalars['String']>;
  receiver_in?: InputMaybe<Array<Scalars['String']>>;
  receiver_lt?: InputMaybe<Scalars['String']>;
  receiver_lte?: InputMaybe<Scalars['String']>;
  receiver_not?: InputMaybe<Scalars['String']>;
  receiver_not_contains?: InputMaybe<Scalars['String']>;
  receiver_not_contains_nocase?: InputMaybe<Scalars['String']>;
  receiver_not_ends_with?: InputMaybe<Scalars['String']>;
  receiver_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  receiver_not_in?: InputMaybe<Array<Scalars['String']>>;
  receiver_not_starts_with?: InputMaybe<Scalars['String']>;
  receiver_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  receiver_starts_with?: InputMaybe<Scalars['String']>;
  receiver_starts_with_nocase?: InputMaybe<Scalars['String']>;
  sender?: InputMaybe<Scalars['String']>;
  sender_?: InputMaybe<Account_Filter>;
  sender_contains?: InputMaybe<Scalars['String']>;
  sender_contains_nocase?: InputMaybe<Scalars['String']>;
  sender_ends_with?: InputMaybe<Scalars['String']>;
  sender_ends_with_nocase?: InputMaybe<Scalars['String']>;
  sender_gt?: InputMaybe<Scalars['String']>;
  sender_gte?: InputMaybe<Scalars['String']>;
  sender_in?: InputMaybe<Array<Scalars['String']>>;
  sender_lt?: InputMaybe<Scalars['String']>;
  sender_lte?: InputMaybe<Scalars['String']>;
  sender_not?: InputMaybe<Scalars['String']>;
  sender_not_contains?: InputMaybe<Scalars['String']>;
  sender_not_contains_nocase?: InputMaybe<Scalars['String']>;
  sender_not_ends_with?: InputMaybe<Scalars['String']>;
  sender_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  sender_not_in?: InputMaybe<Array<Scalars['String']>>;
  sender_not_starts_with?: InputMaybe<Scalars['String']>;
  sender_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  sender_starts_with?: InputMaybe<Scalars['String']>;
  sender_starts_with_nocase?: InputMaybe<Scalars['String']>;
  streamPeriods_?: InputMaybe<StreamPeriod_Filter>;
  streamedUntilUpdatedAt?: InputMaybe<Scalars['BigInt']>;
  streamedUntilUpdatedAt_gt?: InputMaybe<Scalars['BigInt']>;
  streamedUntilUpdatedAt_gte?: InputMaybe<Scalars['BigInt']>;
  streamedUntilUpdatedAt_in?: InputMaybe<Array<Scalars['BigInt']>>;
  streamedUntilUpdatedAt_lt?: InputMaybe<Scalars['BigInt']>;
  streamedUntilUpdatedAt_lte?: InputMaybe<Scalars['BigInt']>;
  streamedUntilUpdatedAt_not?: InputMaybe<Scalars['BigInt']>;
  streamedUntilUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  updatedAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  userData?: InputMaybe<Scalars['Bytes']>;
  userData_contains?: InputMaybe<Scalars['Bytes']>;
  userData_gt?: InputMaybe<Scalars['Bytes']>;
  userData_gte?: InputMaybe<Scalars['Bytes']>;
  userData_in?: InputMaybe<Array<Scalars['Bytes']>>;
  userData_lt?: InputMaybe<Scalars['Bytes']>;
  userData_lte?: InputMaybe<Scalars['Bytes']>;
  userData_not?: InputMaybe<Scalars['Bytes']>;
  userData_not_contains?: InputMaybe<Scalars['Bytes']>;
  userData_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum Stream_OrderBy {
  CreatedAtBlockNumber = 'createdAtBlockNumber',
  CreatedAtTimestamp = 'createdAtTimestamp',
  CurrentFlowRate = 'currentFlowRate',
  Deposit = 'deposit',
  FlowUpdatedEvents = 'flowUpdatedEvents',
  Id = 'id',
  Receiver = 'receiver',
  ReceiverCreatedAtBlockNumber = 'receiver__createdAtBlockNumber',
  ReceiverCreatedAtTimestamp = 'receiver__createdAtTimestamp',
  ReceiverId = 'receiver__id',
  ReceiverIsSuperApp = 'receiver__isSuperApp',
  ReceiverUpdatedAtBlockNumber = 'receiver__updatedAtBlockNumber',
  ReceiverUpdatedAtTimestamp = 'receiver__updatedAtTimestamp',
  Sender = 'sender',
  SenderCreatedAtBlockNumber = 'sender__createdAtBlockNumber',
  SenderCreatedAtTimestamp = 'sender__createdAtTimestamp',
  SenderId = 'sender__id',
  SenderIsSuperApp = 'sender__isSuperApp',
  SenderUpdatedAtBlockNumber = 'sender__updatedAtBlockNumber',
  SenderUpdatedAtTimestamp = 'sender__updatedAtTimestamp',
  StreamPeriods = 'streamPeriods',
  StreamedUntilUpdatedAt = 'streamedUntilUpdatedAt',
  Token = 'token',
  TokenCreatedAtBlockNumber = 'token__createdAtBlockNumber',
  TokenCreatedAtTimestamp = 'token__createdAtTimestamp',
  TokenDecimals = 'token__decimals',
  TokenId = 'token__id',
  TokenIsListed = 'token__isListed',
  TokenIsNativeAssetSuperToken = 'token__isNativeAssetSuperToken',
  TokenIsSuperToken = 'token__isSuperToken',
  TokenName = 'token__name',
  TokenSymbol = 'token__symbol',
  TokenUnderlyingAddress = 'token__underlyingAddress',
  UpdatedAtBlockNumber = 'updatedAtBlockNumber',
  UpdatedAtTimestamp = 'updatedAtTimestamp',
  UserData = 'userData'
}

export type Subscription = {
  __typename?: 'Subscription';
  /** Access to subgraph metadata */
  _meta?: Maybe<_Meta_>;
  account?: Maybe<Account>;
  accountTokenSnapshot?: Maybe<AccountTokenSnapshot>;
  accountTokenSnapshotLog?: Maybe<AccountTokenSnapshotLog>;
  accountTokenSnapshotLogs: Array<AccountTokenSnapshotLog>;
  accountTokenSnapshots: Array<AccountTokenSnapshot>;
  accounts: Array<Account>;
  agreementClassRegisteredEvent?: Maybe<AgreementClassRegisteredEvent>;
  agreementClassRegisteredEvents: Array<AgreementClassRegisteredEvent>;
  agreementClassUpdatedEvent?: Maybe<AgreementClassUpdatedEvent>;
  agreementClassUpdatedEvents: Array<AgreementClassUpdatedEvent>;
  agreementLiquidatedByEvent?: Maybe<AgreementLiquidatedByEvent>;
  agreementLiquidatedByEvents: Array<AgreementLiquidatedByEvent>;
  agreementLiquidatedV2Event?: Maybe<AgreementLiquidatedV2Event>;
  agreementLiquidatedV2Events: Array<AgreementLiquidatedV2Event>;
  appRegisteredEvent?: Maybe<AppRegisteredEvent>;
  appRegisteredEvents: Array<AppRegisteredEvent>;
  bondIncreasedEvent?: Maybe<BondIncreasedEvent>;
  bondIncreasedEvents: Array<BondIncreasedEvent>;
  burnedEvent?: Maybe<BurnedEvent>;
  burnedEvents: Array<BurnedEvent>;
  cfav1LiquidationPeriodChangedEvent?: Maybe<CfAv1LiquidationPeriodChangedEvent>;
  cfav1LiquidationPeriodChangedEvents: Array<CfAv1LiquidationPeriodChangedEvent>;
  configChangedEvent?: Maybe<ConfigChangedEvent>;
  configChangedEvents: Array<ConfigChangedEvent>;
  customSuperTokenCreatedEvent?: Maybe<CustomSuperTokenCreatedEvent>;
  customSuperTokenCreatedEvents: Array<CustomSuperTokenCreatedEvent>;
  event?: Maybe<Event>;
  events: Array<Event>;
  exitRateChangedEvent?: Maybe<ExitRateChangedEvent>;
  exitRateChangedEvents: Array<ExitRateChangedEvent>;
  flowOperator?: Maybe<FlowOperator>;
  flowOperatorUpdatedEvent?: Maybe<FlowOperatorUpdatedEvent>;
  flowOperatorUpdatedEvents: Array<FlowOperatorUpdatedEvent>;
  flowOperators: Array<FlowOperator>;
  flowUpdatedEvent?: Maybe<FlowUpdatedEvent>;
  flowUpdatedEvents: Array<FlowUpdatedEvent>;
  governanceReplacedEvent?: Maybe<GovernanceReplacedEvent>;
  governanceReplacedEvents: Array<GovernanceReplacedEvent>;
  index?: Maybe<Index>;
  indexCreatedEvent?: Maybe<IndexCreatedEvent>;
  indexCreatedEvents: Array<IndexCreatedEvent>;
  indexDistributionClaimedEvent?: Maybe<IndexDistributionClaimedEvent>;
  indexDistributionClaimedEvents: Array<IndexDistributionClaimedEvent>;
  indexSubscribedEvent?: Maybe<IndexSubscribedEvent>;
  indexSubscribedEvents: Array<IndexSubscribedEvent>;
  indexSubscription?: Maybe<IndexSubscription>;
  indexSubscriptions: Array<IndexSubscription>;
  indexUnitsUpdatedEvent?: Maybe<IndexUnitsUpdatedEvent>;
  indexUnitsUpdatedEvents: Array<IndexUnitsUpdatedEvent>;
  indexUnsubscribedEvent?: Maybe<IndexUnsubscribedEvent>;
  indexUnsubscribedEvents: Array<IndexUnsubscribedEvent>;
  indexUpdatedEvent?: Maybe<IndexUpdatedEvent>;
  indexUpdatedEvents: Array<IndexUpdatedEvent>;
  indexes: Array<Index>;
  jailEvent?: Maybe<JailEvent>;
  jailEvents: Array<JailEvent>;
  mintedEvent?: Maybe<MintedEvent>;
  mintedEvents: Array<MintedEvent>;
  newDataAvailabilityTransaction: DataAvailabilityTransactionUnion;
  newPICEvent?: Maybe<NewPicEvent>;
  newPICEvents: Array<NewPicEvent>;
  pppconfigurationChangedEvent?: Maybe<PppConfigurationChangedEvent>;
  pppconfigurationChangedEvents: Array<PppConfigurationChangedEvent>;
  resolverEntries: Array<ResolverEntry>;
  resolverEntry?: Maybe<ResolverEntry>;
  rewardAddressChangedEvent?: Maybe<RewardAddressChangedEvent>;
  rewardAddressChangedEvents: Array<RewardAddressChangedEvent>;
  roleAdminChangedEvent?: Maybe<RoleAdminChangedEvent>;
  roleAdminChangedEvents: Array<RoleAdminChangedEvent>;
  roleGrantedEvent?: Maybe<RoleGrantedEvent>;
  roleGrantedEvents: Array<RoleGrantedEvent>;
  roleRevokedEvent?: Maybe<RoleRevokedEvent>;
  roleRevokedEvents: Array<RoleRevokedEvent>;
  sentEvent?: Maybe<SentEvent>;
  sentEvents: Array<SentEvent>;
  setEvent?: Maybe<SetEvent>;
  setEvents: Array<SetEvent>;
  sfmeta?: Maybe<SfMeta>;
  sfmetas: Array<SfMeta>;
  stream?: Maybe<Stream>;
  streamPeriod?: Maybe<StreamPeriod>;
  streamPeriods: Array<StreamPeriod>;
  streamRevision?: Maybe<StreamRevision>;
  streamRevisions: Array<StreamRevision>;
  streams: Array<Stream>;
  subscriptionApprovedEvent?: Maybe<SubscriptionApprovedEvent>;
  subscriptionApprovedEvents: Array<SubscriptionApprovedEvent>;
  subscriptionDistributionClaimedEvent?: Maybe<SubscriptionDistributionClaimedEvent>;
  subscriptionDistributionClaimedEvents: Array<SubscriptionDistributionClaimedEvent>;
  subscriptionRevokedEvent?: Maybe<SubscriptionRevokedEvent>;
  subscriptionRevokedEvents: Array<SubscriptionRevokedEvent>;
  subscriptionUnitsUpdatedEvent?: Maybe<SubscriptionUnitsUpdatedEvent>;
  subscriptionUnitsUpdatedEvents: Array<SubscriptionUnitsUpdatedEvent>;
  superTokenCreatedEvent?: Maybe<SuperTokenCreatedEvent>;
  superTokenCreatedEvents: Array<SuperTokenCreatedEvent>;
  superTokenFactoryUpdatedEvent?: Maybe<SuperTokenFactoryUpdatedEvent>;
  superTokenFactoryUpdatedEvents: Array<SuperTokenFactoryUpdatedEvent>;
  superTokenLogicCreatedEvent?: Maybe<SuperTokenLogicCreatedEvent>;
  superTokenLogicCreatedEvents: Array<SuperTokenLogicCreatedEvent>;
  superTokenLogicUpdatedEvent?: Maybe<SuperTokenLogicUpdatedEvent>;
  superTokenLogicUpdatedEvents: Array<SuperTokenLogicUpdatedEvent>;
  superTokenMinimumDepositChangedEvent?: Maybe<SuperTokenMinimumDepositChangedEvent>;
  superTokenMinimumDepositChangedEvents: Array<SuperTokenMinimumDepositChangedEvent>;
  token?: Maybe<Token>;
  tokenDowngradedEvent?: Maybe<TokenDowngradedEvent>;
  tokenDowngradedEvents: Array<TokenDowngradedEvent>;
  tokenGovernanceConfig?: Maybe<TokenGovernanceConfig>;
  tokenGovernanceConfigs: Array<TokenGovernanceConfig>;
  tokenStatistic?: Maybe<TokenStatistic>;
  tokenStatisticLog?: Maybe<TokenStatisticLog>;
  tokenStatisticLogs: Array<TokenStatisticLog>;
  tokenStatistics: Array<TokenStatistic>;
  tokenUpgradedEvent?: Maybe<TokenUpgradedEvent>;
  tokenUpgradedEvents: Array<TokenUpgradedEvent>;
  tokens: Array<Token>;
  transferEvent?: Maybe<TransferEvent>;
  transferEvents: Array<TransferEvent>;
  trustedForwarderChangedEvent?: Maybe<TrustedForwarderChangedEvent>;
  trustedForwarderChangedEvents: Array<TrustedForwarderChangedEvent>;
};


export type Subscription_MetaArgs = {
  block?: InputMaybe<Block_Height>;
};


export type SubscriptionAccountArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionAccountTokenSnapshotArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionAccountTokenSnapshotLogArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionAccountTokenSnapshotLogsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenSnapshotLog_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountTokenSnapshotLog_Filter>;
};


export type SubscriptionAccountTokenSnapshotsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AccountTokenSnapshot_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AccountTokenSnapshot_Filter>;
};


export type SubscriptionAccountsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Account_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Account_Filter>;
};


export type SubscriptionAgreementClassRegisteredEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionAgreementClassRegisteredEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AgreementClassRegisteredEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AgreementClassRegisteredEvent_Filter>;
};


export type SubscriptionAgreementClassUpdatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionAgreementClassUpdatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AgreementClassUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AgreementClassUpdatedEvent_Filter>;
};


export type SubscriptionAgreementLiquidatedByEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionAgreementLiquidatedByEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AgreementLiquidatedByEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AgreementLiquidatedByEvent_Filter>;
};


export type SubscriptionAgreementLiquidatedV2EventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionAgreementLiquidatedV2EventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AgreementLiquidatedV2Event_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AgreementLiquidatedV2Event_Filter>;
};


export type SubscriptionAppRegisteredEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionAppRegisteredEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<AppRegisteredEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<AppRegisteredEvent_Filter>;
};


export type SubscriptionBondIncreasedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionBondIncreasedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<BondIncreasedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<BondIncreasedEvent_Filter>;
};


export type SubscriptionBurnedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionBurnedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<BurnedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<BurnedEvent_Filter>;
};


export type SubscriptionCfav1LiquidationPeriodChangedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionCfav1LiquidationPeriodChangedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<CfAv1LiquidationPeriodChangedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<CfAv1LiquidationPeriodChangedEvent_Filter>;
};


export type SubscriptionConfigChangedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionConfigChangedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ConfigChangedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<ConfigChangedEvent_Filter>;
};


export type SubscriptionCustomSuperTokenCreatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionCustomSuperTokenCreatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<CustomSuperTokenCreatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<CustomSuperTokenCreatedEvent_Filter>;
};


export type SubscriptionEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Event_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Event_Filter>;
};


export type SubscriptionExitRateChangedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionExitRateChangedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ExitRateChangedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<ExitRateChangedEvent_Filter>;
};


export type SubscriptionFlowOperatorArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionFlowOperatorUpdatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionFlowOperatorUpdatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<FlowOperatorUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<FlowOperatorUpdatedEvent_Filter>;
};


export type SubscriptionFlowOperatorsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<FlowOperator_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<FlowOperator_Filter>;
};


export type SubscriptionFlowUpdatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionFlowUpdatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<FlowUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<FlowUpdatedEvent_Filter>;
};


export type SubscriptionGovernanceReplacedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionGovernanceReplacedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<GovernanceReplacedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<GovernanceReplacedEvent_Filter>;
};


export type SubscriptionIndexArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionIndexCreatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionIndexCreatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexCreatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<IndexCreatedEvent_Filter>;
};


export type SubscriptionIndexDistributionClaimedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionIndexDistributionClaimedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexDistributionClaimedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<IndexDistributionClaimedEvent_Filter>;
};


export type SubscriptionIndexSubscribedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionIndexSubscribedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexSubscribedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<IndexSubscribedEvent_Filter>;
};


export type SubscriptionIndexSubscriptionArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionIndexSubscriptionsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexSubscription_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<IndexSubscription_Filter>;
};


export type SubscriptionIndexUnitsUpdatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionIndexUnitsUpdatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexUnitsUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<IndexUnitsUpdatedEvent_Filter>;
};


export type SubscriptionIndexUnsubscribedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionIndexUnsubscribedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexUnsubscribedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<IndexUnsubscribedEvent_Filter>;
};


export type SubscriptionIndexUpdatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionIndexUpdatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<IndexUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<IndexUpdatedEvent_Filter>;
};


export type SubscriptionIndexesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Index_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Index_Filter>;
};


export type SubscriptionJailEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionJailEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<JailEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<JailEvent_Filter>;
};


export type SubscriptionMintedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionMintedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<MintedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<MintedEvent_Filter>;
};


export type SubscriptionNewPicEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionNewPicEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<NewPicEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<NewPicEvent_Filter>;
};


export type SubscriptionPppconfigurationChangedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionPppconfigurationChangedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PppConfigurationChangedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<PppConfigurationChangedEvent_Filter>;
};


export type SubscriptionResolverEntriesArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ResolverEntry_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<ResolverEntry_Filter>;
};


export type SubscriptionResolverEntryArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionRewardAddressChangedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionRewardAddressChangedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<RewardAddressChangedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<RewardAddressChangedEvent_Filter>;
};


export type SubscriptionRoleAdminChangedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionRoleAdminChangedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<RoleAdminChangedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<RoleAdminChangedEvent_Filter>;
};


export type SubscriptionRoleGrantedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionRoleGrantedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<RoleGrantedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<RoleGrantedEvent_Filter>;
};


export type SubscriptionRoleRevokedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionRoleRevokedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<RoleRevokedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<RoleRevokedEvent_Filter>;
};


export type SubscriptionSentEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionSentEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SentEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SentEvent_Filter>;
};


export type SubscriptionSetEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionSetEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SetEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SetEvent_Filter>;
};


export type SubscriptionSfmetaArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionSfmetasArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SfMeta_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SfMeta_Filter>;
};


export type SubscriptionStreamArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionStreamPeriodArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionStreamPeriodsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StreamPeriod_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<StreamPeriod_Filter>;
};


export type SubscriptionStreamRevisionArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionStreamRevisionsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<StreamRevision_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<StreamRevision_Filter>;
};


export type SubscriptionStreamsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Stream_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Stream_Filter>;
};


export type SubscriptionSubscriptionApprovedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionSubscriptionApprovedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SubscriptionApprovedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SubscriptionApprovedEvent_Filter>;
};


export type SubscriptionSubscriptionDistributionClaimedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionSubscriptionDistributionClaimedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SubscriptionDistributionClaimedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SubscriptionDistributionClaimedEvent_Filter>;
};


export type SubscriptionSubscriptionRevokedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionSubscriptionRevokedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SubscriptionRevokedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SubscriptionRevokedEvent_Filter>;
};


export type SubscriptionSubscriptionUnitsUpdatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionSubscriptionUnitsUpdatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SubscriptionUnitsUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SubscriptionUnitsUpdatedEvent_Filter>;
};


export type SubscriptionSuperTokenCreatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionSuperTokenCreatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SuperTokenCreatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SuperTokenCreatedEvent_Filter>;
};


export type SubscriptionSuperTokenFactoryUpdatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionSuperTokenFactoryUpdatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SuperTokenFactoryUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SuperTokenFactoryUpdatedEvent_Filter>;
};


export type SubscriptionSuperTokenLogicCreatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionSuperTokenLogicCreatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SuperTokenLogicCreatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SuperTokenLogicCreatedEvent_Filter>;
};


export type SubscriptionSuperTokenLogicUpdatedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionSuperTokenLogicUpdatedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SuperTokenLogicUpdatedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SuperTokenLogicUpdatedEvent_Filter>;
};


export type SubscriptionSuperTokenMinimumDepositChangedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionSuperTokenMinimumDepositChangedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<SuperTokenMinimumDepositChangedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<SuperTokenMinimumDepositChangedEvent_Filter>;
};


export type SubscriptionTokenArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionTokenDowngradedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionTokenDowngradedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenDowngradedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenDowngradedEvent_Filter>;
};


export type SubscriptionTokenGovernanceConfigArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionTokenGovernanceConfigsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenGovernanceConfig_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenGovernanceConfig_Filter>;
};


export type SubscriptionTokenStatisticArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionTokenStatisticLogArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionTokenStatisticLogsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenStatisticLog_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenStatisticLog_Filter>;
};


export type SubscriptionTokenStatisticsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenStatistic_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenStatistic_Filter>;
};


export type SubscriptionTokenUpgradedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionTokenUpgradedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenUpgradedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TokenUpgradedEvent_Filter>;
};


export type SubscriptionTokensArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<Token_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<Token_Filter>;
};


export type SubscriptionTransferEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionTransferEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TransferEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TransferEvent_Filter>;
};


export type SubscriptionTrustedForwarderChangedEventArgs = {
  block?: InputMaybe<Block_Height>;
  id: Scalars['ID'];
  subgraphError?: _SubgraphErrorPolicy_;
};


export type SubscriptionTrustedForwarderChangedEventsArgs = {
  block?: InputMaybe<Block_Height>;
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TrustedForwarderChangedEvent_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  subgraphError?: _SubgraphErrorPolicy_;
  where?: InputMaybe<TrustedForwarderChangedEvent_Filter>;
};

export type SubscriptionApprovedEvent = Event & {
  __typename?: 'SubscriptionApprovedEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   * addresses[2] = `subscriber`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars['BigInt'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars['Bytes'];
  /**
   * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
   * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
   *
   */
  subscriber: Scalars['Bytes'];
  subscription: IndexSubscription;
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
  userData: Scalars['Bytes'];
};

export type SubscriptionApprovedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<SubscriptionApprovedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  indexId?: InputMaybe<Scalars['BigInt']>;
  indexId_gt?: InputMaybe<Scalars['BigInt']>;
  indexId_gte?: InputMaybe<Scalars['BigInt']>;
  indexId_in?: InputMaybe<Array<Scalars['BigInt']>>;
  indexId_lt?: InputMaybe<Scalars['BigInt']>;
  indexId_lte?: InputMaybe<Scalars['BigInt']>;
  indexId_not?: InputMaybe<Scalars['BigInt']>;
  indexId_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<SubscriptionApprovedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  publisher?: InputMaybe<Scalars['Bytes']>;
  publisher_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_gt?: InputMaybe<Scalars['Bytes']>;
  publisher_gte?: InputMaybe<Scalars['Bytes']>;
  publisher_in?: InputMaybe<Array<Scalars['Bytes']>>;
  publisher_lt?: InputMaybe<Scalars['Bytes']>;
  publisher_lte?: InputMaybe<Scalars['Bytes']>;
  publisher_not?: InputMaybe<Scalars['Bytes']>;
  publisher_not_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscriber?: InputMaybe<Scalars['Bytes']>;
  subscriber_contains?: InputMaybe<Scalars['Bytes']>;
  subscriber_gt?: InputMaybe<Scalars['Bytes']>;
  subscriber_gte?: InputMaybe<Scalars['Bytes']>;
  subscriber_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscriber_lt?: InputMaybe<Scalars['Bytes']>;
  subscriber_lte?: InputMaybe<Scalars['Bytes']>;
  subscriber_not?: InputMaybe<Scalars['Bytes']>;
  subscriber_not_contains?: InputMaybe<Scalars['Bytes']>;
  subscriber_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscription?: InputMaybe<Scalars['String']>;
  subscription_?: InputMaybe<IndexSubscription_Filter>;
  subscription_contains?: InputMaybe<Scalars['String']>;
  subscription_contains_nocase?: InputMaybe<Scalars['String']>;
  subscription_ends_with?: InputMaybe<Scalars['String']>;
  subscription_ends_with_nocase?: InputMaybe<Scalars['String']>;
  subscription_gt?: InputMaybe<Scalars['String']>;
  subscription_gte?: InputMaybe<Scalars['String']>;
  subscription_in?: InputMaybe<Array<Scalars['String']>>;
  subscription_lt?: InputMaybe<Scalars['String']>;
  subscription_lte?: InputMaybe<Scalars['String']>;
  subscription_not?: InputMaybe<Scalars['String']>;
  subscription_not_contains?: InputMaybe<Scalars['String']>;
  subscription_not_contains_nocase?: InputMaybe<Scalars['String']>;
  subscription_not_ends_with?: InputMaybe<Scalars['String']>;
  subscription_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  subscription_not_in?: InputMaybe<Array<Scalars['String']>>;
  subscription_not_starts_with?: InputMaybe<Scalars['String']>;
  subscription_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  subscription_starts_with?: InputMaybe<Scalars['String']>;
  subscription_starts_with_nocase?: InputMaybe<Scalars['String']>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  userData?: InputMaybe<Scalars['Bytes']>;
  userData_contains?: InputMaybe<Scalars['Bytes']>;
  userData_gt?: InputMaybe<Scalars['Bytes']>;
  userData_gte?: InputMaybe<Scalars['Bytes']>;
  userData_in?: InputMaybe<Array<Scalars['Bytes']>>;
  userData_lt?: InputMaybe<Scalars['Bytes']>;
  userData_lte?: InputMaybe<Scalars['Bytes']>;
  userData_not?: InputMaybe<Scalars['Bytes']>;
  userData_not_contains?: InputMaybe<Scalars['Bytes']>;
  userData_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum SubscriptionApprovedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  IndexId = 'indexId',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Publisher = 'publisher',
  Subscriber = 'subscriber',
  Subscription = 'subscription',
  SubscriptionApproved = 'subscription__approved',
  SubscriptionCreatedAtBlockNumber = 'subscription__createdAtBlockNumber',
  SubscriptionCreatedAtTimestamp = 'subscription__createdAtTimestamp',
  SubscriptionId = 'subscription__id',
  SubscriptionIndexValueUntilUpdatedAt = 'subscription__indexValueUntilUpdatedAt',
  SubscriptionTotalAmountReceivedUntilUpdatedAt = 'subscription__totalAmountReceivedUntilUpdatedAt',
  SubscriptionUnits = 'subscription__units',
  SubscriptionUpdatedAtBlockNumber = 'subscription__updatedAtBlockNumber',
  SubscriptionUpdatedAtTimestamp = 'subscription__updatedAtTimestamp',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash',
  UserData = 'userData'
}

export type SubscriptionDistributionClaimedEvent = Event & {
  __typename?: 'SubscriptionDistributionClaimedEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   * addresses[2] = `subscriber`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  amount: Scalars['BigInt'];
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars['BigInt'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars['Bytes'];
  /**
   * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
   * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
   *
   */
  subscriber: Scalars['Bytes'];
  subscription: IndexSubscription;
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
};

export type SubscriptionDistributionClaimedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  and?: InputMaybe<Array<InputMaybe<SubscriptionDistributionClaimedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  indexId?: InputMaybe<Scalars['BigInt']>;
  indexId_gt?: InputMaybe<Scalars['BigInt']>;
  indexId_gte?: InputMaybe<Scalars['BigInt']>;
  indexId_in?: InputMaybe<Array<Scalars['BigInt']>>;
  indexId_lt?: InputMaybe<Scalars['BigInt']>;
  indexId_lte?: InputMaybe<Scalars['BigInt']>;
  indexId_not?: InputMaybe<Scalars['BigInt']>;
  indexId_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<SubscriptionDistributionClaimedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  publisher?: InputMaybe<Scalars['Bytes']>;
  publisher_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_gt?: InputMaybe<Scalars['Bytes']>;
  publisher_gte?: InputMaybe<Scalars['Bytes']>;
  publisher_in?: InputMaybe<Array<Scalars['Bytes']>>;
  publisher_lt?: InputMaybe<Scalars['Bytes']>;
  publisher_lte?: InputMaybe<Scalars['Bytes']>;
  publisher_not?: InputMaybe<Scalars['Bytes']>;
  publisher_not_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscriber?: InputMaybe<Scalars['Bytes']>;
  subscriber_contains?: InputMaybe<Scalars['Bytes']>;
  subscriber_gt?: InputMaybe<Scalars['Bytes']>;
  subscriber_gte?: InputMaybe<Scalars['Bytes']>;
  subscriber_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscriber_lt?: InputMaybe<Scalars['Bytes']>;
  subscriber_lte?: InputMaybe<Scalars['Bytes']>;
  subscriber_not?: InputMaybe<Scalars['Bytes']>;
  subscriber_not_contains?: InputMaybe<Scalars['Bytes']>;
  subscriber_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscription?: InputMaybe<Scalars['String']>;
  subscription_?: InputMaybe<IndexSubscription_Filter>;
  subscription_contains?: InputMaybe<Scalars['String']>;
  subscription_contains_nocase?: InputMaybe<Scalars['String']>;
  subscription_ends_with?: InputMaybe<Scalars['String']>;
  subscription_ends_with_nocase?: InputMaybe<Scalars['String']>;
  subscription_gt?: InputMaybe<Scalars['String']>;
  subscription_gte?: InputMaybe<Scalars['String']>;
  subscription_in?: InputMaybe<Array<Scalars['String']>>;
  subscription_lt?: InputMaybe<Scalars['String']>;
  subscription_lte?: InputMaybe<Scalars['String']>;
  subscription_not?: InputMaybe<Scalars['String']>;
  subscription_not_contains?: InputMaybe<Scalars['String']>;
  subscription_not_contains_nocase?: InputMaybe<Scalars['String']>;
  subscription_not_ends_with?: InputMaybe<Scalars['String']>;
  subscription_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  subscription_not_in?: InputMaybe<Array<Scalars['String']>>;
  subscription_not_starts_with?: InputMaybe<Scalars['String']>;
  subscription_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  subscription_starts_with?: InputMaybe<Scalars['String']>;
  subscription_starts_with_nocase?: InputMaybe<Scalars['String']>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum SubscriptionDistributionClaimedEvent_OrderBy {
  Addresses = 'addresses',
  Amount = 'amount',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  IndexId = 'indexId',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Publisher = 'publisher',
  Subscriber = 'subscriber',
  Subscription = 'subscription',
  SubscriptionApproved = 'subscription__approved',
  SubscriptionCreatedAtBlockNumber = 'subscription__createdAtBlockNumber',
  SubscriptionCreatedAtTimestamp = 'subscription__createdAtTimestamp',
  SubscriptionId = 'subscription__id',
  SubscriptionIndexValueUntilUpdatedAt = 'subscription__indexValueUntilUpdatedAt',
  SubscriptionTotalAmountReceivedUntilUpdatedAt = 'subscription__totalAmountReceivedUntilUpdatedAt',
  SubscriptionUnits = 'subscription__units',
  SubscriptionUpdatedAtBlockNumber = 'subscription__updatedAtBlockNumber',
  SubscriptionUpdatedAtTimestamp = 'subscription__updatedAtTimestamp',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash'
}

export type SubscriptionRevokedEvent = Event & {
  __typename?: 'SubscriptionRevokedEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   * addresses[2] = `subscriber`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars['BigInt'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars['Bytes'];
  /**
   * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
   * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
   *
   */
  subscriber: Scalars['Bytes'];
  subscription: IndexSubscription;
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
  userData: Scalars['Bytes'];
};

export type SubscriptionRevokedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<SubscriptionRevokedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  indexId?: InputMaybe<Scalars['BigInt']>;
  indexId_gt?: InputMaybe<Scalars['BigInt']>;
  indexId_gte?: InputMaybe<Scalars['BigInt']>;
  indexId_in?: InputMaybe<Array<Scalars['BigInt']>>;
  indexId_lt?: InputMaybe<Scalars['BigInt']>;
  indexId_lte?: InputMaybe<Scalars['BigInt']>;
  indexId_not?: InputMaybe<Scalars['BigInt']>;
  indexId_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<SubscriptionRevokedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  publisher?: InputMaybe<Scalars['Bytes']>;
  publisher_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_gt?: InputMaybe<Scalars['Bytes']>;
  publisher_gte?: InputMaybe<Scalars['Bytes']>;
  publisher_in?: InputMaybe<Array<Scalars['Bytes']>>;
  publisher_lt?: InputMaybe<Scalars['Bytes']>;
  publisher_lte?: InputMaybe<Scalars['Bytes']>;
  publisher_not?: InputMaybe<Scalars['Bytes']>;
  publisher_not_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscriber?: InputMaybe<Scalars['Bytes']>;
  subscriber_contains?: InputMaybe<Scalars['Bytes']>;
  subscriber_gt?: InputMaybe<Scalars['Bytes']>;
  subscriber_gte?: InputMaybe<Scalars['Bytes']>;
  subscriber_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscriber_lt?: InputMaybe<Scalars['Bytes']>;
  subscriber_lte?: InputMaybe<Scalars['Bytes']>;
  subscriber_not?: InputMaybe<Scalars['Bytes']>;
  subscriber_not_contains?: InputMaybe<Scalars['Bytes']>;
  subscriber_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscription?: InputMaybe<Scalars['String']>;
  subscription_?: InputMaybe<IndexSubscription_Filter>;
  subscription_contains?: InputMaybe<Scalars['String']>;
  subscription_contains_nocase?: InputMaybe<Scalars['String']>;
  subscription_ends_with?: InputMaybe<Scalars['String']>;
  subscription_ends_with_nocase?: InputMaybe<Scalars['String']>;
  subscription_gt?: InputMaybe<Scalars['String']>;
  subscription_gte?: InputMaybe<Scalars['String']>;
  subscription_in?: InputMaybe<Array<Scalars['String']>>;
  subscription_lt?: InputMaybe<Scalars['String']>;
  subscription_lte?: InputMaybe<Scalars['String']>;
  subscription_not?: InputMaybe<Scalars['String']>;
  subscription_not_contains?: InputMaybe<Scalars['String']>;
  subscription_not_contains_nocase?: InputMaybe<Scalars['String']>;
  subscription_not_ends_with?: InputMaybe<Scalars['String']>;
  subscription_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  subscription_not_in?: InputMaybe<Array<Scalars['String']>>;
  subscription_not_starts_with?: InputMaybe<Scalars['String']>;
  subscription_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  subscription_starts_with?: InputMaybe<Scalars['String']>;
  subscription_starts_with_nocase?: InputMaybe<Scalars['String']>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  userData?: InputMaybe<Scalars['Bytes']>;
  userData_contains?: InputMaybe<Scalars['Bytes']>;
  userData_gt?: InputMaybe<Scalars['Bytes']>;
  userData_gte?: InputMaybe<Scalars['Bytes']>;
  userData_in?: InputMaybe<Array<Scalars['Bytes']>>;
  userData_lt?: InputMaybe<Scalars['Bytes']>;
  userData_lte?: InputMaybe<Scalars['Bytes']>;
  userData_not?: InputMaybe<Scalars['Bytes']>;
  userData_not_contains?: InputMaybe<Scalars['Bytes']>;
  userData_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum SubscriptionRevokedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  IndexId = 'indexId',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Publisher = 'publisher',
  Subscriber = 'subscriber',
  Subscription = 'subscription',
  SubscriptionApproved = 'subscription__approved',
  SubscriptionCreatedAtBlockNumber = 'subscription__createdAtBlockNumber',
  SubscriptionCreatedAtTimestamp = 'subscription__createdAtTimestamp',
  SubscriptionId = 'subscription__id',
  SubscriptionIndexValueUntilUpdatedAt = 'subscription__indexValueUntilUpdatedAt',
  SubscriptionTotalAmountReceivedUntilUpdatedAt = 'subscription__totalAmountReceivedUntilUpdatedAt',
  SubscriptionUnits = 'subscription__units',
  SubscriptionUpdatedAtBlockNumber = 'subscription__updatedAtBlockNumber',
  SubscriptionUpdatedAtTimestamp = 'subscription__updatedAtTimestamp',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash',
  UserData = 'userData'
}

export type SubscriptionUnitsUpdatedEvent = Event & {
  __typename?: 'SubscriptionUnitsUpdatedEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `publisher`
   * addresses[2] = `subscriber`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  /**
   * An arbitrary uint32 value used to allow a publisher to create multiple indexes for a specific `token`.
   *
   */
  indexId: Scalars['BigInt'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  oldUnits: Scalars['BigInt'];
  order: Scalars['BigInt'];
  /**
   * The creator of the `index`.
   *
   */
  publisher: Scalars['Bytes'];
  /**
   * The account that is subscribed to `index`. A possible recipient of distributions from the `publisher`.
   * `subscriber` only receives tokens if they have been allocated units (can be thought of as shares).
   *
   */
  subscriber: Scalars['Bytes'];
  subscription: IndexSubscription;
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
  units: Scalars['BigInt'];
  userData: Scalars['Bytes'];
};

export type SubscriptionUnitsUpdatedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<SubscriptionUnitsUpdatedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  indexId?: InputMaybe<Scalars['BigInt']>;
  indexId_gt?: InputMaybe<Scalars['BigInt']>;
  indexId_gte?: InputMaybe<Scalars['BigInt']>;
  indexId_in?: InputMaybe<Array<Scalars['BigInt']>>;
  indexId_lt?: InputMaybe<Scalars['BigInt']>;
  indexId_lte?: InputMaybe<Scalars['BigInt']>;
  indexId_not?: InputMaybe<Scalars['BigInt']>;
  indexId_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  oldUnits?: InputMaybe<Scalars['BigInt']>;
  oldUnits_gt?: InputMaybe<Scalars['BigInt']>;
  oldUnits_gte?: InputMaybe<Scalars['BigInt']>;
  oldUnits_in?: InputMaybe<Array<Scalars['BigInt']>>;
  oldUnits_lt?: InputMaybe<Scalars['BigInt']>;
  oldUnits_lte?: InputMaybe<Scalars['BigInt']>;
  oldUnits_not?: InputMaybe<Scalars['BigInt']>;
  oldUnits_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  or?: InputMaybe<Array<InputMaybe<SubscriptionUnitsUpdatedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  publisher?: InputMaybe<Scalars['Bytes']>;
  publisher_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_gt?: InputMaybe<Scalars['Bytes']>;
  publisher_gte?: InputMaybe<Scalars['Bytes']>;
  publisher_in?: InputMaybe<Array<Scalars['Bytes']>>;
  publisher_lt?: InputMaybe<Scalars['Bytes']>;
  publisher_lte?: InputMaybe<Scalars['Bytes']>;
  publisher_not?: InputMaybe<Scalars['Bytes']>;
  publisher_not_contains?: InputMaybe<Scalars['Bytes']>;
  publisher_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscriber?: InputMaybe<Scalars['Bytes']>;
  subscriber_contains?: InputMaybe<Scalars['Bytes']>;
  subscriber_gt?: InputMaybe<Scalars['Bytes']>;
  subscriber_gte?: InputMaybe<Scalars['Bytes']>;
  subscriber_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscriber_lt?: InputMaybe<Scalars['Bytes']>;
  subscriber_lte?: InputMaybe<Scalars['Bytes']>;
  subscriber_not?: InputMaybe<Scalars['Bytes']>;
  subscriber_not_contains?: InputMaybe<Scalars['Bytes']>;
  subscriber_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  subscription?: InputMaybe<Scalars['String']>;
  subscription_?: InputMaybe<IndexSubscription_Filter>;
  subscription_contains?: InputMaybe<Scalars['String']>;
  subscription_contains_nocase?: InputMaybe<Scalars['String']>;
  subscription_ends_with?: InputMaybe<Scalars['String']>;
  subscription_ends_with_nocase?: InputMaybe<Scalars['String']>;
  subscription_gt?: InputMaybe<Scalars['String']>;
  subscription_gte?: InputMaybe<Scalars['String']>;
  subscription_in?: InputMaybe<Array<Scalars['String']>>;
  subscription_lt?: InputMaybe<Scalars['String']>;
  subscription_lte?: InputMaybe<Scalars['String']>;
  subscription_not?: InputMaybe<Scalars['String']>;
  subscription_not_contains?: InputMaybe<Scalars['String']>;
  subscription_not_contains_nocase?: InputMaybe<Scalars['String']>;
  subscription_not_ends_with?: InputMaybe<Scalars['String']>;
  subscription_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  subscription_not_in?: InputMaybe<Array<Scalars['String']>>;
  subscription_not_starts_with?: InputMaybe<Scalars['String']>;
  subscription_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  subscription_starts_with?: InputMaybe<Scalars['String']>;
  subscription_starts_with_nocase?: InputMaybe<Scalars['String']>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  units?: InputMaybe<Scalars['BigInt']>;
  units_gt?: InputMaybe<Scalars['BigInt']>;
  units_gte?: InputMaybe<Scalars['BigInt']>;
  units_in?: InputMaybe<Array<Scalars['BigInt']>>;
  units_lt?: InputMaybe<Scalars['BigInt']>;
  units_lte?: InputMaybe<Scalars['BigInt']>;
  units_not?: InputMaybe<Scalars['BigInt']>;
  units_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  userData?: InputMaybe<Scalars['Bytes']>;
  userData_contains?: InputMaybe<Scalars['Bytes']>;
  userData_gt?: InputMaybe<Scalars['Bytes']>;
  userData_gte?: InputMaybe<Scalars['Bytes']>;
  userData_in?: InputMaybe<Array<Scalars['Bytes']>>;
  userData_lt?: InputMaybe<Scalars['Bytes']>;
  userData_lte?: InputMaybe<Scalars['Bytes']>;
  userData_not?: InputMaybe<Scalars['Bytes']>;
  userData_not_contains?: InputMaybe<Scalars['Bytes']>;
  userData_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum SubscriptionUnitsUpdatedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  IndexId = 'indexId',
  LogIndex = 'logIndex',
  Name = 'name',
  OldUnits = 'oldUnits',
  Order = 'order',
  Publisher = 'publisher',
  Subscriber = 'subscriber',
  Subscription = 'subscription',
  SubscriptionApproved = 'subscription__approved',
  SubscriptionCreatedAtBlockNumber = 'subscription__createdAtBlockNumber',
  SubscriptionCreatedAtTimestamp = 'subscription__createdAtTimestamp',
  SubscriptionId = 'subscription__id',
  SubscriptionIndexValueUntilUpdatedAt = 'subscription__indexValueUntilUpdatedAt',
  SubscriptionTotalAmountReceivedUntilUpdatedAt = 'subscription__totalAmountReceivedUntilUpdatedAt',
  SubscriptionUnits = 'subscription__units',
  SubscriptionUpdatedAtBlockNumber = 'subscription__updatedAtBlockNumber',
  SubscriptionUpdatedAtTimestamp = 'subscription__updatedAtTimestamp',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash',
  Units = 'units',
  UserData = 'userData'
}

export type SuperTokenCreatedEvent = Event & {
  __typename?: 'SuperTokenCreatedEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
};

export type SuperTokenCreatedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<SuperTokenCreatedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<SuperTokenCreatedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum SuperTokenCreatedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash'
}

export type SuperTokenFactoryUpdatedEvent = Event & {
  __typename?: 'SuperTokenFactoryUpdatedEvent';
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  newFactory: Scalars['Bytes'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
};

export type SuperTokenFactoryUpdatedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<SuperTokenFactoryUpdatedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  newFactory?: InputMaybe<Scalars['Bytes']>;
  newFactory_contains?: InputMaybe<Scalars['Bytes']>;
  newFactory_gt?: InputMaybe<Scalars['Bytes']>;
  newFactory_gte?: InputMaybe<Scalars['Bytes']>;
  newFactory_in?: InputMaybe<Array<Scalars['Bytes']>>;
  newFactory_lt?: InputMaybe<Scalars['Bytes']>;
  newFactory_lte?: InputMaybe<Scalars['Bytes']>;
  newFactory_not?: InputMaybe<Scalars['Bytes']>;
  newFactory_not_contains?: InputMaybe<Scalars['Bytes']>;
  newFactory_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  or?: InputMaybe<Array<InputMaybe<SuperTokenFactoryUpdatedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum SuperTokenFactoryUpdatedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  NewFactory = 'newFactory',
  Order = 'order',
  Timestamp = 'timestamp',
  TransactionHash = 'transactionHash'
}

export type SuperTokenLogicCreatedEvent = Event & {
  __typename?: 'SuperTokenLogicCreatedEvent';
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  tokenLogic: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
};

export type SuperTokenLogicCreatedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<SuperTokenLogicCreatedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<SuperTokenLogicCreatedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  tokenLogic?: InputMaybe<Scalars['Bytes']>;
  tokenLogic_contains?: InputMaybe<Scalars['Bytes']>;
  tokenLogic_gt?: InputMaybe<Scalars['Bytes']>;
  tokenLogic_gte?: InputMaybe<Scalars['Bytes']>;
  tokenLogic_in?: InputMaybe<Array<Scalars['Bytes']>>;
  tokenLogic_lt?: InputMaybe<Scalars['Bytes']>;
  tokenLogic_lte?: InputMaybe<Scalars['Bytes']>;
  tokenLogic_not?: InputMaybe<Scalars['Bytes']>;
  tokenLogic_not_contains?: InputMaybe<Scalars['Bytes']>;
  tokenLogic_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum SuperTokenLogicCreatedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Timestamp = 'timestamp',
  TokenLogic = 'tokenLogic',
  TransactionHash = 'transactionHash'
}

export type SuperTokenLogicUpdatedEvent = Event & {
  __typename?: 'SuperTokenLogicUpdatedEvent';
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  code: Scalars['Bytes'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
};

export type SuperTokenLogicUpdatedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<SuperTokenLogicUpdatedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  code?: InputMaybe<Scalars['Bytes']>;
  code_contains?: InputMaybe<Scalars['Bytes']>;
  code_gt?: InputMaybe<Scalars['Bytes']>;
  code_gte?: InputMaybe<Scalars['Bytes']>;
  code_in?: InputMaybe<Array<Scalars['Bytes']>>;
  code_lt?: InputMaybe<Scalars['Bytes']>;
  code_lte?: InputMaybe<Scalars['Bytes']>;
  code_not?: InputMaybe<Scalars['Bytes']>;
  code_not_contains?: InputMaybe<Scalars['Bytes']>;
  code_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<SuperTokenLogicUpdatedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum SuperTokenLogicUpdatedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  Code = 'code',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash'
}

export type SuperTokenMinimumDepositChangedEvent = Event & {
  __typename?: 'SuperTokenMinimumDepositChangedEvent';
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  /**
   * The address of the governance contract the event was emitted from.
   *
   */
  governanceAddress: Scalars['Bytes'];
  host: Scalars['Bytes'];
  id: Scalars['ID'];
  isKeySet: Scalars['Boolean'];
  logIndex: Scalars['BigInt'];
  minimumDeposit: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  superToken: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
};

export type SuperTokenMinimumDepositChangedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<SuperTokenMinimumDepositChangedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  governanceAddress?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_contains?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_gt?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_gte?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_in?: InputMaybe<Array<Scalars['Bytes']>>;
  governanceAddress_lt?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_lte?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not_contains?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  host?: InputMaybe<Scalars['Bytes']>;
  host_contains?: InputMaybe<Scalars['Bytes']>;
  host_gt?: InputMaybe<Scalars['Bytes']>;
  host_gte?: InputMaybe<Scalars['Bytes']>;
  host_in?: InputMaybe<Array<Scalars['Bytes']>>;
  host_lt?: InputMaybe<Scalars['Bytes']>;
  host_lte?: InputMaybe<Scalars['Bytes']>;
  host_not?: InputMaybe<Scalars['Bytes']>;
  host_not_contains?: InputMaybe<Scalars['Bytes']>;
  host_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  isKeySet?: InputMaybe<Scalars['Boolean']>;
  isKeySet_in?: InputMaybe<Array<Scalars['Boolean']>>;
  isKeySet_not?: InputMaybe<Scalars['Boolean']>;
  isKeySet_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  minimumDeposit?: InputMaybe<Scalars['BigInt']>;
  minimumDeposit_gt?: InputMaybe<Scalars['BigInt']>;
  minimumDeposit_gte?: InputMaybe<Scalars['BigInt']>;
  minimumDeposit_in?: InputMaybe<Array<Scalars['BigInt']>>;
  minimumDeposit_lt?: InputMaybe<Scalars['BigInt']>;
  minimumDeposit_lte?: InputMaybe<Scalars['BigInt']>;
  minimumDeposit_not?: InputMaybe<Scalars['BigInt']>;
  minimumDeposit_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<SuperTokenMinimumDepositChangedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  superToken?: InputMaybe<Scalars['Bytes']>;
  superToken_contains?: InputMaybe<Scalars['Bytes']>;
  superToken_gt?: InputMaybe<Scalars['Bytes']>;
  superToken_gte?: InputMaybe<Scalars['Bytes']>;
  superToken_in?: InputMaybe<Array<Scalars['Bytes']>>;
  superToken_lt?: InputMaybe<Scalars['Bytes']>;
  superToken_lte?: InputMaybe<Scalars['Bytes']>;
  superToken_not?: InputMaybe<Scalars['Bytes']>;
  superToken_not_contains?: InputMaybe<Scalars['Bytes']>;
  superToken_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum SuperTokenMinimumDepositChangedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  GovernanceAddress = 'governanceAddress',
  Host = 'host',
  Id = 'id',
  IsKeySet = 'isKeySet',
  LogIndex = 'logIndex',
  MinimumDeposit = 'minimumDeposit',
  Name = 'name',
  Order = 'order',
  SuperToken = 'superToken',
  Timestamp = 'timestamp',
  TransactionHash = 'transactionHash'
}

export type SybilDotOrgIdentity = {
  __typename?: 'SybilDotOrgIdentity';
  source: SybilDotOrgIdentitySource;
  /** The sybil dot org status */
  verified: Scalars['Boolean'];
};

export type SybilDotOrgIdentitySource = {
  __typename?: 'SybilDotOrgIdentitySource';
  twitter: SybilDotOrgTwitterIdentity;
};

export type SybilDotOrgTwitterIdentity = {
  __typename?: 'SybilDotOrgTwitterIdentity';
  handle?: Maybe<Scalars['String']>;
};

/** The social comment */
export type TagResult = {
  __typename?: 'TagResult';
  /** The tag */
  tag: Scalars['PublicationTag'];
  /** The total amount of publication tagged */
  total: Scalars['Int'];
};

/** The publications tags sort criteria */
export enum TagSortCriteria {
  Alphabetical = 'ALPHABETICAL',
  MostPopular = 'MOST_POPULAR'
}

export type TimedFeeCollectModuleParams = {
  /** The collect module amount info */
  amount: ModuleFeeAmountParams;
  /** Follower only */
  followerOnly: Scalars['Boolean'];
  /** The collect module recipient address */
  recipient: Scalars['EthereumAddress'];
  /** The collect module referral fee */
  referralFee: Scalars['Float'];
};

export type TimedFeeCollectModuleSettings = {
  __typename?: 'TimedFeeCollectModuleSettings';
  /** The collect module amount info */
  amount: ModuleFeeAmount;
  contractAddress: Scalars['ContractAddress'];
  /** The collect module end timestamp */
  endTimestamp: Scalars['DateTime'];
  /** Follower only */
  followerOnly: Scalars['Boolean'];
  /** The collect module recipient address */
  recipient: Scalars['EthereumAddress'];
  /** The collect module referral fee */
  referralFee: Scalars['Float'];
  /** The collect modules enum */
  type: CollectModules;
};

/**
 * Token: A higher order entity created for super tokens (and underlying tokens) that are "valid" (tokens that have Superfluid's host contract address set as the host).
 *
 */
export type Token = {
  __typename?: 'Token';
  createdAtBlockNumber: Scalars['BigInt'];
  createdAtTimestamp: Scalars['BigInt'];
  decimals: Scalars['Int'];
  governanceConfig?: Maybe<TokenGovernanceConfig>;
  /**
   * ID: the token address
   *
   */
  id: Scalars['ID'];
  /**
   * A boolean indicating whether the token is a part of our resolver list.
   *
   */
  isListed: Scalars['Boolean'];
  /**
   * A boolean indicating whether the token is a NativeAssetSuperToken.
   *
   */
  isNativeAssetSuperToken: Scalars['Boolean'];
  isSuperToken: Scalars['Boolean'];
  name: Scalars['String'];
  symbol: Scalars['String'];
  /**
   * The address of the underlying ERC20 token (zero address for non-ERC20WrapperSuperToken's)
   *
   */
  underlyingAddress: Scalars['Bytes'];
  /**
   * The underlying ERC20 token for a ERC20WrapperSuperToken otherwise null.
   *
   */
  underlyingToken?: Maybe<Token>;
};

export type TokenDowngradedEvent = Event & {
  __typename?: 'TokenDowngradedEvent';
  account: Account;
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `account`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  amount: Scalars['BigInt'];
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
};

export type TokenDowngradedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['String']>;
  account_?: InputMaybe<Account_Filter>;
  account_contains?: InputMaybe<Scalars['String']>;
  account_contains_nocase?: InputMaybe<Scalars['String']>;
  account_ends_with?: InputMaybe<Scalars['String']>;
  account_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_gt?: InputMaybe<Scalars['String']>;
  account_gte?: InputMaybe<Scalars['String']>;
  account_in?: InputMaybe<Array<Scalars['String']>>;
  account_lt?: InputMaybe<Scalars['String']>;
  account_lte?: InputMaybe<Scalars['String']>;
  account_not?: InputMaybe<Scalars['String']>;
  account_not_contains?: InputMaybe<Scalars['String']>;
  account_not_contains_nocase?: InputMaybe<Scalars['String']>;
  account_not_ends_with?: InputMaybe<Scalars['String']>;
  account_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_not_in?: InputMaybe<Array<Scalars['String']>>;
  account_not_starts_with?: InputMaybe<Scalars['String']>;
  account_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_starts_with?: InputMaybe<Scalars['String']>;
  account_starts_with_nocase?: InputMaybe<Scalars['String']>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  and?: InputMaybe<Array<InputMaybe<TokenDowngradedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<TokenDowngradedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum TokenDowngradedEvent_OrderBy {
  Account = 'account',
  AccountCreatedAtBlockNumber = 'account__createdAtBlockNumber',
  AccountCreatedAtTimestamp = 'account__createdAtTimestamp',
  AccountId = 'account__id',
  AccountIsSuperApp = 'account__isSuperApp',
  AccountUpdatedAtBlockNumber = 'account__updatedAtBlockNumber',
  AccountUpdatedAtTimestamp = 'account__updatedAtTimestamp',
  Addresses = 'addresses',
  Amount = 'amount',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash'
}

/**
 * TokenGovernanceConfig: A higher order entity that represents the governance configs for a token.
 * If `id` is `address(0)`, it will be used as the default config.
 *
 */
export type TokenGovernanceConfig = {
  __typename?: 'TokenGovernanceConfig';
  createdAtBlockNumber: Scalars['BigInt'];
  createdAtTimestamp: Scalars['BigInt'];
  /**
   * id is the address of the SuperToken
   * NOTE: the zero address is reserved for the default config for all tokens with unset configs.
   *
   */
  id: Scalars['ID'];
  /**
   * If true, `id` is `address(0)` and this is the default config for all tokens with unset configs.
   *
   */
  isDefault: Scalars['Boolean'];
  /**
   * The (default or token-specific) liquidation period (buffer amount required for a token).
   * This field can be used to calculate the liquidation buffer (or deposit) amount for a token: `liquidationBufferAmount = liquidationPeriod * flowRate`.
   * Note that if `minimumDeposit` is set, the liquidation buffer amount will be the greater of the two values.
   *
   */
  liquidationPeriod?: Maybe<Scalars['BigInt']>;
  /**
   * The (default or token-specific) minimum deposit amount.
   *
   */
  minimumDeposit?: Maybe<Scalars['BigInt']>;
  /**
   * The (default or token-specific) patrician period, the patrician period is the window in which a patrician receives all rewards for a liquidation, no matter the liquidating account.
   *
   */
  patricianPeriod?: Maybe<Scalars['BigInt']>;
  /**
   * The (default or token-specific) address that receives liquidation rewards for a token prior to 3Ps and the TOGA address after 3Ps.
   *
   */
  rewardAddress?: Maybe<Scalars['Bytes']>;
  /**
   * A reverse lookup to the token it is associated with and null if it is the default config.
   *
   */
  token?: Maybe<Token>;
  updatedAtBlockNumber: Scalars['BigInt'];
  updatedAtTimestamp: Scalars['BigInt'];
};

export type TokenGovernanceConfig_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<TokenGovernanceConfig_Filter>>>;
  createdAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  isDefault?: InputMaybe<Scalars['Boolean']>;
  isDefault_in?: InputMaybe<Array<Scalars['Boolean']>>;
  isDefault_not?: InputMaybe<Scalars['Boolean']>;
  isDefault_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  liquidationPeriod?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_gt?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_gte?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_in?: InputMaybe<Array<Scalars['BigInt']>>;
  liquidationPeriod_lt?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_lte?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_not?: InputMaybe<Scalars['BigInt']>;
  liquidationPeriod_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  minimumDeposit?: InputMaybe<Scalars['BigInt']>;
  minimumDeposit_gt?: InputMaybe<Scalars['BigInt']>;
  minimumDeposit_gte?: InputMaybe<Scalars['BigInt']>;
  minimumDeposit_in?: InputMaybe<Array<Scalars['BigInt']>>;
  minimumDeposit_lt?: InputMaybe<Scalars['BigInt']>;
  minimumDeposit_lte?: InputMaybe<Scalars['BigInt']>;
  minimumDeposit_not?: InputMaybe<Scalars['BigInt']>;
  minimumDeposit_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  or?: InputMaybe<Array<InputMaybe<TokenGovernanceConfig_Filter>>>;
  patricianPeriod?: InputMaybe<Scalars['BigInt']>;
  patricianPeriod_gt?: InputMaybe<Scalars['BigInt']>;
  patricianPeriod_gte?: InputMaybe<Scalars['BigInt']>;
  patricianPeriod_in?: InputMaybe<Array<Scalars['BigInt']>>;
  patricianPeriod_lt?: InputMaybe<Scalars['BigInt']>;
  patricianPeriod_lte?: InputMaybe<Scalars['BigInt']>;
  patricianPeriod_not?: InputMaybe<Scalars['BigInt']>;
  patricianPeriod_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  rewardAddress?: InputMaybe<Scalars['Bytes']>;
  rewardAddress_contains?: InputMaybe<Scalars['Bytes']>;
  rewardAddress_gt?: InputMaybe<Scalars['Bytes']>;
  rewardAddress_gte?: InputMaybe<Scalars['Bytes']>;
  rewardAddress_in?: InputMaybe<Array<Scalars['Bytes']>>;
  rewardAddress_lt?: InputMaybe<Scalars['Bytes']>;
  rewardAddress_lte?: InputMaybe<Scalars['Bytes']>;
  rewardAddress_not?: InputMaybe<Scalars['Bytes']>;
  rewardAddress_not_contains?: InputMaybe<Scalars['Bytes']>;
  rewardAddress_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  updatedAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum TokenGovernanceConfig_OrderBy {
  CreatedAtBlockNumber = 'createdAtBlockNumber',
  CreatedAtTimestamp = 'createdAtTimestamp',
  Id = 'id',
  IsDefault = 'isDefault',
  LiquidationPeriod = 'liquidationPeriod',
  MinimumDeposit = 'minimumDeposit',
  PatricianPeriod = 'patricianPeriod',
  RewardAddress = 'rewardAddress',
  Token = 'token',
  TokenCreatedAtBlockNumber = 'token__createdAtBlockNumber',
  TokenCreatedAtTimestamp = 'token__createdAtTimestamp',
  TokenDecimals = 'token__decimals',
  TokenId = 'token__id',
  TokenIsListed = 'token__isListed',
  TokenIsNativeAssetSuperToken = 'token__isNativeAssetSuperToken',
  TokenIsSuperToken = 'token__isSuperToken',
  TokenName = 'token__name',
  TokenSymbol = 'token__symbol',
  TokenUnderlyingAddress = 'token__underlyingAddress',
  UpdatedAtBlockNumber = 'updatedAtBlockNumber',
  UpdatedAtTimestamp = 'updatedAtTimestamp'
}

/**
 * TokenStatistic: An aggregate entity which contains aggregate data for `token`.
 *
 */
export type TokenStatistic = {
  __typename?: 'TokenStatistic';
  /**
   * id: `token` (superToken) address
   *
   */
  id: Scalars['ID'];
  token: Token;
  tokenStatisticLogs: Array<TokenStatisticLog>;
  /**
   * The all-time total amount distributed until the `updatedAtTimestamp`/`updatedAtBlock`.
   *
   */
  totalAmountDistributedUntilUpdatedAt: Scalars['BigInt'];
  /**
   * The all-time total amount streamed (outflows) until the `updatedAtTimestamp`/`updatedAtBlock`.
   *
   */
  totalAmountStreamedUntilUpdatedAt: Scalars['BigInt'];
  /**
   * The all-time total amount transferred until the `updatedAtTimestamp`/`updatedAtBlock`.
   *
   */
  totalAmountTransferredUntilUpdatedAt: Scalars['BigInt'];
  /**
   * Counts all approved subscriptions whether or not they have units.
   *
   */
  totalApprovedSubscriptions: Scalars['Int'];
  /**
   * The total deposit held by the CFA agreement for this particular `token`.
   *
   */
  totalDeposit: Scalars['BigInt'];
  /**
   * The total number of "active" (has greater than 0 units and has distributed it at least once) Indexes created with `token`.
   *
   */
  totalNumberOfActiveIndexes: Scalars['Int'];
  /**
   * The total number of currently active `token` streams.
   *
   */
  totalNumberOfActiveStreams: Scalars['Int'];
  /**
   * The count of closed streams for `token`.
   *
   */
  totalNumberOfClosedStreams: Scalars['Int'];
  /**
   * The total number of Indexes created with `token`.
   *
   */
  totalNumberOfIndexes: Scalars['Int'];
  /**
   * The total outflow rate of the `token` (how much value is being moved).
   *
   */
  totalOutflowRate: Scalars['BigInt'];
  /**
   * The number of subscriptions which have units allocated to them created with Indexes that distribute `token`.
   *
   */
  totalSubscriptionsWithUnits: Scalars['Int'];
  /**
   * The total supply of the token - this is impacted by users upgrading/downgrading their tokens.
   *
   */
  totalSupply: Scalars['BigInt'];
  updatedAtBlockNumber: Scalars['BigInt'];
  updatedAtTimestamp: Scalars['BigInt'];
};


/**
 * TokenStatistic: An aggregate entity which contains aggregate data for `token`.
 *
 */
export type TokenStatisticTokenStatisticLogsArgs = {
  first?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<TokenStatisticLog_OrderBy>;
  orderDirection?: InputMaybe<OrderDirection>;
  skip?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<TokenStatisticLog_Filter>;
};

/**
 * TokenStatisticLog: Historical entries of `TokenStatistic` updates.
 *
 */
export type TokenStatisticLog = {
  __typename?: 'TokenStatisticLog';
  blockNumber: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  token: Token;
  tokenStatistic: TokenStatistic;
  /**
   * The all-time total amount of `token` distributed until the `timestamp`/`block`.
   *
   */
  totalAmountDistributed: Scalars['BigInt'];
  /**
   * The all-time total amount of `token` streamed (outflows) until the `timestamp`/`block`.
   *
   */
  totalAmountStreamed: Scalars['BigInt'];
  /**
   * The all-time total amount of `token` transferred until the `timestamp`/`block`.
   *
   */
  totalAmountTransferred: Scalars['BigInt'];
  /**
   * Counts all approved subscriptions whether or not they have units.
   *
   */
  totalApprovedSubscriptions: Scalars['Int'];
  /**
   * The total deposit held by the CFA agreement for this particular `token`.
   *
   */
  totalDeposit: Scalars['BigInt'];
  /**
   * The total number of "active" (has greater than 0 units and has distributed it at least once) Indexes created with `token`.
   *
   */
  totalNumberOfActiveIndexes: Scalars['Int'];
  /**
   * The total number of currently active `token` streams.
   *
   */
  totalNumberOfActiveStreams: Scalars['Int'];
  /**
   * The count of closed streams for `token`.
   *
   */
  totalNumberOfClosedStreams: Scalars['Int'];
  /**
   * The total number of Indexes created with `token`.
   *
   */
  totalNumberOfIndexes: Scalars['Int'];
  /**
   * The total outflow rate of the `token` (how much value is being moved).
   *
   */
  totalOutflowRate: Scalars['BigInt'];
  /**
   * The number of subscriptions which have units allocated to them created with Indexes that distribute `token`.
   *
   */
  totalSubscriptionsWithUnits: Scalars['Int'];
  /**
   * The total supply of the token - this is impacted by users upgrading/downgrading their tokens.
   *
   */
  totalSupply: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
  triggeredByEventName: Scalars['String'];
};

export type TokenStatisticLog_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<TokenStatisticLog_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  or?: InputMaybe<Array<InputMaybe<TokenStatisticLog_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['String']>;
  tokenStatistic?: InputMaybe<Scalars['String']>;
  tokenStatistic_?: InputMaybe<TokenStatistic_Filter>;
  tokenStatistic_contains?: InputMaybe<Scalars['String']>;
  tokenStatistic_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenStatistic_ends_with?: InputMaybe<Scalars['String']>;
  tokenStatistic_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenStatistic_gt?: InputMaybe<Scalars['String']>;
  tokenStatistic_gte?: InputMaybe<Scalars['String']>;
  tokenStatistic_in?: InputMaybe<Array<Scalars['String']>>;
  tokenStatistic_lt?: InputMaybe<Scalars['String']>;
  tokenStatistic_lte?: InputMaybe<Scalars['String']>;
  tokenStatistic_not?: InputMaybe<Scalars['String']>;
  tokenStatistic_not_contains?: InputMaybe<Scalars['String']>;
  tokenStatistic_not_contains_nocase?: InputMaybe<Scalars['String']>;
  tokenStatistic_not_ends_with?: InputMaybe<Scalars['String']>;
  tokenStatistic_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  tokenStatistic_not_in?: InputMaybe<Array<Scalars['String']>>;
  tokenStatistic_not_starts_with?: InputMaybe<Scalars['String']>;
  tokenStatistic_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  tokenStatistic_starts_with?: InputMaybe<Scalars['String']>;
  tokenStatistic_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  totalAmountDistributed?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributed_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributed_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountDistributed_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributed_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributed_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountStreamed?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamed_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamed_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountStreamed_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamed_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamed_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountTransferred?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferred_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferred_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferred_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountTransferred_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferred_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferred_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferred_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalApprovedSubscriptions?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_gt?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_gte?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_in?: InputMaybe<Array<Scalars['Int']>>;
  totalApprovedSubscriptions_lt?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_lte?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_not?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalDeposit?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_gt?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_gte?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalDeposit_lt?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_lte?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_not?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalNumberOfActiveIndexes?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveIndexes_gt?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveIndexes_gte?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveIndexes_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfActiveIndexes_lt?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveIndexes_lte?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveIndexes_not?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveIndexes_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfActiveStreams?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_gt?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_gte?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfActiveStreams_lt?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_lte?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_not?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfClosedStreams?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_gt?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_gte?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfClosedStreams_lt?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_lte?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_not?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfIndexes?: InputMaybe<Scalars['Int']>;
  totalNumberOfIndexes_gt?: InputMaybe<Scalars['Int']>;
  totalNumberOfIndexes_gte?: InputMaybe<Scalars['Int']>;
  totalNumberOfIndexes_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfIndexes_lt?: InputMaybe<Scalars['Int']>;
  totalNumberOfIndexes_lte?: InputMaybe<Scalars['Int']>;
  totalNumberOfIndexes_not?: InputMaybe<Scalars['Int']>;
  totalNumberOfIndexes_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalOutflowRate?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_gt?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_gte?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalOutflowRate_lt?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_lte?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_not?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalSubscriptionsWithUnits?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_gt?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_gte?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_in?: InputMaybe<Array<Scalars['Int']>>;
  totalSubscriptionsWithUnits_lt?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_lte?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_not?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalSupply?: InputMaybe<Scalars['BigInt']>;
  totalSupply_gt?: InputMaybe<Scalars['BigInt']>;
  totalSupply_gte?: InputMaybe<Scalars['BigInt']>;
  totalSupply_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalSupply_lt?: InputMaybe<Scalars['BigInt']>;
  totalSupply_lte?: InputMaybe<Scalars['BigInt']>;
  totalSupply_not?: InputMaybe<Scalars['BigInt']>;
  totalSupply_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  triggeredByEventName?: InputMaybe<Scalars['String']>;
  triggeredByEventName_contains?: InputMaybe<Scalars['String']>;
  triggeredByEventName_contains_nocase?: InputMaybe<Scalars['String']>;
  triggeredByEventName_ends_with?: InputMaybe<Scalars['String']>;
  triggeredByEventName_ends_with_nocase?: InputMaybe<Scalars['String']>;
  triggeredByEventName_gt?: InputMaybe<Scalars['String']>;
  triggeredByEventName_gte?: InputMaybe<Scalars['String']>;
  triggeredByEventName_in?: InputMaybe<Array<Scalars['String']>>;
  triggeredByEventName_lt?: InputMaybe<Scalars['String']>;
  triggeredByEventName_lte?: InputMaybe<Scalars['String']>;
  triggeredByEventName_not?: InputMaybe<Scalars['String']>;
  triggeredByEventName_not_contains?: InputMaybe<Scalars['String']>;
  triggeredByEventName_not_contains_nocase?: InputMaybe<Scalars['String']>;
  triggeredByEventName_not_ends_with?: InputMaybe<Scalars['String']>;
  triggeredByEventName_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  triggeredByEventName_not_in?: InputMaybe<Array<Scalars['String']>>;
  triggeredByEventName_not_starts_with?: InputMaybe<Scalars['String']>;
  triggeredByEventName_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  triggeredByEventName_starts_with?: InputMaybe<Scalars['String']>;
  triggeredByEventName_starts_with_nocase?: InputMaybe<Scalars['String']>;
};

export enum TokenStatisticLog_OrderBy {
  BlockNumber = 'blockNumber',
  Id = 'id',
  LogIndex = 'logIndex',
  Order = 'order',
  Timestamp = 'timestamp',
  Token = 'token',
  TokenStatistic = 'tokenStatistic',
  TokenStatisticId = 'tokenStatistic__id',
  TokenStatisticTotalAmountDistributedUntilUpdatedAt = 'tokenStatistic__totalAmountDistributedUntilUpdatedAt',
  TokenStatisticTotalAmountStreamedUntilUpdatedAt = 'tokenStatistic__totalAmountStreamedUntilUpdatedAt',
  TokenStatisticTotalAmountTransferredUntilUpdatedAt = 'tokenStatistic__totalAmountTransferredUntilUpdatedAt',
  TokenStatisticTotalApprovedSubscriptions = 'tokenStatistic__totalApprovedSubscriptions',
  TokenStatisticTotalDeposit = 'tokenStatistic__totalDeposit',
  TokenStatisticTotalNumberOfActiveIndexes = 'tokenStatistic__totalNumberOfActiveIndexes',
  TokenStatisticTotalNumberOfActiveStreams = 'tokenStatistic__totalNumberOfActiveStreams',
  TokenStatisticTotalNumberOfClosedStreams = 'tokenStatistic__totalNumberOfClosedStreams',
  TokenStatisticTotalNumberOfIndexes = 'tokenStatistic__totalNumberOfIndexes',
  TokenStatisticTotalOutflowRate = 'tokenStatistic__totalOutflowRate',
  TokenStatisticTotalSubscriptionsWithUnits = 'tokenStatistic__totalSubscriptionsWithUnits',
  TokenStatisticTotalSupply = 'tokenStatistic__totalSupply',
  TokenStatisticUpdatedAtBlockNumber = 'tokenStatistic__updatedAtBlockNumber',
  TokenStatisticUpdatedAtTimestamp = 'tokenStatistic__updatedAtTimestamp',
  TokenCreatedAtBlockNumber = 'token__createdAtBlockNumber',
  TokenCreatedAtTimestamp = 'token__createdAtTimestamp',
  TokenDecimals = 'token__decimals',
  TokenId = 'token__id',
  TokenIsListed = 'token__isListed',
  TokenIsNativeAssetSuperToken = 'token__isNativeAssetSuperToken',
  TokenIsSuperToken = 'token__isSuperToken',
  TokenName = 'token__name',
  TokenSymbol = 'token__symbol',
  TokenUnderlyingAddress = 'token__underlyingAddress',
  TotalAmountDistributed = 'totalAmountDistributed',
  TotalAmountStreamed = 'totalAmountStreamed',
  TotalAmountTransferred = 'totalAmountTransferred',
  TotalApprovedSubscriptions = 'totalApprovedSubscriptions',
  TotalDeposit = 'totalDeposit',
  TotalNumberOfActiveIndexes = 'totalNumberOfActiveIndexes',
  TotalNumberOfActiveStreams = 'totalNumberOfActiveStreams',
  TotalNumberOfClosedStreams = 'totalNumberOfClosedStreams',
  TotalNumberOfIndexes = 'totalNumberOfIndexes',
  TotalOutflowRate = 'totalOutflowRate',
  TotalSubscriptionsWithUnits = 'totalSubscriptionsWithUnits',
  TotalSupply = 'totalSupply',
  TransactionHash = 'transactionHash',
  TriggeredByEventName = 'triggeredByEventName'
}

export type TokenStatistic_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<TokenStatistic_Filter>>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  or?: InputMaybe<Array<InputMaybe<TokenStatistic_Filter>>>;
  token?: InputMaybe<Scalars['String']>;
  tokenStatisticLogs_?: InputMaybe<TokenStatisticLog_Filter>;
  token_?: InputMaybe<Token_Filter>;
  token_contains?: InputMaybe<Scalars['String']>;
  token_contains_nocase?: InputMaybe<Scalars['String']>;
  token_ends_with?: InputMaybe<Scalars['String']>;
  token_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_gt?: InputMaybe<Scalars['String']>;
  token_gte?: InputMaybe<Scalars['String']>;
  token_in?: InputMaybe<Array<Scalars['String']>>;
  token_lt?: InputMaybe<Scalars['String']>;
  token_lte?: InputMaybe<Scalars['String']>;
  token_not?: InputMaybe<Scalars['String']>;
  token_not_contains?: InputMaybe<Scalars['String']>;
  token_not_contains_nocase?: InputMaybe<Scalars['String']>;
  token_not_ends_with?: InputMaybe<Scalars['String']>;
  token_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  token_not_in?: InputMaybe<Array<Scalars['String']>>;
  token_not_starts_with?: InputMaybe<Scalars['String']>;
  token_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token_starts_with?: InputMaybe<Scalars['String']>;
  token_starts_with_nocase?: InputMaybe<Scalars['String']>;
  totalAmountDistributedUntilUpdatedAt?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributedUntilUpdatedAt_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributedUntilUpdatedAt_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributedUntilUpdatedAt_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountDistributedUntilUpdatedAt_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributedUntilUpdatedAt_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributedUntilUpdatedAt_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountDistributedUntilUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountStreamedUntilUpdatedAt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilUpdatedAt_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilUpdatedAt_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilUpdatedAt_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountStreamedUntilUpdatedAt_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilUpdatedAt_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilUpdatedAt_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountStreamedUntilUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountTransferredUntilUpdatedAt?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferredUntilUpdatedAt_gt?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferredUntilUpdatedAt_gte?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferredUntilUpdatedAt_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalAmountTransferredUntilUpdatedAt_lt?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferredUntilUpdatedAt_lte?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferredUntilUpdatedAt_not?: InputMaybe<Scalars['BigInt']>;
  totalAmountTransferredUntilUpdatedAt_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalApprovedSubscriptions?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_gt?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_gte?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_in?: InputMaybe<Array<Scalars['Int']>>;
  totalApprovedSubscriptions_lt?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_lte?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_not?: InputMaybe<Scalars['Int']>;
  totalApprovedSubscriptions_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalDeposit?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_gt?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_gte?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalDeposit_lt?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_lte?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_not?: InputMaybe<Scalars['BigInt']>;
  totalDeposit_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalNumberOfActiveIndexes?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveIndexes_gt?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveIndexes_gte?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveIndexes_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfActiveIndexes_lt?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveIndexes_lte?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveIndexes_not?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveIndexes_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfActiveStreams?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_gt?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_gte?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfActiveStreams_lt?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_lte?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_not?: InputMaybe<Scalars['Int']>;
  totalNumberOfActiveStreams_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfClosedStreams?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_gt?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_gte?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfClosedStreams_lt?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_lte?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_not?: InputMaybe<Scalars['Int']>;
  totalNumberOfClosedStreams_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfIndexes?: InputMaybe<Scalars['Int']>;
  totalNumberOfIndexes_gt?: InputMaybe<Scalars['Int']>;
  totalNumberOfIndexes_gte?: InputMaybe<Scalars['Int']>;
  totalNumberOfIndexes_in?: InputMaybe<Array<Scalars['Int']>>;
  totalNumberOfIndexes_lt?: InputMaybe<Scalars['Int']>;
  totalNumberOfIndexes_lte?: InputMaybe<Scalars['Int']>;
  totalNumberOfIndexes_not?: InputMaybe<Scalars['Int']>;
  totalNumberOfIndexes_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalOutflowRate?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_gt?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_gte?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalOutflowRate_lt?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_lte?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_not?: InputMaybe<Scalars['BigInt']>;
  totalOutflowRate_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalSubscriptionsWithUnits?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_gt?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_gte?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_in?: InputMaybe<Array<Scalars['Int']>>;
  totalSubscriptionsWithUnits_lt?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_lte?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_not?: InputMaybe<Scalars['Int']>;
  totalSubscriptionsWithUnits_not_in?: InputMaybe<Array<Scalars['Int']>>;
  totalSupply?: InputMaybe<Scalars['BigInt']>;
  totalSupply_gt?: InputMaybe<Scalars['BigInt']>;
  totalSupply_gte?: InputMaybe<Scalars['BigInt']>;
  totalSupply_in?: InputMaybe<Array<Scalars['BigInt']>>;
  totalSupply_lt?: InputMaybe<Scalars['BigInt']>;
  totalSupply_lte?: InputMaybe<Scalars['BigInt']>;
  totalSupply_not?: InputMaybe<Scalars['BigInt']>;
  totalSupply_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  updatedAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  updatedAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum TokenStatistic_OrderBy {
  Id = 'id',
  Token = 'token',
  TokenStatisticLogs = 'tokenStatisticLogs',
  TokenCreatedAtBlockNumber = 'token__createdAtBlockNumber',
  TokenCreatedAtTimestamp = 'token__createdAtTimestamp',
  TokenDecimals = 'token__decimals',
  TokenId = 'token__id',
  TokenIsListed = 'token__isListed',
  TokenIsNativeAssetSuperToken = 'token__isNativeAssetSuperToken',
  TokenIsSuperToken = 'token__isSuperToken',
  TokenName = 'token__name',
  TokenSymbol = 'token__symbol',
  TokenUnderlyingAddress = 'token__underlyingAddress',
  TotalAmountDistributedUntilUpdatedAt = 'totalAmountDistributedUntilUpdatedAt',
  TotalAmountStreamedUntilUpdatedAt = 'totalAmountStreamedUntilUpdatedAt',
  TotalAmountTransferredUntilUpdatedAt = 'totalAmountTransferredUntilUpdatedAt',
  TotalApprovedSubscriptions = 'totalApprovedSubscriptions',
  TotalDeposit = 'totalDeposit',
  TotalNumberOfActiveIndexes = 'totalNumberOfActiveIndexes',
  TotalNumberOfActiveStreams = 'totalNumberOfActiveStreams',
  TotalNumberOfClosedStreams = 'totalNumberOfClosedStreams',
  TotalNumberOfIndexes = 'totalNumberOfIndexes',
  TotalOutflowRate = 'totalOutflowRate',
  TotalSubscriptionsWithUnits = 'totalSubscriptionsWithUnits',
  TotalSupply = 'totalSupply',
  UpdatedAtBlockNumber = 'updatedAtBlockNumber',
  UpdatedAtTimestamp = 'updatedAtTimestamp'
}

export type TokenUpgradedEvent = Event & {
  __typename?: 'TokenUpgradedEvent';
  account: Account;
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `account`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  amount: Scalars['BigInt'];
  blockNumber: Scalars['BigInt'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
};

export type TokenUpgradedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  account?: InputMaybe<Scalars['String']>;
  account_?: InputMaybe<Account_Filter>;
  account_contains?: InputMaybe<Scalars['String']>;
  account_contains_nocase?: InputMaybe<Scalars['String']>;
  account_ends_with?: InputMaybe<Scalars['String']>;
  account_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_gt?: InputMaybe<Scalars['String']>;
  account_gte?: InputMaybe<Scalars['String']>;
  account_in?: InputMaybe<Array<Scalars['String']>>;
  account_lt?: InputMaybe<Scalars['String']>;
  account_lte?: InputMaybe<Scalars['String']>;
  account_not?: InputMaybe<Scalars['String']>;
  account_not_contains?: InputMaybe<Scalars['String']>;
  account_not_contains_nocase?: InputMaybe<Scalars['String']>;
  account_not_ends_with?: InputMaybe<Scalars['String']>;
  account_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  account_not_in?: InputMaybe<Array<Scalars['String']>>;
  account_not_starts_with?: InputMaybe<Scalars['String']>;
  account_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  account_starts_with?: InputMaybe<Scalars['String']>;
  account_starts_with_nocase?: InputMaybe<Scalars['String']>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  amount?: InputMaybe<Scalars['BigInt']>;
  amount_gt?: InputMaybe<Scalars['BigInt']>;
  amount_gte?: InputMaybe<Scalars['BigInt']>;
  amount_in?: InputMaybe<Array<Scalars['BigInt']>>;
  amount_lt?: InputMaybe<Scalars['BigInt']>;
  amount_lte?: InputMaybe<Scalars['BigInt']>;
  amount_not?: InputMaybe<Scalars['BigInt']>;
  amount_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  and?: InputMaybe<Array<InputMaybe<TokenUpgradedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<TokenUpgradedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum TokenUpgradedEvent_OrderBy {
  Account = 'account',
  AccountCreatedAtBlockNumber = 'account__createdAtBlockNumber',
  AccountCreatedAtTimestamp = 'account__createdAtTimestamp',
  AccountId = 'account__id',
  AccountIsSuperApp = 'account__isSuperApp',
  AccountUpdatedAtBlockNumber = 'account__updatedAtBlockNumber',
  AccountUpdatedAtTimestamp = 'account__updatedAtTimestamp',
  Addresses = 'addresses',
  Amount = 'amount',
  BlockNumber = 'blockNumber',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Timestamp = 'timestamp',
  Token = 'token',
  TransactionHash = 'transactionHash'
}

export type Token_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  and?: InputMaybe<Array<InputMaybe<Token_Filter>>>;
  createdAtBlockNumber?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtBlockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_not?: InputMaybe<Scalars['BigInt']>;
  createdAtBlockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtTimestamp?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_gt?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_gte?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  createdAtTimestamp_lt?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_lte?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_not?: InputMaybe<Scalars['BigInt']>;
  createdAtTimestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  decimals?: InputMaybe<Scalars['Int']>;
  decimals_gt?: InputMaybe<Scalars['Int']>;
  decimals_gte?: InputMaybe<Scalars['Int']>;
  decimals_in?: InputMaybe<Array<Scalars['Int']>>;
  decimals_lt?: InputMaybe<Scalars['Int']>;
  decimals_lte?: InputMaybe<Scalars['Int']>;
  decimals_not?: InputMaybe<Scalars['Int']>;
  decimals_not_in?: InputMaybe<Array<Scalars['Int']>>;
  governanceConfig?: InputMaybe<Scalars['String']>;
  governanceConfig_?: InputMaybe<TokenGovernanceConfig_Filter>;
  governanceConfig_contains?: InputMaybe<Scalars['String']>;
  governanceConfig_contains_nocase?: InputMaybe<Scalars['String']>;
  governanceConfig_ends_with?: InputMaybe<Scalars['String']>;
  governanceConfig_ends_with_nocase?: InputMaybe<Scalars['String']>;
  governanceConfig_gt?: InputMaybe<Scalars['String']>;
  governanceConfig_gte?: InputMaybe<Scalars['String']>;
  governanceConfig_in?: InputMaybe<Array<Scalars['String']>>;
  governanceConfig_lt?: InputMaybe<Scalars['String']>;
  governanceConfig_lte?: InputMaybe<Scalars['String']>;
  governanceConfig_not?: InputMaybe<Scalars['String']>;
  governanceConfig_not_contains?: InputMaybe<Scalars['String']>;
  governanceConfig_not_contains_nocase?: InputMaybe<Scalars['String']>;
  governanceConfig_not_ends_with?: InputMaybe<Scalars['String']>;
  governanceConfig_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  governanceConfig_not_in?: InputMaybe<Array<Scalars['String']>>;
  governanceConfig_not_starts_with?: InputMaybe<Scalars['String']>;
  governanceConfig_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  governanceConfig_starts_with?: InputMaybe<Scalars['String']>;
  governanceConfig_starts_with_nocase?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  isListed?: InputMaybe<Scalars['Boolean']>;
  isListed_in?: InputMaybe<Array<Scalars['Boolean']>>;
  isListed_not?: InputMaybe<Scalars['Boolean']>;
  isListed_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  isNativeAssetSuperToken?: InputMaybe<Scalars['Boolean']>;
  isNativeAssetSuperToken_in?: InputMaybe<Array<Scalars['Boolean']>>;
  isNativeAssetSuperToken_not?: InputMaybe<Scalars['Boolean']>;
  isNativeAssetSuperToken_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  isSuperToken?: InputMaybe<Scalars['Boolean']>;
  isSuperToken_in?: InputMaybe<Array<Scalars['Boolean']>>;
  isSuperToken_not?: InputMaybe<Scalars['Boolean']>;
  isSuperToken_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<Token_Filter>>>;
  symbol?: InputMaybe<Scalars['String']>;
  symbol_contains?: InputMaybe<Scalars['String']>;
  symbol_contains_nocase?: InputMaybe<Scalars['String']>;
  symbol_ends_with?: InputMaybe<Scalars['String']>;
  symbol_ends_with_nocase?: InputMaybe<Scalars['String']>;
  symbol_gt?: InputMaybe<Scalars['String']>;
  symbol_gte?: InputMaybe<Scalars['String']>;
  symbol_in?: InputMaybe<Array<Scalars['String']>>;
  symbol_lt?: InputMaybe<Scalars['String']>;
  symbol_lte?: InputMaybe<Scalars['String']>;
  symbol_not?: InputMaybe<Scalars['String']>;
  symbol_not_contains?: InputMaybe<Scalars['String']>;
  symbol_not_contains_nocase?: InputMaybe<Scalars['String']>;
  symbol_not_ends_with?: InputMaybe<Scalars['String']>;
  symbol_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  symbol_not_in?: InputMaybe<Array<Scalars['String']>>;
  symbol_not_starts_with?: InputMaybe<Scalars['String']>;
  symbol_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  symbol_starts_with?: InputMaybe<Scalars['String']>;
  symbol_starts_with_nocase?: InputMaybe<Scalars['String']>;
  underlyingAddress?: InputMaybe<Scalars['Bytes']>;
  underlyingAddress_contains?: InputMaybe<Scalars['Bytes']>;
  underlyingAddress_gt?: InputMaybe<Scalars['Bytes']>;
  underlyingAddress_gte?: InputMaybe<Scalars['Bytes']>;
  underlyingAddress_in?: InputMaybe<Array<Scalars['Bytes']>>;
  underlyingAddress_lt?: InputMaybe<Scalars['Bytes']>;
  underlyingAddress_lte?: InputMaybe<Scalars['Bytes']>;
  underlyingAddress_not?: InputMaybe<Scalars['Bytes']>;
  underlyingAddress_not_contains?: InputMaybe<Scalars['Bytes']>;
  underlyingAddress_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  underlyingToken?: InputMaybe<Scalars['String']>;
  underlyingToken_?: InputMaybe<Token_Filter>;
  underlyingToken_contains?: InputMaybe<Scalars['String']>;
  underlyingToken_contains_nocase?: InputMaybe<Scalars['String']>;
  underlyingToken_ends_with?: InputMaybe<Scalars['String']>;
  underlyingToken_ends_with_nocase?: InputMaybe<Scalars['String']>;
  underlyingToken_gt?: InputMaybe<Scalars['String']>;
  underlyingToken_gte?: InputMaybe<Scalars['String']>;
  underlyingToken_in?: InputMaybe<Array<Scalars['String']>>;
  underlyingToken_lt?: InputMaybe<Scalars['String']>;
  underlyingToken_lte?: InputMaybe<Scalars['String']>;
  underlyingToken_not?: InputMaybe<Scalars['String']>;
  underlyingToken_not_contains?: InputMaybe<Scalars['String']>;
  underlyingToken_not_contains_nocase?: InputMaybe<Scalars['String']>;
  underlyingToken_not_ends_with?: InputMaybe<Scalars['String']>;
  underlyingToken_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  underlyingToken_not_in?: InputMaybe<Array<Scalars['String']>>;
  underlyingToken_not_starts_with?: InputMaybe<Scalars['String']>;
  underlyingToken_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  underlyingToken_starts_with?: InputMaybe<Scalars['String']>;
  underlyingToken_starts_with_nocase?: InputMaybe<Scalars['String']>;
};

export enum Token_OrderBy {
  CreatedAtBlockNumber = 'createdAtBlockNumber',
  CreatedAtTimestamp = 'createdAtTimestamp',
  Decimals = 'decimals',
  GovernanceConfig = 'governanceConfig',
  GovernanceConfigCreatedAtBlockNumber = 'governanceConfig__createdAtBlockNumber',
  GovernanceConfigCreatedAtTimestamp = 'governanceConfig__createdAtTimestamp',
  GovernanceConfigId = 'governanceConfig__id',
  GovernanceConfigIsDefault = 'governanceConfig__isDefault',
  GovernanceConfigLiquidationPeriod = 'governanceConfig__liquidationPeriod',
  GovernanceConfigMinimumDeposit = 'governanceConfig__minimumDeposit',
  GovernanceConfigPatricianPeriod = 'governanceConfig__patricianPeriod',
  GovernanceConfigRewardAddress = 'governanceConfig__rewardAddress',
  GovernanceConfigUpdatedAtBlockNumber = 'governanceConfig__updatedAtBlockNumber',
  GovernanceConfigUpdatedAtTimestamp = 'governanceConfig__updatedAtTimestamp',
  Id = 'id',
  IsListed = 'isListed',
  IsNativeAssetSuperToken = 'isNativeAssetSuperToken',
  IsSuperToken = 'isSuperToken',
  Name = 'name',
  Symbol = 'symbol',
  UnderlyingAddress = 'underlyingAddress',
  UnderlyingToken = 'underlyingToken',
  UnderlyingTokenCreatedAtBlockNumber = 'underlyingToken__createdAtBlockNumber',
  UnderlyingTokenCreatedAtTimestamp = 'underlyingToken__createdAtTimestamp',
  UnderlyingTokenDecimals = 'underlyingToken__decimals',
  UnderlyingTokenId = 'underlyingToken__id',
  UnderlyingTokenIsListed = 'underlyingToken__isListed',
  UnderlyingTokenIsNativeAssetSuperToken = 'underlyingToken__isNativeAssetSuperToken',
  UnderlyingTokenIsSuperToken = 'underlyingToken__isSuperToken',
  UnderlyingTokenName = 'underlyingToken__name',
  UnderlyingTokenSymbol = 'underlyingToken__symbol',
  UnderlyingTokenUnderlyingAddress = 'underlyingToken__underlyingAddress'
}

export type TransactionError = {
  __typename?: 'TransactionError';
  reason: TransactionErrorReasons;
  txReceipt?: Maybe<TransactionReceipt>;
};

/** Transaction error reason */
export enum TransactionErrorReasons {
  Reverted = 'REVERTED'
}

export type TransactionIndexedResult = {
  __typename?: 'TransactionIndexedResult';
  indexed: Scalars['Boolean'];
  /** Publications can be indexed but the ipfs link for example not findable for x time. This allows you to work that out for publications. If its not a publication tx then it always be null. */
  metadataStatus?: Maybe<PublicationMetadataStatus>;
  txHash: Scalars['TxHash'];
  txReceipt?: Maybe<TransactionReceipt>;
};

export type TransactionReceipt = {
  __typename?: 'TransactionReceipt';
  blockHash: Scalars['String'];
  blockNumber: Scalars['Int'];
  byzantium: Scalars['Boolean'];
  confirmations: Scalars['Int'];
  contractAddress?: Maybe<Scalars['ContractAddress']>;
  cumulativeGasUsed: Scalars['String'];
  effectiveGasPrice: Scalars['String'];
  from: Scalars['EthereumAddress'];
  gasUsed: Scalars['String'];
  logs: Array<Log>;
  logsBloom: Scalars['String'];
  root?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['Int']>;
  to?: Maybe<Scalars['EthereumAddress']>;
  transactionHash: Scalars['TxHash'];
  transactionIndex: Scalars['Int'];
  type: Scalars['Int'];
};

export type TransactionResult = TransactionError | TransactionIndexedResult;

export type TransferEvent = Event & {
  __typename?: 'TransferEvent';
  /**
   * Contains the addresses that were impacted by this event:
   * addresses[0] = `token` (superToken)
   * addresses[1] = `from`
   * addresses[2] = `to`
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  from: Account;
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  id: Scalars['ID'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  timestamp: Scalars['BigInt'];
  to: Account;
  token: Scalars['Bytes'];
  transactionHash: Scalars['Bytes'];
  value: Scalars['BigInt'];
};

export type TransferEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<TransferEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  from?: InputMaybe<Scalars['String']>;
  from_?: InputMaybe<Account_Filter>;
  from_contains?: InputMaybe<Scalars['String']>;
  from_contains_nocase?: InputMaybe<Scalars['String']>;
  from_ends_with?: InputMaybe<Scalars['String']>;
  from_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_gt?: InputMaybe<Scalars['String']>;
  from_gte?: InputMaybe<Scalars['String']>;
  from_in?: InputMaybe<Array<Scalars['String']>>;
  from_lt?: InputMaybe<Scalars['String']>;
  from_lte?: InputMaybe<Scalars['String']>;
  from_not?: InputMaybe<Scalars['String']>;
  from_not_contains?: InputMaybe<Scalars['String']>;
  from_not_contains_nocase?: InputMaybe<Scalars['String']>;
  from_not_ends_with?: InputMaybe<Scalars['String']>;
  from_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  from_not_in?: InputMaybe<Array<Scalars['String']>>;
  from_not_starts_with?: InputMaybe<Scalars['String']>;
  from_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  from_starts_with?: InputMaybe<Scalars['String']>;
  from_starts_with_nocase?: InputMaybe<Scalars['String']>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<TransferEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  to?: InputMaybe<Scalars['String']>;
  to_?: InputMaybe<Account_Filter>;
  to_contains?: InputMaybe<Scalars['String']>;
  to_contains_nocase?: InputMaybe<Scalars['String']>;
  to_ends_with?: InputMaybe<Scalars['String']>;
  to_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_gt?: InputMaybe<Scalars['String']>;
  to_gte?: InputMaybe<Scalars['String']>;
  to_in?: InputMaybe<Array<Scalars['String']>>;
  to_lt?: InputMaybe<Scalars['String']>;
  to_lte?: InputMaybe<Scalars['String']>;
  to_not?: InputMaybe<Scalars['String']>;
  to_not_contains?: InputMaybe<Scalars['String']>;
  to_not_contains_nocase?: InputMaybe<Scalars['String']>;
  to_not_ends_with?: InputMaybe<Scalars['String']>;
  to_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  to_not_in?: InputMaybe<Array<Scalars['String']>>;
  to_not_starts_with?: InputMaybe<Scalars['String']>;
  to_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  to_starts_with?: InputMaybe<Scalars['String']>;
  to_starts_with_nocase?: InputMaybe<Scalars['String']>;
  token?: InputMaybe<Scalars['Bytes']>;
  token_contains?: InputMaybe<Scalars['Bytes']>;
  token_gt?: InputMaybe<Scalars['Bytes']>;
  token_gte?: InputMaybe<Scalars['Bytes']>;
  token_in?: InputMaybe<Array<Scalars['Bytes']>>;
  token_lt?: InputMaybe<Scalars['Bytes']>;
  token_lte?: InputMaybe<Scalars['Bytes']>;
  token_not?: InputMaybe<Scalars['Bytes']>;
  token_not_contains?: InputMaybe<Scalars['Bytes']>;
  token_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  value?: InputMaybe<Scalars['BigInt']>;
  value_gt?: InputMaybe<Scalars['BigInt']>;
  value_gte?: InputMaybe<Scalars['BigInt']>;
  value_in?: InputMaybe<Array<Scalars['BigInt']>>;
  value_lt?: InputMaybe<Scalars['BigInt']>;
  value_lte?: InputMaybe<Scalars['BigInt']>;
  value_not?: InputMaybe<Scalars['BigInt']>;
  value_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
};

export enum TransferEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  From = 'from',
  FromCreatedAtBlockNumber = 'from__createdAtBlockNumber',
  FromCreatedAtTimestamp = 'from__createdAtTimestamp',
  FromId = 'from__id',
  FromIsSuperApp = 'from__isSuperApp',
  FromUpdatedAtBlockNumber = 'from__updatedAtBlockNumber',
  FromUpdatedAtTimestamp = 'from__updatedAtTimestamp',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  Id = 'id',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  Timestamp = 'timestamp',
  To = 'to',
  ToCreatedAtBlockNumber = 'to__createdAtBlockNumber',
  ToCreatedAtTimestamp = 'to__createdAtTimestamp',
  ToId = 'to__id',
  ToIsSuperApp = 'to__isSuperApp',
  ToUpdatedAtBlockNumber = 'to__updatedAtBlockNumber',
  ToUpdatedAtTimestamp = 'to__updatedAtTimestamp',
  Token = 'token',
  TransactionHash = 'transactionHash',
  Value = 'value'
}

export type TrustedForwarderChangedEvent = Event & {
  __typename?: 'TrustedForwarderChangedEvent';
  /**
   * Empty addresses array.
   *
   */
  addresses: Array<Scalars['Bytes']>;
  blockNumber: Scalars['BigInt'];
  enabled: Scalars['Boolean'];
  forwarder: Scalars['Bytes'];
  gasPrice: Scalars['BigInt'];
  gasUsed: Scalars['BigInt'];
  /**
   * The address of the governance contract the event was emitted from.
   *
   */
  governanceAddress: Scalars['Bytes'];
  host: Scalars['Bytes'];
  id: Scalars['ID'];
  isKeySet: Scalars['Boolean'];
  logIndex: Scalars['BigInt'];
  name: Scalars['String'];
  order: Scalars['BigInt'];
  superToken: Scalars['Bytes'];
  timestamp: Scalars['BigInt'];
  transactionHash: Scalars['Bytes'];
};

export type TrustedForwarderChangedEvent_Filter = {
  /** Filter for the block changed event. */
  _change_block?: InputMaybe<BlockChangedFilter>;
  addresses?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains?: InputMaybe<Array<Scalars['Bytes']>>;
  addresses_not_contains_nocase?: InputMaybe<Array<Scalars['Bytes']>>;
  and?: InputMaybe<Array<InputMaybe<TrustedForwarderChangedEvent_Filter>>>;
  blockNumber?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_gte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_in?: InputMaybe<Array<Scalars['BigInt']>>;
  blockNumber_lt?: InputMaybe<Scalars['BigInt']>;
  blockNumber_lte?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not?: InputMaybe<Scalars['BigInt']>;
  blockNumber_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  enabled?: InputMaybe<Scalars['Boolean']>;
  enabled_in?: InputMaybe<Array<Scalars['Boolean']>>;
  enabled_not?: InputMaybe<Scalars['Boolean']>;
  enabled_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  forwarder?: InputMaybe<Scalars['Bytes']>;
  forwarder_contains?: InputMaybe<Scalars['Bytes']>;
  forwarder_gt?: InputMaybe<Scalars['Bytes']>;
  forwarder_gte?: InputMaybe<Scalars['Bytes']>;
  forwarder_in?: InputMaybe<Array<Scalars['Bytes']>>;
  forwarder_lt?: InputMaybe<Scalars['Bytes']>;
  forwarder_lte?: InputMaybe<Scalars['Bytes']>;
  forwarder_not?: InputMaybe<Scalars['Bytes']>;
  forwarder_not_contains?: InputMaybe<Scalars['Bytes']>;
  forwarder_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  gasPrice?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_gte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasPrice_lt?: InputMaybe<Scalars['BigInt']>;
  gasPrice_lte?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not?: InputMaybe<Scalars['BigInt']>;
  gasPrice_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_gte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_in?: InputMaybe<Array<Scalars['BigInt']>>;
  gasUsed_lt?: InputMaybe<Scalars['BigInt']>;
  gasUsed_lte?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not?: InputMaybe<Scalars['BigInt']>;
  gasUsed_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  governanceAddress?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_contains?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_gt?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_gte?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_in?: InputMaybe<Array<Scalars['Bytes']>>;
  governanceAddress_lt?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_lte?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not_contains?: InputMaybe<Scalars['Bytes']>;
  governanceAddress_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  host?: InputMaybe<Scalars['Bytes']>;
  host_contains?: InputMaybe<Scalars['Bytes']>;
  host_gt?: InputMaybe<Scalars['Bytes']>;
  host_gte?: InputMaybe<Scalars['Bytes']>;
  host_in?: InputMaybe<Array<Scalars['Bytes']>>;
  host_lt?: InputMaybe<Scalars['Bytes']>;
  host_lte?: InputMaybe<Scalars['Bytes']>;
  host_not?: InputMaybe<Scalars['Bytes']>;
  host_not_contains?: InputMaybe<Scalars['Bytes']>;
  host_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  id?: InputMaybe<Scalars['ID']>;
  id_gt?: InputMaybe<Scalars['ID']>;
  id_gte?: InputMaybe<Scalars['ID']>;
  id_in?: InputMaybe<Array<Scalars['ID']>>;
  id_lt?: InputMaybe<Scalars['ID']>;
  id_lte?: InputMaybe<Scalars['ID']>;
  id_not?: InputMaybe<Scalars['ID']>;
  id_not_in?: InputMaybe<Array<Scalars['ID']>>;
  isKeySet?: InputMaybe<Scalars['Boolean']>;
  isKeySet_in?: InputMaybe<Array<Scalars['Boolean']>>;
  isKeySet_not?: InputMaybe<Scalars['Boolean']>;
  isKeySet_not_in?: InputMaybe<Array<Scalars['Boolean']>>;
  logIndex?: InputMaybe<Scalars['BigInt']>;
  logIndex_gt?: InputMaybe<Scalars['BigInt']>;
  logIndex_gte?: InputMaybe<Scalars['BigInt']>;
  logIndex_in?: InputMaybe<Array<Scalars['BigInt']>>;
  logIndex_lt?: InputMaybe<Scalars['BigInt']>;
  logIndex_lte?: InputMaybe<Scalars['BigInt']>;
  logIndex_not?: InputMaybe<Scalars['BigInt']>;
  logIndex_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  name?: InputMaybe<Scalars['String']>;
  name_contains?: InputMaybe<Scalars['String']>;
  name_contains_nocase?: InputMaybe<Scalars['String']>;
  name_ends_with?: InputMaybe<Scalars['String']>;
  name_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_gt?: InputMaybe<Scalars['String']>;
  name_gte?: InputMaybe<Scalars['String']>;
  name_in?: InputMaybe<Array<Scalars['String']>>;
  name_lt?: InputMaybe<Scalars['String']>;
  name_lte?: InputMaybe<Scalars['String']>;
  name_not?: InputMaybe<Scalars['String']>;
  name_not_contains?: InputMaybe<Scalars['String']>;
  name_not_contains_nocase?: InputMaybe<Scalars['String']>;
  name_not_ends_with?: InputMaybe<Scalars['String']>;
  name_not_ends_with_nocase?: InputMaybe<Scalars['String']>;
  name_not_in?: InputMaybe<Array<Scalars['String']>>;
  name_not_starts_with?: InputMaybe<Scalars['String']>;
  name_not_starts_with_nocase?: InputMaybe<Scalars['String']>;
  name_starts_with?: InputMaybe<Scalars['String']>;
  name_starts_with_nocase?: InputMaybe<Scalars['String']>;
  or?: InputMaybe<Array<InputMaybe<TrustedForwarderChangedEvent_Filter>>>;
  order?: InputMaybe<Scalars['BigInt']>;
  order_gt?: InputMaybe<Scalars['BigInt']>;
  order_gte?: InputMaybe<Scalars['BigInt']>;
  order_in?: InputMaybe<Array<Scalars['BigInt']>>;
  order_lt?: InputMaybe<Scalars['BigInt']>;
  order_lte?: InputMaybe<Scalars['BigInt']>;
  order_not?: InputMaybe<Scalars['BigInt']>;
  order_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  superToken?: InputMaybe<Scalars['Bytes']>;
  superToken_contains?: InputMaybe<Scalars['Bytes']>;
  superToken_gt?: InputMaybe<Scalars['Bytes']>;
  superToken_gte?: InputMaybe<Scalars['Bytes']>;
  superToken_in?: InputMaybe<Array<Scalars['Bytes']>>;
  superToken_lt?: InputMaybe<Scalars['Bytes']>;
  superToken_lte?: InputMaybe<Scalars['Bytes']>;
  superToken_not?: InputMaybe<Scalars['Bytes']>;
  superToken_not_contains?: InputMaybe<Scalars['Bytes']>;
  superToken_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
  timestamp?: InputMaybe<Scalars['BigInt']>;
  timestamp_gt?: InputMaybe<Scalars['BigInt']>;
  timestamp_gte?: InputMaybe<Scalars['BigInt']>;
  timestamp_in?: InputMaybe<Array<Scalars['BigInt']>>;
  timestamp_lt?: InputMaybe<Scalars['BigInt']>;
  timestamp_lte?: InputMaybe<Scalars['BigInt']>;
  timestamp_not?: InputMaybe<Scalars['BigInt']>;
  timestamp_not_in?: InputMaybe<Array<Scalars['BigInt']>>;
  transactionHash?: InputMaybe<Scalars['Bytes']>;
  transactionHash_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_gte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_in?: InputMaybe<Array<Scalars['Bytes']>>;
  transactionHash_lt?: InputMaybe<Scalars['Bytes']>;
  transactionHash_lte?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_contains?: InputMaybe<Scalars['Bytes']>;
  transactionHash_not_in?: InputMaybe<Array<Scalars['Bytes']>>;
};

export enum TrustedForwarderChangedEvent_OrderBy {
  Addresses = 'addresses',
  BlockNumber = 'blockNumber',
  Enabled = 'enabled',
  Forwarder = 'forwarder',
  GasPrice = 'gasPrice',
  GasUsed = 'gasUsed',
  GovernanceAddress = 'governanceAddress',
  Host = 'host',
  Id = 'id',
  IsKeySet = 'isKeySet',
  LogIndex = 'logIndex',
  Name = 'name',
  Order = 'order',
  SuperToken = 'superToken',
  Timestamp = 'timestamp',
  TransactionHash = 'transactionHash'
}

export type TypedDataOptions = {
  /** If you wish to override the nonce for the sig if you want to do some clever stuff in the client */
  overrideSigNonce: Scalars['Nonce'];
};

export type UnfollowRequest = {
  profile: Scalars['ProfileId'];
};

export type UnknownCollectModuleParams = {
  contractAddress: Scalars['ContractAddress'];
  /** The encoded data to submit with the module */
  data: Scalars['BlockchainData'];
};

export type UnknownCollectModuleSettings = {
  __typename?: 'UnknownCollectModuleSettings';
  /** The data used to setup the module which you can decode with your known ABI  */
  collectModuleReturnData: Scalars['CollectModuleData'];
  contractAddress: Scalars['ContractAddress'];
  /** The collect modules enum */
  type: CollectModules;
};

export type UnknownFollowModuleParams = {
  contractAddress: Scalars['ContractAddress'];
  /** The encoded data to submit with the module */
  data: Scalars['BlockchainData'];
};

export type UnknownFollowModuleRedeemParams = {
  /** The encoded data to submit with the module */
  data: Scalars['BlockchainData'];
};

export type UnknownFollowModuleSettings = {
  __typename?: 'UnknownFollowModuleSettings';
  contractAddress: Scalars['ContractAddress'];
  /** The data used to setup the module which you can decode with your known ABI  */
  followModuleReturnData: Scalars['FollowModuleData'];
  /** The follow modules enum */
  type: FollowModules;
};

export type UnknownReferenceModuleParams = {
  contractAddress: Scalars['ContractAddress'];
  /** The encoded data to submit with the module */
  data: Scalars['BlockchainData'];
};

export type UnknownReferenceModuleSettings = {
  __typename?: 'UnknownReferenceModuleSettings';
  contractAddress: Scalars['ContractAddress'];
  /** The data used to setup the module which you can decode with your known ABI  */
  referenceModuleReturnData: Scalars['ReferenceModuleData'];
  /** The reference modules enum */
  type: ReferenceModules;
};

export type UpdateProfileImageRequest = {
  /** The nft data */
  nftData?: InputMaybe<NftData>;
  profileId: Scalars['ProfileId'];
  /** The url to the image if offline */
  url?: InputMaybe<Scalars['Url']>;
};

export type UserSigNonces = {
  __typename?: 'UserSigNonces';
  lensHubOnChainSigNonce: Scalars['Nonce'];
  peripheryOnChainSigNonce: Scalars['Nonce'];
};

export type ValidatePublicationMetadataRequest = {
  metadatav1?: InputMaybe<PublicationMetadataV1Input>;
  metadatav2?: InputMaybe<PublicationMetadataV2Input>;
};

/** The access request */
export type VerifyRequest = {
  /** The access token */
  accessToken: Scalars['Jwt'];
};

export type Wallet = {
  __typename?: 'Wallet';
  address: Scalars['EthereumAddress'];
  /** The default profile for the wallet for now it is just their first profile, this will be the default profile they picked soon enough */
  defaultProfile?: Maybe<Profile>;
};

export type WhoCollectedPublicationRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  /** Internal publication id */
  publicationId: Scalars['InternalPublicationId'];
};

export type WhoReactedPublicationRequest = {
  cursor?: InputMaybe<Scalars['Cursor']>;
  limit?: InputMaybe<Scalars['LimitScalar']>;
  /** Internal publication id */
  publicationId: Scalars['InternalPublicationId'];
};

/** The Profile */
export type WhoReactedResult = {
  __typename?: 'WhoReactedResult';
  profile: Profile;
  /** The reaction */
  reaction: ReactionTypes;
  /** The reaction */
  reactionAt: Scalars['DateTime'];
  /** The reaction id */
  reactionId: Scalars['ReactionId'];
};

export type WorldcoinIdentity = {
  __typename?: 'WorldcoinIdentity';
  /** If the profile has verified as a user */
  isHuman: Scalars['Boolean'];
};

/** The worldcoin signal type */
export enum WorldcoinPhoneVerifyType {
  Orb = 'ORB',
  Phone = 'PHONE'
}

export type WorldcoinPhoneVerifyWebhookRequest = {
  nullifierHash: Scalars['String'];
  signal: Scalars['EthereumAddress'];
  signalType: WorldcoinPhoneVerifyType;
};

export type _Block_ = {
  __typename?: '_Block_';
  /** The hash of the block */
  hash?: Maybe<Scalars['Bytes']>;
  /** The block number */
  number: Scalars['Int'];
  /** Integer representation of the timestamp stored in blocks for the chain */
  timestamp?: Maybe<Scalars['Int']>;
};

/** The type for the top-level _meta field */
export type _Meta_ = {
  __typename?: '_Meta_';
  /**
   * Information about a specific subgraph block. The hash of the block
   * will be null if the _meta field has a block constraint that asks for
   * a block number. It will be filled if the _meta field has no block constraint
   * and therefore asks for the latest  block
   *
   */
  block: _Block_;
  /** The deployment ID */
  deployment: Scalars['String'];
  /** If `true`, the subgraph encountered indexing errors at some past block */
  hasIndexingErrors: Scalars['Boolean'];
};

export enum _SubgraphErrorPolicy_ {
  /** Data will be returned even if the subgraph has indexing errors */
  Allow = 'allow',
  /** If the subgraph has indexing errors, data will be omitted. The default. */
  Deny = 'deny'
}

type CollectModuleFields_AaveFeeCollectModuleSettings_Fragment = { __typename?: 'AaveFeeCollectModuleSettings' };

type CollectModuleFields_Erc4626FeeCollectModuleSettings_Fragment = { __typename?: 'ERC4626FeeCollectModuleSettings' };

type CollectModuleFields_FeeCollectModuleSettings_Fragment = { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } };

type CollectModuleFields_FreeCollectModuleSettings_Fragment = { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean };

type CollectModuleFields_LimitedFeeCollectModuleSettings_Fragment = { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } };

type CollectModuleFields_LimitedTimedFeeCollectModuleSettings_Fragment = { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } };

type CollectModuleFields_MultirecipientFeeCollectModuleSettings_Fragment = { __typename?: 'MultirecipientFeeCollectModuleSettings' };

type CollectModuleFields_RevertCollectModuleSettings_Fragment = { __typename?: 'RevertCollectModuleSettings' };

type CollectModuleFields_SimpleCollectModuleSettings_Fragment = { __typename?: 'SimpleCollectModuleSettings' };

type CollectModuleFields_TimedFeeCollectModuleSettings_Fragment = { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } };

type CollectModuleFields_UnknownCollectModuleSettings_Fragment = { __typename?: 'UnknownCollectModuleSettings' };

export type CollectModuleFieldsFragment = CollectModuleFields_AaveFeeCollectModuleSettings_Fragment | CollectModuleFields_Erc4626FeeCollectModuleSettings_Fragment | CollectModuleFields_FeeCollectModuleSettings_Fragment | CollectModuleFields_FreeCollectModuleSettings_Fragment | CollectModuleFields_LimitedFeeCollectModuleSettings_Fragment | CollectModuleFields_LimitedTimedFeeCollectModuleSettings_Fragment | CollectModuleFields_MultirecipientFeeCollectModuleSettings_Fragment | CollectModuleFields_RevertCollectModuleSettings_Fragment | CollectModuleFields_SimpleCollectModuleSettings_Fragment | CollectModuleFields_TimedFeeCollectModuleSettings_Fragment | CollectModuleFields_UnknownCollectModuleSettings_Fragment;

export type CommentFieldsFragment = { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, commentOn?: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', handle: any } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, mainPost: { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } | null };

export type MetadataFieldsFragment = { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> };

export type MirrorFieldsFragment = { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } };

export type PostFieldsFragment = { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } };

export type ProfileFieldsFragment = { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null };

type RelayerResultFields_RelayError_Fragment = { __typename?: 'RelayError', reason: RelayErrorReasons };

type RelayerResultFields_RelayerResult_Fragment = { __typename?: 'RelayerResult', txHash: any, txId: any };

export type RelayerResultFieldsFragment = RelayerResultFields_RelayError_Fragment | RelayerResultFields_RelayerResult_Fragment;

export type StatsFieldsFragment = { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number };

export type AddReactionMutationVariables = Exact<{
  request: ReactionRequest;
}>;


export type AddReactionMutation = { __typename?: 'Mutation', addReaction?: any | null };

export type AuthenticateMutationVariables = Exact<{
  request: SignedAuthChallenge;
}>;


export type AuthenticateMutation = { __typename?: 'Mutation', authenticate: { __typename?: 'AuthenticationResult', accessToken: any, refreshToken: any } };

export type BroadcastMutationVariables = Exact<{
  request: BroadcastRequest;
}>;


export type BroadcastMutation = { __typename?: 'Mutation', broadcast: { __typename?: 'RelayError', reason: RelayErrorReasons } | { __typename?: 'RelayerResult', txHash: any, txId: any } };

export type CreateBurnProfileTypedDataMutationVariables = Exact<{
  options?: InputMaybe<TypedDataOptions>;
  request: BurnProfileRequest;
}>;


export type CreateBurnProfileTypedDataMutation = { __typename?: 'Mutation', createBurnProfileTypedData: { __typename?: 'CreateBurnProfileBroadcastItemResult', id: any, expiresAt: any, typedData: { __typename?: 'CreateBurnEIP712TypedData', domain: { __typename?: 'EIP712TypedDataDomain', name: string, chainId: any, version: string, verifyingContract: any }, types: { __typename?: 'CreateBurnEIP712TypedDataTypes', BurnWithSig: Array<{ __typename?: 'EIP712TypedDataField', name: string, type: string }> }, value: { __typename?: 'CreateBurnEIP712TypedDataValue', nonce: any, deadline: any, tokenId: string } } } };

export type CreateCollectTypedDataMutationVariables = Exact<{
  options?: InputMaybe<TypedDataOptions>;
  request: CreateCollectRequest;
}>;


export type CreateCollectTypedDataMutation = { __typename?: 'Mutation', createCollectTypedData: { __typename?: 'CreateCollectBroadcastItemResult', id: any, expiresAt: any, typedData: { __typename?: 'CreateCollectEIP712TypedData', types: { __typename?: 'CreateCollectEIP712TypedDataTypes', CollectWithSig: Array<{ __typename?: 'EIP712TypedDataField', name: string, type: string }> }, domain: { __typename?: 'EIP712TypedDataDomain', name: string, chainId: any, version: string, verifyingContract: any }, value: { __typename?: 'CreateCollectEIP712TypedDataValue', nonce: any, deadline: any, profileId: any, pubId: any, data: any } } } };

export type CreateCommentTypedDataMutationVariables = Exact<{
  options?: InputMaybe<TypedDataOptions>;
  request: CreatePublicCommentRequest;
}>;


export type CreateCommentTypedDataMutation = { __typename?: 'Mutation', createCommentTypedData: { __typename?: 'CreateCommentBroadcastItemResult', id: any, expiresAt: any, typedData: { __typename?: 'CreateCommentEIP712TypedData', types: { __typename?: 'CreateCommentEIP712TypedDataTypes', CommentWithSig: Array<{ __typename?: 'EIP712TypedDataField', name: string, type: string }> }, domain: { __typename?: 'EIP712TypedDataDomain', name: string, chainId: any, version: string, verifyingContract: any }, value: { __typename?: 'CreateCommentEIP712TypedDataValue', nonce: any, deadline: any, profileId: any, profileIdPointed: any, pubIdPointed: any, contentURI: any, collectModule: any, collectModuleInitData: any, referenceModule: any, referenceModuleData: any, referenceModuleInitData: any } } } };

export type CreateCommentViaDispatcherMutationVariables = Exact<{
  request: CreatePublicCommentRequest;
}>;


export type CreateCommentViaDispatcherMutation = { __typename?: 'Mutation', createCommentViaDispatcher: { __typename?: 'RelayError', reason: RelayErrorReasons } | { __typename?: 'RelayerResult', txHash: any, txId: any } };

export type CreateFollowTypedDataMutationVariables = Exact<{
  options?: InputMaybe<TypedDataOptions>;
  request: FollowRequest;
}>;


export type CreateFollowTypedDataMutation = { __typename?: 'Mutation', createFollowTypedData: { __typename?: 'CreateFollowBroadcastItemResult', id: any, expiresAt: any, typedData: { __typename?: 'CreateFollowEIP712TypedData', domain: { __typename?: 'EIP712TypedDataDomain', name: string, chainId: any, version: string, verifyingContract: any }, types: { __typename?: 'CreateFollowEIP712TypedDataTypes', FollowWithSig: Array<{ __typename?: 'EIP712TypedDataField', name: string, type: string }> }, value: { __typename?: 'CreateFollowEIP712TypedDataValue', nonce: any, deadline: any, profileIds: Array<any>, datas: Array<any> } } } };

export type CreateMirrorTypedDataMutationVariables = Exact<{
  options?: InputMaybe<TypedDataOptions>;
  request: CreateMirrorRequest;
}>;


export type CreateMirrorTypedDataMutation = { __typename?: 'Mutation', createMirrorTypedData: { __typename?: 'CreateMirrorBroadcastItemResult', id: any, expiresAt: any, typedData: { __typename?: 'CreateMirrorEIP712TypedData', types: { __typename?: 'CreateMirrorEIP712TypedDataTypes', MirrorWithSig: Array<{ __typename?: 'EIP712TypedDataField', name: string, type: string }> }, domain: { __typename?: 'EIP712TypedDataDomain', name: string, chainId: any, version: string, verifyingContract: any }, value: { __typename?: 'CreateMirrorEIP712TypedDataValue', nonce: any, deadline: any, profileId: any, profileIdPointed: any, pubIdPointed: any, referenceModule: any, referenceModuleData: any, referenceModuleInitData: any } } } };

export type CreateMirrorViaDispatcherMutationVariables = Exact<{
  request: CreateMirrorRequest;
}>;


export type CreateMirrorViaDispatcherMutation = { __typename?: 'Mutation', createMirrorViaDispatcher: { __typename?: 'RelayError', reason: RelayErrorReasons } | { __typename?: 'RelayerResult', txHash: any, txId: any } };

export type CreatePostTypedDataMutationVariables = Exact<{
  options?: InputMaybe<TypedDataOptions>;
  request: CreatePublicPostRequest;
}>;


export type CreatePostTypedDataMutation = { __typename?: 'Mutation', createPostTypedData: { __typename?: 'CreatePostBroadcastItemResult', id: any, expiresAt: any, typedData: { __typename?: 'CreatePostEIP712TypedData', types: { __typename?: 'CreatePostEIP712TypedDataTypes', PostWithSig: Array<{ __typename?: 'EIP712TypedDataField', name: string, type: string }> }, domain: { __typename?: 'EIP712TypedDataDomain', name: string, chainId: any, version: string, verifyingContract: any }, value: { __typename?: 'CreatePostEIP712TypedDataValue', nonce: any, deadline: any, profileId: any, contentURI: any, collectModule: any, collectModuleInitData: any, referenceModule: any, referenceModuleInitData: any } } } };

export type CreatePostViaDispatcherMutationVariables = Exact<{
  request: CreatePublicPostRequest;
}>;


export type CreatePostViaDispatcherMutation = { __typename?: 'Mutation', createPostViaDispatcher: { __typename?: 'RelayError', reason: RelayErrorReasons } | { __typename?: 'RelayerResult', txHash: any, txId: any } };

export type CreateProfileMutationVariables = Exact<{
  request: CreateProfileRequest;
}>;


export type CreateProfileMutation = { __typename?: 'Mutation', createProfile: { __typename?: 'RelayError', reason: RelayErrorReasons } | { __typename?: 'RelayerResult', txHash: any, txId: any } };

export type CreateSetDefaultProfileTypedDataMutationVariables = Exact<{
  options?: InputMaybe<TypedDataOptions>;
  request: CreateSetDefaultProfileRequest;
}>;


export type CreateSetDefaultProfileTypedDataMutation = { __typename?: 'Mutation', createSetDefaultProfileTypedData: { __typename?: 'SetDefaultProfileBroadcastItemResult', id: any, expiresAt: any, typedData: { __typename?: 'SetDefaultProfileEIP712TypedData', domain: { __typename?: 'EIP712TypedDataDomain', name: string, chainId: any, version: string, verifyingContract: any }, types: { __typename?: 'SetDefaultProfileEIP712TypedDataTypes', SetDefaultProfileWithSig: Array<{ __typename?: 'EIP712TypedDataField', name: string, type: string }> }, value: { __typename?: 'SetDefaultProfileEIP712TypedDataValue', nonce: any, deadline: any, wallet: any, profileId: any } } } };

export type CreateSetDispatcherTypedDataMutationVariables = Exact<{
  options?: InputMaybe<TypedDataOptions>;
  request: SetDispatcherRequest;
}>;


export type CreateSetDispatcherTypedDataMutation = { __typename?: 'Mutation', createSetDispatcherTypedData: { __typename?: 'CreateSetDispatcherBroadcastItemResult', id: any, expiresAt: any, typedData: { __typename?: 'CreateSetDispatcherEIP712TypedData', types: { __typename?: 'CreateSetDispatcherEIP712TypedDataTypes', SetDispatcherWithSig: Array<{ __typename?: 'EIP712TypedDataField', name: string, type: string }> }, domain: { __typename?: 'EIP712TypedDataDomain', name: string, chainId: any, version: string, verifyingContract: any }, value: { __typename?: 'CreateSetDispatcherEIP712TypedDataValue', nonce: any, deadline: any, profileId: any, dispatcher: any } } } };

export type CreateSetFollowModuleTypedDataMutationVariables = Exact<{
  options?: InputMaybe<TypedDataOptions>;
  request: CreateSetFollowModuleRequest;
}>;


export type CreateSetFollowModuleTypedDataMutation = { __typename?: 'Mutation', createSetFollowModuleTypedData: { __typename?: 'CreateSetFollowModuleBroadcastItemResult', id: any, expiresAt: any, typedData: { __typename?: 'CreateSetFollowModuleEIP712TypedData', types: { __typename?: 'CreateSetFollowModuleEIP712TypedDataTypes', SetFollowModuleWithSig: Array<{ __typename?: 'EIP712TypedDataField', name: string, type: string }> }, domain: { __typename?: 'EIP712TypedDataDomain', name: string, chainId: any, version: string, verifyingContract: any }, value: { __typename?: 'CreateSetFollowModuleEIP712TypedDataValue', nonce: any, deadline: any, profileId: any, followModule: any, followModuleInitData: any } } } };

export type CreateSetProfileImageUriTypedDataMutationVariables = Exact<{
  options?: InputMaybe<TypedDataOptions>;
  request: UpdateProfileImageRequest;
}>;


export type CreateSetProfileImageUriTypedDataMutation = { __typename?: 'Mutation', createSetProfileImageURITypedData: { __typename?: 'CreateSetProfileImageUriBroadcastItemResult', id: any, expiresAt: any, typedData: { __typename?: 'CreateSetProfileImageUriEIP712TypedData', domain: { __typename?: 'EIP712TypedDataDomain', name: string, chainId: any, version: string, verifyingContract: any }, types: { __typename?: 'CreateSetProfileImageUriEIP712TypedDataTypes', SetProfileImageURIWithSig: Array<{ __typename?: 'EIP712TypedDataField', name: string, type: string }> }, value: { __typename?: 'CreateSetProfileImageUriEIP712TypedDataValue', nonce: any, deadline: any, imageURI: any, profileId: any } } } };

export type CreateSetProfileImageUriViaDispatcherMutationVariables = Exact<{
  request: UpdateProfileImageRequest;
}>;


export type CreateSetProfileImageUriViaDispatcherMutation = { __typename?: 'Mutation', createSetProfileImageURIViaDispatcher: { __typename?: 'RelayError', reason: RelayErrorReasons } | { __typename?: 'RelayerResult', txHash: any, txId: any } };

export type CreateSetProfileMetadataTypedDataMutationVariables = Exact<{
  options?: InputMaybe<TypedDataOptions>;
  request: CreatePublicSetProfileMetadataUriRequest;
}>;


export type CreateSetProfileMetadataTypedDataMutation = { __typename?: 'Mutation', createSetProfileMetadataTypedData: { __typename?: 'CreateSetProfileMetadataURIBroadcastItemResult', id: any, expiresAt: any, typedData: { __typename?: 'CreateSetProfileMetadataURIEIP712TypedData', types: { __typename?: 'CreateSetProfileMetadataURIEIP712TypedDataTypes', SetProfileMetadataURIWithSig: Array<{ __typename?: 'EIP712TypedDataField', name: string, type: string }> }, domain: { __typename?: 'EIP712TypedDataDomain', name: string, chainId: any, version: string, verifyingContract: any }, value: { __typename?: 'CreateSetProfileMetadataURIEIP712TypedDataValue', nonce: any, deadline: any, profileId: any, metadata: any } } } };

export type CreateSetProfileMetadataViaDispatcherMutationVariables = Exact<{
  request: CreatePublicSetProfileMetadataUriRequest;
}>;


export type CreateSetProfileMetadataViaDispatcherMutation = { __typename?: 'Mutation', createSetProfileMetadataViaDispatcher: { __typename?: 'RelayError', reason: RelayErrorReasons } | { __typename?: 'RelayerResult', txHash: any, txId: any } };

export type CreateUnfollowTypedDataMutationVariables = Exact<{
  request: UnfollowRequest;
}>;


export type CreateUnfollowTypedDataMutation = { __typename?: 'Mutation', createUnfollowTypedData: { __typename?: 'CreateUnfollowBroadcastItemResult', id: any, expiresAt: any, typedData: { __typename?: 'CreateBurnEIP712TypedData', domain: { __typename?: 'EIP712TypedDataDomain', name: string, chainId: any, version: string, verifyingContract: any }, types: { __typename?: 'CreateBurnEIP712TypedDataTypes', BurnWithSig: Array<{ __typename?: 'EIP712TypedDataField', name: string, type: string }> }, value: { __typename?: 'CreateBurnEIP712TypedDataValue', nonce: any, deadline: any, tokenId: string } } } };

export type HidePublicationMutationVariables = Exact<{
  request: HidePublicationRequest;
}>;


export type HidePublicationMutation = { __typename?: 'Mutation', hidePublication?: any | null };

export type ProxyActionMutationVariables = Exact<{
  request: ProxyActionRequest;
}>;


export type ProxyActionMutation = { __typename?: 'Mutation', proxyAction: any };

export type RemoveReactionMutationVariables = Exact<{
  request: ReactionRequest;
}>;


export type RemoveReactionMutation = { __typename?: 'Mutation', removeReaction?: any | null };

export type ReportPublicationMutationVariables = Exact<{
  request: ReportPublicationRequest;
}>;


export type ReportPublicationMutation = { __typename?: 'Mutation', reportPublication?: any | null };

export type ApprovedModuleAllowanceAmountQueryVariables = Exact<{
  request: ApprovedModuleAllowanceAmountRequest;
}>;


export type ApprovedModuleAllowanceAmountQuery = { __typename?: 'Query', approvedModuleAllowanceAmount: Array<{ __typename?: 'ApprovedAllowanceAmount', currency: any, module: string, allowance: string, contractAddress: any }>, enabledModuleCurrencies: Array<{ __typename?: 'Erc20', name: string, symbol: string, decimals: number, address: any }> };

export type ChallengeQueryVariables = Exact<{
  request: ChallengeRequest;
}>;


export type ChallengeQuery = { __typename?: 'Query', challenge: { __typename?: 'AuthChallengeResult', text: string } };

export type CollectModuleQueryVariables = Exact<{
  request: PublicationQueryRequest;
}>;


export type CollectModuleQuery = { __typename?: 'Query', publication?: { __typename?: 'Comment', collectNftAddress?: any | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' } } | { __typename?: 'Mirror', collectNftAddress?: any | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' } } | { __typename?: 'Post', collectNftAddress?: any | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' } } | null };

export type CollectorsQueryVariables = Exact<{
  request: WhoCollectedPublicationRequest;
}>;


export type CollectorsQuery = { __typename?: 'Query', whoCollectedPublication: { __typename?: 'PaginatedWhoCollectedResult', items: Array<{ __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', isFollowedByMe: boolean, id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null }>, pageInfo: { __typename?: 'PaginatedResultInfo', next?: any | null, totalCount?: number | null } } };

export type CommentFeedQueryVariables = Exact<{
  request: PublicationsQueryRequest;
  reactionRequest?: InputMaybe<ReactionFieldResolverRequest>;
  profileId?: InputMaybe<Scalars['ProfileId']>;
}>;


export type CommentFeedQuery = { __typename?: 'Query', publications: { __typename?: 'PaginatedPublicationResult', items: Array<{ __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, commentOn?: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', handle: any } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, mainPost: { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } | null } | { __typename?: 'Mirror' } | { __typename?: 'Post' }>, pageInfo: { __typename?: 'PaginatedResultInfo', totalCount?: number | null, next?: any | null } } };

export type EnabledCurrencyModulesQueryVariables = Exact<{ [key: string]: never; }>;


export type EnabledCurrencyModulesQuery = { __typename?: 'Query', enabledModuleCurrencies: Array<{ __typename?: 'Erc20', name: string, symbol: string, decimals: number, address: any }> };

export type EnabledCurrencyModulesWithProfileQueryVariables = Exact<{
  request: SingleProfileQueryRequest;
}>;


export type EnabledCurrencyModulesWithProfileQuery = { __typename?: 'Query', enabledModuleCurrencies: Array<{ __typename?: 'Erc20', name: string, symbol: string, decimals: number, address: any }>, profile?: { __typename?: 'Profile', followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null };

export type EnabledModulesQueryVariables = Exact<{ [key: string]: never; }>;


export type EnabledModulesQuery = { __typename?: 'Query', enabledModules: { __typename?: 'EnabledModules', collectModules: Array<{ __typename?: 'EnabledModule', moduleName: string, contractAddress: any }> }, enabledModuleCurrencies: Array<{ __typename?: 'Erc20', name: string, symbol: string, decimals: number, address: any }> };

export type ExploreFeedQueryVariables = Exact<{
  request: ExplorePublicationRequest;
  reactionRequest?: InputMaybe<ReactionFieldResolverRequest>;
  profileId?: InputMaybe<Scalars['ProfileId']>;
}>;


export type ExploreFeedQuery = { __typename?: 'Query', explorePublications: { __typename?: 'ExplorePublicationResult', items: Array<{ __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, commentOn?: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', handle: any } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, mainPost: { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } | null } | { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } }>, pageInfo: { __typename?: 'PaginatedResultInfo', totalCount?: number | null, next?: any | null } } };

export type FeedHighlightsQueryVariables = Exact<{
  request: FeedHighlightsRequest;
  reactionRequest?: InputMaybe<ReactionFieldResolverRequest>;
  profileId?: InputMaybe<Scalars['ProfileId']>;
}>;


export type FeedHighlightsQuery = { __typename?: 'Query', feedHighlights: { __typename?: 'PaginatedTimelineResult', items: Array<{ __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, commentOn?: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', handle: any } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, mainPost: { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } | null } | { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } }>, pageInfo: { __typename?: 'PaginatedResultInfo', totalCount?: number | null, next?: any | null } } };

export type FollowersQueryVariables = Exact<{
  request: FollowersRequest;
}>;


export type FollowersQuery = { __typename?: 'Query', followers: { __typename?: 'PaginatedFollowersResult', items: Array<{ __typename?: 'Follower', totalAmountOfTimesFollowed: number, wallet: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', isFollowedByMe: boolean, id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } }>, pageInfo: { __typename?: 'PaginatedResultInfo', next?: any | null, totalCount?: number | null } } };

export type FollowingQueryVariables = Exact<{
  request: FollowingRequest;
}>;


export type FollowingQuery = { __typename?: 'Query', following: { __typename?: 'PaginatedFollowingResult', items: Array<{ __typename?: 'Following', totalAmountOfTimesFollowing: number, profile: { __typename?: 'Profile', isFollowedByMe: boolean, id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } }>, pageInfo: { __typename?: 'PaginatedResultInfo', next?: any | null, totalCount?: number | null } } };

export type GenerateModuleCurrencyApprovalDataQueryVariables = Exact<{
  request: GenerateModuleCurrencyApprovalDataRequest;
}>;


export type GenerateModuleCurrencyApprovalDataQuery = { __typename?: 'Query', generateModuleCurrencyApprovalData: { __typename?: 'GenerateModuleCurrencyApproval', to: any, from: any, data: any } };

export type HasTxHashBeenIndexedQueryVariables = Exact<{
  request: HasTxHashBeenIndexedRequest;
}>;


export type HasTxHashBeenIndexedQuery = { __typename?: 'Query', hasTxHashBeenIndexed: { __typename?: 'TransactionError', reason: TransactionErrorReasons } | { __typename?: 'TransactionIndexedResult', txHash: any, indexed: boolean, metadataStatus?: { __typename?: 'PublicationMetadataStatus', status: PublicationMetadataStatusType } | null } };

export type LensterStatsQueryVariables = Exact<{ [key: string]: never; }>;


export type LensterStatsQuery = { __typename?: 'Query', globalProtocolStats: { __typename?: 'GlobalProtocolStats', totalProfiles: number, totalPosts: number, totalBurntProfiles: number, totalMirrors: number, totalComments: number, totalCollects: number, totalFollows: number } };

export type LikesQueryVariables = Exact<{
  request: WhoReactedPublicationRequest;
}>;


export type LikesQuery = { __typename?: 'Query', whoReactedPublication: { __typename?: 'PaginatedWhoReactedResult', items: Array<{ __typename?: 'WhoReactedResult', reactionId: any, profile: { __typename?: 'Profile', isFollowedByMe: boolean, id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } }>, pageInfo: { __typename?: 'PaginatedResultInfo', next?: any | null, totalCount?: number | null } } };

export type MirrorsQueryVariables = Exact<{
  request: ProfileQueryRequest;
}>;


export type MirrorsQuery = { __typename?: 'Query', profiles: { __typename?: 'PaginatedProfileResult', items: Array<{ __typename?: 'Profile', isFollowedByMe: boolean, id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }>, pageInfo: { __typename?: 'PaginatedResultInfo', next?: any | null, totalCount?: number | null } } };

export type MutualFollowersQueryVariables = Exact<{
  request: MutualFollowersProfilesQueryRequest;
}>;


export type MutualFollowersQuery = { __typename?: 'Query', mutualFollowersProfiles: { __typename?: 'PaginatedProfileResult', items: Array<{ __typename?: 'Profile', handle: any, name?: string | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null }>, pageInfo: { __typename?: 'PaginatedResultInfo', totalCount?: number | null } } };

export type MutualFollowersListQueryVariables = Exact<{
  request: MutualFollowersProfilesQueryRequest;
}>;


export type MutualFollowersListQuery = { __typename?: 'Query', mutualFollowersProfiles: { __typename?: 'PaginatedProfileResult', items: Array<{ __typename?: 'Profile', isFollowedByMe: boolean, id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }>, pageInfo: { __typename?: 'PaginatedResultInfo', next?: any | null, totalCount?: number | null } } };

export type NftChallengeQueryVariables = Exact<{
  request: NftOwnershipChallengeRequest;
}>;


export type NftChallengeQuery = { __typename?: 'Query', nftOwnershipChallenge: { __typename?: 'NftOwnershipChallengeResult', id: any, text: string } };

export type NftFeedQueryVariables = Exact<{
  request: NfTsRequest;
}>;


export type NftFeedQuery = { __typename?: 'Query', nfts: { __typename?: 'NFTsResult', items: Array<{ __typename?: 'NFT', name: string, collectionName: string, contractAddress: any, tokenId: string, chainId: any, originalContent: { __typename?: 'NFTContent', uri: string, animatedUrl?: string | null } }>, pageInfo: { __typename?: 'PaginatedResultInfo', next?: any | null, totalCount?: number | null } } };

export type NotificationCountQueryVariables = Exact<{
  request: NotificationRequest;
}>;


export type NotificationCountQuery = { __typename?: 'Query', notifications: { __typename?: 'PaginatedNotificationResult', pageInfo: { __typename?: 'PaginatedResultInfo', totalCount?: number | null } } };

export type NotificationsQueryVariables = Exact<{
  request: NotificationRequest;
}>;


export type NotificationsQuery = { __typename?: 'Query', notifications: { __typename?: 'PaginatedNotificationResult', items: Array<{ __typename?: 'NewCollectNotification', notificationId: any, createdAt: any, wallet: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null }, collectedPublication: { __typename?: 'Comment', id: any, metadata: { __typename?: 'MetadataOutput', content?: any | null }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' } } | { __typename?: 'Mirror' } | { __typename?: 'Post', id: any, metadata: { __typename?: 'MetadataOutput', content?: any | null }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' } } } | { __typename?: 'NewCommentNotification', notificationId: any, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, comment: { __typename?: 'Comment', id: any, metadata: { __typename?: 'MetadataOutput', content?: any | null }, commentOn?: { __typename?: 'Comment', id: any } | { __typename?: 'Mirror', id: any } | { __typename?: 'Post', id: any } | null } } | { __typename?: 'NewFollowerNotification', notificationId: any, createdAt: any, wallet: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } } | { __typename?: 'NewMentionNotification', notificationId: any, createdAt: any, mentionPublication: { __typename?: 'Comment', id: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, metadata: { __typename?: 'MetadataOutput', content?: any | null } } | { __typename?: 'Post', id: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, metadata: { __typename?: 'MetadataOutput', content?: any | null } } } | { __typename?: 'NewMirrorNotification', notificationId: any, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, publication: { __typename?: 'Comment', id: any, metadata: { __typename?: 'MetadataOutput', content?: any | null } } | { __typename?: 'Post', id: any, metadata: { __typename?: 'MetadataOutput', content?: any | null } } } | { __typename?: 'NewReactionNotification', notificationId: any, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, publication: { __typename?: 'Comment', id: any, metadata: { __typename?: 'MetadataOutput', content?: any | null } } | { __typename?: 'Mirror', id: any, metadata: { __typename?: 'MetadataOutput', content?: any | null } } | { __typename?: 'Post', id: any, metadata: { __typename?: 'MetadataOutput', content?: any | null } } }>, pageInfo: { __typename?: 'PaginatedResultInfo', totalCount?: number | null, next?: any | null } } };

export type ProfileQueryVariables = Exact<{
  request: SingleProfileQueryRequest;
  who?: InputMaybe<Scalars['ProfileId']>;
}>;


export type ProfileQuery = { __typename?: 'Query', profile?: { __typename?: 'Profile', id: any, handle: any, ownedBy: any, name?: string | null, bio?: string | null, metadata?: any | null, followNftAddress?: any | null, isFollowedByMe: boolean, isFollowing: boolean, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, dispatcher?: { __typename?: 'Dispatcher', canUseRelay: boolean } | null, onChainIdentity: { __typename?: 'OnChainIdentity', proofOfHumanity: boolean, sybilDotOrg: { __typename?: 'SybilDotOrgIdentity', verified: boolean, source: { __typename?: 'SybilDotOrgIdentitySource', twitter: { __typename?: 'SybilDotOrgTwitterIdentity', handle?: string | null } } }, ens?: { __typename?: 'EnsOnChainIdentity', name?: any | null } | null, worldcoin: { __typename?: 'WorldcoinIdentity', isHuman: boolean } }, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number, totalPosts: number, totalComments: number, totalMirrors: number }, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, coverPicture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage' } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null };

export type ProfileAddressQueryVariables = Exact<{
  request: SingleProfileQueryRequest;
}>;


export type ProfileAddressQuery = { __typename?: 'Query', profile?: { __typename?: 'Profile', id: any, ownedBy: any } | null };

export type ProfileFeedQueryVariables = Exact<{
  request: PublicationsQueryRequest;
  reactionRequest?: InputMaybe<ReactionFieldResolverRequest>;
  profileId?: InputMaybe<Scalars['ProfileId']>;
}>;


export type ProfileFeedQuery = { __typename?: 'Query', publications: { __typename?: 'PaginatedPublicationResult', items: Array<{ __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, commentOn?: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', handle: any } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, mainPost: { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } | null } | { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } }>, pageInfo: { __typename?: 'PaginatedResultInfo', totalCount?: number | null, next?: any | null } } };

export type ProfileSettingsQueryVariables = Exact<{
  request: SingleProfileQueryRequest;
}>;


export type ProfileSettingsQuery = { __typename?: 'Query', profile?: { __typename?: 'Profile', id: any, handle: any, name?: string | null, bio?: string | null, attributes?: Array<{ __typename?: 'Attribute', traitType?: string | null, key: string, value: string }> | null, coverPicture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage' } | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any, tokenId: string, contractAddress: any } | null } | null };

export type ProfilesQueryVariables = Exact<{
  request: ProfileQueryRequest;
}>;


export type ProfilesQuery = { __typename?: 'Query', profiles: { __typename?: 'PaginatedProfileResult', items: Array<{ __typename?: 'Profile', isDefault: boolean, isFollowedByMe: boolean, id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }>, pageInfo: { __typename?: 'PaginatedResultInfo', next?: any | null, totalCount?: number | null } } };

export type PublicationQueryVariables = Exact<{
  request: PublicationQueryRequest;
  reactionRequest?: InputMaybe<ReactionFieldResolverRequest>;
  profileId?: InputMaybe<Scalars['ProfileId']>;
}>;


export type PublicationQuery = { __typename?: 'Query', publication?: { __typename?: 'Comment', onChainContentURI: string, collectNftAddress?: any | null, id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', isFollowedByMe: boolean, id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, referenceModule?: { __typename: 'DegreesOfSeparationReferenceModuleSettings' } | { __typename: 'FollowOnlyReferenceModuleSettings' } | { __typename: 'UnknownReferenceModuleSettings' } | null, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, commentOn?: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', handle: any } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, mainPost: { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } | null } | { __typename?: 'Mirror', onChainContentURI: string, collectNftAddress?: any | null, id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', isFollowedByMe: boolean, id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, referenceModule?: { __typename: 'DegreesOfSeparationReferenceModuleSettings' } | { __typename: 'FollowOnlyReferenceModuleSettings' } | { __typename: 'UnknownReferenceModuleSettings' } | null, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', onChainContentURI: string, collectNftAddress?: any | null, id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', isFollowedByMe: boolean, id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, referenceModule?: { __typename: 'DegreesOfSeparationReferenceModuleSettings' } | { __typename: 'FollowOnlyReferenceModuleSettings' } | { __typename: 'UnknownReferenceModuleSettings' } | null, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } | null };

export type PublicationRevenueQueryVariables = Exact<{
  request: PublicationRevenueQueryRequest;
}>;


export type PublicationRevenueQuery = { __typename?: 'Query', publicationRevenue?: { __typename?: 'PublicationRevenue', revenue: { __typename?: 'RevenueAggregate', total: { __typename?: 'Erc20Amount', value: string } } } | null };

export type RecommendedProfilesQueryVariables = Exact<{
  options?: InputMaybe<RecommendedProfileOptions>;
}>;


export type RecommendedProfilesQuery = { __typename?: 'Query', recommendedProfiles: Array<{ __typename?: 'Profile', isFollowedByMe: boolean, id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }> };

export type RelevantPeopleQueryVariables = Exact<{
  request: ProfileQueryRequest;
}>;


export type RelevantPeopleQuery = { __typename?: 'Query', profiles: { __typename?: 'PaginatedProfileResult', items: Array<{ __typename?: 'Profile', isFollowedByMe: boolean, id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }> } };

export type SearchProfilesQueryVariables = Exact<{
  request: SearchQueryRequest;
}>;


export type SearchProfilesQuery = { __typename?: 'Query', search: { __typename?: 'ProfileSearchResult', items: Array<{ __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }>, pageInfo: { __typename?: 'PaginatedResultInfo', next?: any | null, totalCount?: number | null } } | { __typename?: 'PublicationSearchResult' } };

export type SearchPublicationsQueryVariables = Exact<{
  request: SearchQueryRequest;
  reactionRequest?: InputMaybe<ReactionFieldResolverRequest>;
  profileId?: InputMaybe<Scalars['ProfileId']>;
}>;


export type SearchPublicationsQuery = { __typename?: 'Query', search: { __typename?: 'ProfileSearchResult' } | { __typename?: 'PublicationSearchResult', items: Array<{ __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, commentOn?: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', handle: any } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, mainPost: { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } | null } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } }>, pageInfo: { __typename?: 'PaginatedResultInfo', next?: any | null, totalCount?: number | null } } };

export type SuperFollowQueryVariables = Exact<{
  request: SingleProfileQueryRequest;
}>;


export type SuperFollowQuery = { __typename?: 'Query', profile?: { __typename?: 'Profile', id: any, followModule?: { __typename?: 'FeeFollowModuleSettings', recipient: any, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', name: string, symbol: string, decimals: number, address: any } } } | { __typename?: 'ProfileFollowModuleSettings' } | { __typename?: 'RevertFollowModuleSettings' } | { __typename?: 'UnknownFollowModuleSettings' } | null } | null };

export type SuperfluidInflowsQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']>;
}>;


export type SuperfluidInflowsQuery = { __typename?: 'Query', account?: { __typename?: 'Account', createdAtTimestamp: any, createdAtBlockNumber: any, isSuperApp: boolean, updatedAtBlockNumber: any, updatedAtTimestamp: any, inflows: Array<{ __typename?: 'Stream', id: string, deposit: any, currentFlowRate: any, createdAtTimestamp: any, token: { __typename?: 'Token', name: string, symbol: string, id: string, decimals: number, underlyingToken?: { __typename?: 'Token', name: string, symbol: string } | null }, sender: { __typename?: 'Account', id: string } }> } | null };

export type TimelineQueryVariables = Exact<{
  request: FeedRequest;
  reactionRequest?: InputMaybe<ReactionFieldResolverRequest>;
  profileId?: InputMaybe<Scalars['ProfileId']>;
}>;


export type TimelineQuery = { __typename?: 'Query', feed: { __typename?: 'PaginatedFeedResult', items: Array<{ __typename?: 'FeedItem', root: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, commentOn?: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', handle: any } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, mainPost: { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } | null } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } }, electedMirror?: { __typename?: 'ElectedMirror', mirrorId: any, timestamp: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } } | null, mirrors: Array<{ __typename?: 'MirrorEvent', timestamp: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } }>, collects: Array<{ __typename?: 'CollectedEvent', timestamp: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } }>, reactions: Array<{ __typename?: 'ReactionEvent', reaction: ReactionTypes, timestamp: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } }>, comments?: Array<{ __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, commentOn?: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', handle: any } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, mainPost: { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Mirror', id: any, reaction?: ReactionTypes | null, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> }, mirrorOf: { __typename?: 'Comment', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, createdAt: any, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } } | { __typename?: 'Post', id: any, reaction?: ReactionTypes | null, mirrors: Array<any>, hasCollectedByMe: boolean, hidden: boolean, createdAt: any, appId?: any | null, profile: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }, canComment: { __typename?: 'CanCommentResponse', result: boolean }, canMirror: { __typename?: 'CanMirrorResponse', result: boolean }, collectedBy?: { __typename?: 'Wallet', address: any, defaultProfile?: { __typename?: 'Profile', id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowers: number, totalFollowing: number }, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null } | null } | null, collectModule: { __typename?: 'AaveFeeCollectModuleSettings' } | { __typename?: 'ERC4626FeeCollectModuleSettings' } | { __typename?: 'FeeCollectModuleSettings', type: CollectModules, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'FreeCollectModuleSettings', type: CollectModules, contractAddress: any, followerOnly: boolean } | { __typename?: 'LimitedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'LimitedTimedFeeCollectModuleSettings', type: CollectModules, collectLimit: string, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'MultirecipientFeeCollectModuleSettings' } | { __typename?: 'RevertCollectModuleSettings' } | { __typename?: 'SimpleCollectModuleSettings' } | { __typename?: 'TimedFeeCollectModuleSettings', type: CollectModules, endTimestamp: any, referralFee: number, contractAddress: any, followerOnly: boolean, amount: { __typename?: 'ModuleFeeAmount', value: string, asset: { __typename?: 'Erc20', symbol: string, decimals: number, address: any } } } | { __typename?: 'UnknownCollectModuleSettings' }, stats: { __typename?: 'PublicationStats', totalUpvotes: number, totalAmountOfMirrors: number, totalAmountOfCollects: number, totalAmountOfComments: number }, metadata: { __typename?: 'MetadataOutput', name?: string | null, description?: any | null, content?: any | null, image?: any | null, attributes: Array<{ __typename?: 'MetadataAttributeOutput', traitType?: string | null, value?: string | null }>, cover?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | null, media: Array<{ __typename?: 'MediaSet', original: { __typename?: 'Media', url: any, mimeType?: any | null } }> } } | null }> | null }>, pageInfo: { __typename?: 'PaginatedResultInfo', next?: any | null, totalCount?: number | null } } };

export type TrendingQueryVariables = Exact<{
  request: AllPublicationsTagsRequest;
}>;


export type TrendingQuery = { __typename?: 'Query', allPublicationsTags: { __typename?: 'PaginatedAllPublicationsTagsResult', items: Array<{ __typename?: 'TagResult', tag: any, total: number }> } };

export type UserProfilesQueryVariables = Exact<{
  ownedBy?: InputMaybe<Array<Scalars['EthereumAddress']> | Scalars['EthereumAddress']>;
}>;


export type UserProfilesQuery = { __typename?: 'Query', profiles: { __typename?: 'PaginatedProfileResult', items: Array<{ __typename?: 'Profile', isDefault: boolean, id: any, name?: string | null, handle: any, bio?: string | null, ownedBy: any, isFollowedByMe: boolean, stats: { __typename?: 'ProfileStats', totalFollowing: number, totalFollowers: number }, dispatcher?: { __typename?: 'Dispatcher', canUseRelay: boolean } | null, attributes?: Array<{ __typename?: 'Attribute', key: string, value: string }> | null, picture?: { __typename?: 'MediaSet', original: { __typename?: 'Media', url: any } } | { __typename?: 'NftImage', uri: any } | null, followModule?: { __typename: 'FeeFollowModuleSettings' } | { __typename: 'ProfileFollowModuleSettings' } | { __typename: 'RevertFollowModuleSettings' } | { __typename: 'UnknownFollowModuleSettings' } | null }> }, userSigNonces: { __typename?: 'UserSigNonces', lensHubOnChainSigNonce: any } };


      export interface PossibleTypesResultData {
        possibleTypes: {
          [key: string]: string[]
        }
      }
      const result: PossibleTypesResultData = {
  "possibleTypes": {
    "BroadcastDataAvailabilityUnion": [
      "CreateDataAvailabilityPublicationResult",
      "RelayError"
    ],
    "CollectModule": [
      "AaveFeeCollectModuleSettings",
      "ERC4626FeeCollectModuleSettings",
      "FeeCollectModuleSettings",
      "FreeCollectModuleSettings",
      "LimitedFeeCollectModuleSettings",
      "LimitedTimedFeeCollectModuleSettings",
      "MultirecipientFeeCollectModuleSettings",
      "RevertCollectModuleSettings",
      "SimpleCollectModuleSettings",
      "TimedFeeCollectModuleSettings",
      "UnknownCollectModuleSettings"
    ],
    "DataAvailabilityTransactionUnion": [
      "DataAvailabilityComment",
      "DataAvailabilityMirror",
      "DataAvailabilityPost"
    ],
    "DataAvailabilityVerificationStatusUnion": [
      "DataAvailabilityVerificationStatusFailure",
      "DataAvailabilityVerificationStatusSuccess"
    ],
    "Event": [
      "AgreementClassRegisteredEvent",
      "AgreementClassUpdatedEvent",
      "AgreementLiquidatedByEvent",
      "AgreementLiquidatedV2Event",
      "AppRegisteredEvent",
      "BondIncreasedEvent",
      "BurnedEvent",
      "CFAv1LiquidationPeriodChangedEvent",
      "ConfigChangedEvent",
      "CustomSuperTokenCreatedEvent",
      "ExitRateChangedEvent",
      "FlowOperatorUpdatedEvent",
      "FlowUpdatedEvent",
      "GovernanceReplacedEvent",
      "IndexCreatedEvent",
      "IndexDistributionClaimedEvent",
      "IndexSubscribedEvent",
      "IndexUnitsUpdatedEvent",
      "IndexUnsubscribedEvent",
      "IndexUpdatedEvent",
      "JailEvent",
      "MintedEvent",
      "NewPICEvent",
      "PPPConfigurationChangedEvent",
      "RewardAddressChangedEvent",
      "RoleAdminChangedEvent",
      "RoleGrantedEvent",
      "RoleRevokedEvent",
      "SentEvent",
      "SetEvent",
      "SubscriptionApprovedEvent",
      "SubscriptionDistributionClaimedEvent",
      "SubscriptionRevokedEvent",
      "SubscriptionUnitsUpdatedEvent",
      "SuperTokenCreatedEvent",
      "SuperTokenFactoryUpdatedEvent",
      "SuperTokenLogicCreatedEvent",
      "SuperTokenLogicUpdatedEvent",
      "SuperTokenMinimumDepositChangedEvent",
      "TokenDowngradedEvent",
      "TokenUpgradedEvent",
      "TransferEvent",
      "TrustedForwarderChangedEvent"
    ],
    "FeedItemRoot": [
      "Comment",
      "Post"
    ],
    "FollowModule": [
      "FeeFollowModuleSettings",
      "ProfileFollowModuleSettings",
      "RevertFollowModuleSettings",
      "UnknownFollowModuleSettings"
    ],
    "MainPostReference": [
      "Mirror",
      "Post"
    ],
    "MentionPublication": [
      "Comment",
      "Post"
    ],
    "MirrorablePublication": [
      "Comment",
      "Post"
    ],
    "Notification": [
      "NewCollectNotification",
      "NewCommentNotification",
      "NewFollowerNotification",
      "NewMentionNotification",
      "NewMirrorNotification",
      "NewReactionNotification"
    ],
    "ProfileMedia": [
      "MediaSet",
      "NftImage"
    ],
    "ProxyActionStatusResultUnion": [
      "ProxyActionError",
      "ProxyActionQueued",
      "ProxyActionStatusResult"
    ],
    "Publication": [
      "Comment",
      "Mirror",
      "Post"
    ],
    "PublicationForSale": [
      "Comment",
      "Post"
    ],
    "PublicationSearchResultItem": [
      "Comment",
      "Post"
    ],
    "ReferenceModule": [
      "DegreesOfSeparationReferenceModuleSettings",
      "FollowOnlyReferenceModuleSettings",
      "UnknownReferenceModuleSettings"
    ],
    "RelayDataAvailabilityResult": [
      "CreateDataAvailabilityPublicationResult",
      "RelayError"
    ],
    "RelayResult": [
      "RelayError",
      "RelayerResult"
    ],
    "SearchResult": [
      "ProfileSearchResult",
      "PublicationSearchResult"
    ],
    "TransactionResult": [
      "TransactionError",
      "TransactionIndexedResult"
    ]
  }
};
      export default result;
    
export const ProfileFieldsFragmentDoc = gql`
    fragment ProfileFields on Profile {
  id
  name
  handle
  bio
  ownedBy
  isFollowedByMe
  stats {
    totalFollowers
    totalFollowing
  }
  attributes {
    key
    value
  }
  picture {
    ... on MediaSet {
      original {
        url
      }
    }
    ... on NftImage {
      uri
    }
  }
  followModule {
    __typename
  }
}
    `;
export const CollectModuleFieldsFragmentDoc = gql`
    fragment CollectModuleFields on CollectModule {
  ... on FreeCollectModuleSettings {
    type
    contractAddress
    followerOnly
  }
  ... on FeeCollectModuleSettings {
    type
    referralFee
    contractAddress
    followerOnly
    amount {
      asset {
        symbol
        decimals
        address
      }
      value
    }
  }
  ... on LimitedFeeCollectModuleSettings {
    type
    collectLimit
    referralFee
    contractAddress
    followerOnly
    amount {
      asset {
        symbol
        decimals
        address
      }
      value
    }
  }
  ... on LimitedTimedFeeCollectModuleSettings {
    type
    collectLimit
    endTimestamp
    referralFee
    contractAddress
    followerOnly
    amount {
      asset {
        symbol
        decimals
        address
      }
      value
    }
  }
  ... on TimedFeeCollectModuleSettings {
    type
    endTimestamp
    referralFee
    contractAddress
    followerOnly
    amount {
      asset {
        symbol
        decimals
        address
      }
      value
    }
  }
}
    `;
export const StatsFieldsFragmentDoc = gql`
    fragment StatsFields on PublicationStats {
  totalUpvotes
  totalAmountOfMirrors
  totalAmountOfCollects
  totalAmountOfComments
}
    `;
export const MetadataFieldsFragmentDoc = gql`
    fragment MetadataFields on MetadataOutput {
  name
  description
  content
  image
  attributes {
    traitType
    value
  }
  cover {
    original {
      url
    }
  }
  media {
    original {
      url
      mimeType
    }
  }
}
    `;
export const PostFieldsFragmentDoc = gql`
    fragment PostFields on Post {
  id
  profile {
    ...ProfileFields
  }
  reaction(request: $reactionRequest)
  mirrors(by: $profileId)
  canComment(profileId: $profileId) {
    result
  }
  canMirror(profileId: $profileId) {
    result
  }
  hasCollectedByMe
  collectedBy {
    address
    defaultProfile {
      ...ProfileFields
    }
  }
  collectModule {
    ...CollectModuleFields
  }
  stats {
    ...StatsFields
  }
  metadata {
    ...MetadataFields
  }
  hidden
  createdAt
  appId
}
    ${ProfileFieldsFragmentDoc}
${CollectModuleFieldsFragmentDoc}
${StatsFieldsFragmentDoc}
${MetadataFieldsFragmentDoc}`;
export const MirrorFieldsFragmentDoc = gql`
    fragment MirrorFields on Mirror {
  id
  profile {
    ...ProfileFields
  }
  reaction(request: $reactionRequest)
  canComment(profileId: $profileId) {
    result
  }
  canMirror(profileId: $profileId) {
    result
  }
  collectModule {
    ...CollectModuleFields
  }
  stats {
    ...StatsFields
  }
  metadata {
    ...MetadataFields
  }
  hidden
  mirrorOf {
    ... on Post {
      ...PostFields
    }
    ... on Comment {
      id
      profile {
        ...ProfileFields
      }
      reaction(request: $reactionRequest)
      mirrors(by: $profileId)
      canComment(profileId: $profileId) {
        result
      }
      canMirror(profileId: $profileId) {
        result
      }
      stats {
        ...StatsFields
      }
      createdAt
    }
  }
  createdAt
  appId
}
    ${ProfileFieldsFragmentDoc}
${CollectModuleFieldsFragmentDoc}
${StatsFieldsFragmentDoc}
${MetadataFieldsFragmentDoc}
${PostFieldsFragmentDoc}`;
export const CommentFieldsFragmentDoc = gql`
    fragment CommentFields on Comment {
  id
  profile {
    ...ProfileFields
  }
  reaction(request: $reactionRequest)
  mirrors(by: $profileId)
  canComment(profileId: $profileId) {
    result
  }
  canMirror(profileId: $profileId) {
    result
  }
  hasCollectedByMe
  collectedBy {
    address
    defaultProfile {
      ...ProfileFields
    }
  }
  collectModule {
    ...CollectModuleFields
  }
  stats {
    ...StatsFields
  }
  metadata {
    ...MetadataFields
  }
  hidden
  createdAt
  appId
  commentOn {
    ... on Post {
      ...PostFields
    }
    ... on Comment {
      id
      profile {
        ...ProfileFields
      }
      reaction(request: $reactionRequest)
      mirrors(by: $profileId)
      canComment(profileId: $profileId) {
        result
      }
      canMirror(profileId: $profileId) {
        result
      }
      hasCollectedByMe
      collectedBy {
        address
        defaultProfile {
          handle
        }
      }
      collectModule {
        ...CollectModuleFields
      }
      metadata {
        ...MetadataFields
      }
      stats {
        ...StatsFields
      }
      mainPost {
        ... on Post {
          ...PostFields
        }
        ... on Mirror {
          ...MirrorFields
        }
      }
      hidden
      createdAt
    }
    ... on Mirror {
      ...MirrorFields
    }
  }
}
    ${ProfileFieldsFragmentDoc}
${CollectModuleFieldsFragmentDoc}
${StatsFieldsFragmentDoc}
${MetadataFieldsFragmentDoc}
${PostFieldsFragmentDoc}
${MirrorFieldsFragmentDoc}`;
export const RelayerResultFieldsFragmentDoc = gql`
    fragment RelayerResultFields on RelayResult {
  ... on RelayerResult {
    txHash
    txId
  }
  ... on RelayError {
    reason
  }
}
    `;
export const AddReactionDocument = gql`
    mutation AddReaction($request: ReactionRequest!) {
  addReaction(request: $request)
}
    `;
export type AddReactionMutationFn = Apollo.MutationFunction<AddReactionMutation, AddReactionMutationVariables>;

/**
 * __useAddReactionMutation__
 *
 * To run a mutation, you first call `useAddReactionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddReactionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addReactionMutation, { data, loading, error }] = useAddReactionMutation({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useAddReactionMutation(baseOptions?: Apollo.MutationHookOptions<AddReactionMutation, AddReactionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddReactionMutation, AddReactionMutationVariables>(AddReactionDocument, options);
      }
export type AddReactionMutationHookResult = ReturnType<typeof useAddReactionMutation>;
export type AddReactionMutationResult = Apollo.MutationResult<AddReactionMutation>;
export type AddReactionMutationOptions = Apollo.BaseMutationOptions<AddReactionMutation, AddReactionMutationVariables>;
export const AuthenticateDocument = gql`
    mutation Authenticate($request: SignedAuthChallenge!) {
  authenticate(request: $request) {
    accessToken
    refreshToken
  }
}
    `;
export type AuthenticateMutationFn = Apollo.MutationFunction<AuthenticateMutation, AuthenticateMutationVariables>;

/**
 * __useAuthenticateMutation__
 *
 * To run a mutation, you first call `useAuthenticateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAuthenticateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [authenticateMutation, { data, loading, error }] = useAuthenticateMutation({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useAuthenticateMutation(baseOptions?: Apollo.MutationHookOptions<AuthenticateMutation, AuthenticateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AuthenticateMutation, AuthenticateMutationVariables>(AuthenticateDocument, options);
      }
export type AuthenticateMutationHookResult = ReturnType<typeof useAuthenticateMutation>;
export type AuthenticateMutationResult = Apollo.MutationResult<AuthenticateMutation>;
export type AuthenticateMutationOptions = Apollo.BaseMutationOptions<AuthenticateMutation, AuthenticateMutationVariables>;
export const BroadcastDocument = gql`
    mutation Broadcast($request: BroadcastRequest!) {
  broadcast(request: $request) {
    ... on RelayerResult {
      txHash
      txId
    }
    ... on RelayError {
      reason
    }
  }
}
    `;
export type BroadcastMutationFn = Apollo.MutationFunction<BroadcastMutation, BroadcastMutationVariables>;

/**
 * __useBroadcastMutation__
 *
 * To run a mutation, you first call `useBroadcastMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBroadcastMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [broadcastMutation, { data, loading, error }] = useBroadcastMutation({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useBroadcastMutation(baseOptions?: Apollo.MutationHookOptions<BroadcastMutation, BroadcastMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<BroadcastMutation, BroadcastMutationVariables>(BroadcastDocument, options);
      }
export type BroadcastMutationHookResult = ReturnType<typeof useBroadcastMutation>;
export type BroadcastMutationResult = Apollo.MutationResult<BroadcastMutation>;
export type BroadcastMutationOptions = Apollo.BaseMutationOptions<BroadcastMutation, BroadcastMutationVariables>;
export const CreateBurnProfileTypedDataDocument = gql`
    mutation CreateBurnProfileTypedData($options: TypedDataOptions, $request: BurnProfileRequest!) {
  createBurnProfileTypedData(options: $options, request: $request) {
    id
    expiresAt
    typedData {
      domain {
        name
        chainId
        version
        verifyingContract
      }
      types {
        BurnWithSig {
          name
          type
        }
      }
      value {
        nonce
        deadline
        tokenId
      }
    }
  }
}
    `;
export type CreateBurnProfileTypedDataMutationFn = Apollo.MutationFunction<CreateBurnProfileTypedDataMutation, CreateBurnProfileTypedDataMutationVariables>;

/**
 * __useCreateBurnProfileTypedDataMutation__
 *
 * To run a mutation, you first call `useCreateBurnProfileTypedDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateBurnProfileTypedDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createBurnProfileTypedDataMutation, { data, loading, error }] = useCreateBurnProfileTypedDataMutation({
 *   variables: {
 *      options: // value for 'options'
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreateBurnProfileTypedDataMutation(baseOptions?: Apollo.MutationHookOptions<CreateBurnProfileTypedDataMutation, CreateBurnProfileTypedDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateBurnProfileTypedDataMutation, CreateBurnProfileTypedDataMutationVariables>(CreateBurnProfileTypedDataDocument, options);
      }
export type CreateBurnProfileTypedDataMutationHookResult = ReturnType<typeof useCreateBurnProfileTypedDataMutation>;
export type CreateBurnProfileTypedDataMutationResult = Apollo.MutationResult<CreateBurnProfileTypedDataMutation>;
export type CreateBurnProfileTypedDataMutationOptions = Apollo.BaseMutationOptions<CreateBurnProfileTypedDataMutation, CreateBurnProfileTypedDataMutationVariables>;
export const CreateCollectTypedDataDocument = gql`
    mutation CreateCollectTypedData($options: TypedDataOptions, $request: CreateCollectRequest!) {
  createCollectTypedData(options: $options, request: $request) {
    id
    expiresAt
    typedData {
      types {
        CollectWithSig {
          name
          type
        }
      }
      domain {
        name
        chainId
        version
        verifyingContract
      }
      value {
        nonce
        deadline
        profileId
        pubId
        data
      }
    }
  }
}
    `;
export type CreateCollectTypedDataMutationFn = Apollo.MutationFunction<CreateCollectTypedDataMutation, CreateCollectTypedDataMutationVariables>;

/**
 * __useCreateCollectTypedDataMutation__
 *
 * To run a mutation, you first call `useCreateCollectTypedDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCollectTypedDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCollectTypedDataMutation, { data, loading, error }] = useCreateCollectTypedDataMutation({
 *   variables: {
 *      options: // value for 'options'
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreateCollectTypedDataMutation(baseOptions?: Apollo.MutationHookOptions<CreateCollectTypedDataMutation, CreateCollectTypedDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCollectTypedDataMutation, CreateCollectTypedDataMutationVariables>(CreateCollectTypedDataDocument, options);
      }
export type CreateCollectTypedDataMutationHookResult = ReturnType<typeof useCreateCollectTypedDataMutation>;
export type CreateCollectTypedDataMutationResult = Apollo.MutationResult<CreateCollectTypedDataMutation>;
export type CreateCollectTypedDataMutationOptions = Apollo.BaseMutationOptions<CreateCollectTypedDataMutation, CreateCollectTypedDataMutationVariables>;
export const CreateCommentTypedDataDocument = gql`
    mutation CreateCommentTypedData($options: TypedDataOptions, $request: CreatePublicCommentRequest!) {
  createCommentTypedData(options: $options, request: $request) {
    id
    expiresAt
    typedData {
      types {
        CommentWithSig {
          name
          type
        }
      }
      domain {
        name
        chainId
        version
        verifyingContract
      }
      value {
        nonce
        deadline
        profileId
        profileIdPointed
        pubIdPointed
        contentURI
        collectModule
        collectModuleInitData
        referenceModule
        referenceModuleData
        referenceModuleInitData
      }
    }
  }
}
    `;
export type CreateCommentTypedDataMutationFn = Apollo.MutationFunction<CreateCommentTypedDataMutation, CreateCommentTypedDataMutationVariables>;

/**
 * __useCreateCommentTypedDataMutation__
 *
 * To run a mutation, you first call `useCreateCommentTypedDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCommentTypedDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCommentTypedDataMutation, { data, loading, error }] = useCreateCommentTypedDataMutation({
 *   variables: {
 *      options: // value for 'options'
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreateCommentTypedDataMutation(baseOptions?: Apollo.MutationHookOptions<CreateCommentTypedDataMutation, CreateCommentTypedDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCommentTypedDataMutation, CreateCommentTypedDataMutationVariables>(CreateCommentTypedDataDocument, options);
      }
export type CreateCommentTypedDataMutationHookResult = ReturnType<typeof useCreateCommentTypedDataMutation>;
export type CreateCommentTypedDataMutationResult = Apollo.MutationResult<CreateCommentTypedDataMutation>;
export type CreateCommentTypedDataMutationOptions = Apollo.BaseMutationOptions<CreateCommentTypedDataMutation, CreateCommentTypedDataMutationVariables>;
export const CreateCommentViaDispatcherDocument = gql`
    mutation CreateCommentViaDispatcher($request: CreatePublicCommentRequest!) {
  createCommentViaDispatcher(request: $request) {
    ...RelayerResultFields
  }
}
    ${RelayerResultFieldsFragmentDoc}`;
export type CreateCommentViaDispatcherMutationFn = Apollo.MutationFunction<CreateCommentViaDispatcherMutation, CreateCommentViaDispatcherMutationVariables>;

/**
 * __useCreateCommentViaDispatcherMutation__
 *
 * To run a mutation, you first call `useCreateCommentViaDispatcherMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCommentViaDispatcherMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCommentViaDispatcherMutation, { data, loading, error }] = useCreateCommentViaDispatcherMutation({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreateCommentViaDispatcherMutation(baseOptions?: Apollo.MutationHookOptions<CreateCommentViaDispatcherMutation, CreateCommentViaDispatcherMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCommentViaDispatcherMutation, CreateCommentViaDispatcherMutationVariables>(CreateCommentViaDispatcherDocument, options);
      }
export type CreateCommentViaDispatcherMutationHookResult = ReturnType<typeof useCreateCommentViaDispatcherMutation>;
export type CreateCommentViaDispatcherMutationResult = Apollo.MutationResult<CreateCommentViaDispatcherMutation>;
export type CreateCommentViaDispatcherMutationOptions = Apollo.BaseMutationOptions<CreateCommentViaDispatcherMutation, CreateCommentViaDispatcherMutationVariables>;
export const CreateFollowTypedDataDocument = gql`
    mutation CreateFollowTypedData($options: TypedDataOptions, $request: FollowRequest!) {
  createFollowTypedData(options: $options, request: $request) {
    id
    expiresAt
    typedData {
      domain {
        name
        chainId
        version
        verifyingContract
      }
      types {
        FollowWithSig {
          name
          type
        }
      }
      value {
        nonce
        deadline
        profileIds
        datas
      }
    }
  }
}
    `;
export type CreateFollowTypedDataMutationFn = Apollo.MutationFunction<CreateFollowTypedDataMutation, CreateFollowTypedDataMutationVariables>;

/**
 * __useCreateFollowTypedDataMutation__
 *
 * To run a mutation, you first call `useCreateFollowTypedDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateFollowTypedDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createFollowTypedDataMutation, { data, loading, error }] = useCreateFollowTypedDataMutation({
 *   variables: {
 *      options: // value for 'options'
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreateFollowTypedDataMutation(baseOptions?: Apollo.MutationHookOptions<CreateFollowTypedDataMutation, CreateFollowTypedDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateFollowTypedDataMutation, CreateFollowTypedDataMutationVariables>(CreateFollowTypedDataDocument, options);
      }
export type CreateFollowTypedDataMutationHookResult = ReturnType<typeof useCreateFollowTypedDataMutation>;
export type CreateFollowTypedDataMutationResult = Apollo.MutationResult<CreateFollowTypedDataMutation>;
export type CreateFollowTypedDataMutationOptions = Apollo.BaseMutationOptions<CreateFollowTypedDataMutation, CreateFollowTypedDataMutationVariables>;
export const CreateMirrorTypedDataDocument = gql`
    mutation CreateMirrorTypedData($options: TypedDataOptions, $request: CreateMirrorRequest!) {
  createMirrorTypedData(options: $options, request: $request) {
    id
    expiresAt
    typedData {
      types {
        MirrorWithSig {
          name
          type
        }
      }
      domain {
        name
        chainId
        version
        verifyingContract
      }
      value {
        nonce
        deadline
        profileId
        profileIdPointed
        pubIdPointed
        referenceModule
        referenceModuleData
        referenceModuleInitData
      }
    }
  }
}
    `;
export type CreateMirrorTypedDataMutationFn = Apollo.MutationFunction<CreateMirrorTypedDataMutation, CreateMirrorTypedDataMutationVariables>;

/**
 * __useCreateMirrorTypedDataMutation__
 *
 * To run a mutation, you first call `useCreateMirrorTypedDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateMirrorTypedDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createMirrorTypedDataMutation, { data, loading, error }] = useCreateMirrorTypedDataMutation({
 *   variables: {
 *      options: // value for 'options'
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreateMirrorTypedDataMutation(baseOptions?: Apollo.MutationHookOptions<CreateMirrorTypedDataMutation, CreateMirrorTypedDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateMirrorTypedDataMutation, CreateMirrorTypedDataMutationVariables>(CreateMirrorTypedDataDocument, options);
      }
export type CreateMirrorTypedDataMutationHookResult = ReturnType<typeof useCreateMirrorTypedDataMutation>;
export type CreateMirrorTypedDataMutationResult = Apollo.MutationResult<CreateMirrorTypedDataMutation>;
export type CreateMirrorTypedDataMutationOptions = Apollo.BaseMutationOptions<CreateMirrorTypedDataMutation, CreateMirrorTypedDataMutationVariables>;
export const CreateMirrorViaDispatcherDocument = gql`
    mutation CreateMirrorViaDispatcher($request: CreateMirrorRequest!) {
  createMirrorViaDispatcher(request: $request) {
    ...RelayerResultFields
  }
}
    ${RelayerResultFieldsFragmentDoc}`;
export type CreateMirrorViaDispatcherMutationFn = Apollo.MutationFunction<CreateMirrorViaDispatcherMutation, CreateMirrorViaDispatcherMutationVariables>;

/**
 * __useCreateMirrorViaDispatcherMutation__
 *
 * To run a mutation, you first call `useCreateMirrorViaDispatcherMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateMirrorViaDispatcherMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createMirrorViaDispatcherMutation, { data, loading, error }] = useCreateMirrorViaDispatcherMutation({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreateMirrorViaDispatcherMutation(baseOptions?: Apollo.MutationHookOptions<CreateMirrorViaDispatcherMutation, CreateMirrorViaDispatcherMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateMirrorViaDispatcherMutation, CreateMirrorViaDispatcherMutationVariables>(CreateMirrorViaDispatcherDocument, options);
      }
export type CreateMirrorViaDispatcherMutationHookResult = ReturnType<typeof useCreateMirrorViaDispatcherMutation>;
export type CreateMirrorViaDispatcherMutationResult = Apollo.MutationResult<CreateMirrorViaDispatcherMutation>;
export type CreateMirrorViaDispatcherMutationOptions = Apollo.BaseMutationOptions<CreateMirrorViaDispatcherMutation, CreateMirrorViaDispatcherMutationVariables>;
export const CreatePostTypedDataDocument = gql`
    mutation CreatePostTypedData($options: TypedDataOptions, $request: CreatePublicPostRequest!) {
  createPostTypedData(options: $options, request: $request) {
    id
    expiresAt
    typedData {
      types {
        PostWithSig {
          name
          type
        }
      }
      domain {
        name
        chainId
        version
        verifyingContract
      }
      value {
        nonce
        deadline
        profileId
        contentURI
        collectModule
        collectModuleInitData
        referenceModule
        referenceModuleInitData
      }
    }
  }
}
    `;
export type CreatePostTypedDataMutationFn = Apollo.MutationFunction<CreatePostTypedDataMutation, CreatePostTypedDataMutationVariables>;

/**
 * __useCreatePostTypedDataMutation__
 *
 * To run a mutation, you first call `useCreatePostTypedDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePostTypedDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPostTypedDataMutation, { data, loading, error }] = useCreatePostTypedDataMutation({
 *   variables: {
 *      options: // value for 'options'
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreatePostTypedDataMutation(baseOptions?: Apollo.MutationHookOptions<CreatePostTypedDataMutation, CreatePostTypedDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePostTypedDataMutation, CreatePostTypedDataMutationVariables>(CreatePostTypedDataDocument, options);
      }
export type CreatePostTypedDataMutationHookResult = ReturnType<typeof useCreatePostTypedDataMutation>;
export type CreatePostTypedDataMutationResult = Apollo.MutationResult<CreatePostTypedDataMutation>;
export type CreatePostTypedDataMutationOptions = Apollo.BaseMutationOptions<CreatePostTypedDataMutation, CreatePostTypedDataMutationVariables>;
export const CreatePostViaDispatcherDocument = gql`
    mutation CreatePostViaDispatcher($request: CreatePublicPostRequest!) {
  createPostViaDispatcher(request: $request) {
    ...RelayerResultFields
  }
}
    ${RelayerResultFieldsFragmentDoc}`;
export type CreatePostViaDispatcherMutationFn = Apollo.MutationFunction<CreatePostViaDispatcherMutation, CreatePostViaDispatcherMutationVariables>;

/**
 * __useCreatePostViaDispatcherMutation__
 *
 * To run a mutation, you first call `useCreatePostViaDispatcherMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePostViaDispatcherMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPostViaDispatcherMutation, { data, loading, error }] = useCreatePostViaDispatcherMutation({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreatePostViaDispatcherMutation(baseOptions?: Apollo.MutationHookOptions<CreatePostViaDispatcherMutation, CreatePostViaDispatcherMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePostViaDispatcherMutation, CreatePostViaDispatcherMutationVariables>(CreatePostViaDispatcherDocument, options);
      }
export type CreatePostViaDispatcherMutationHookResult = ReturnType<typeof useCreatePostViaDispatcherMutation>;
export type CreatePostViaDispatcherMutationResult = Apollo.MutationResult<CreatePostViaDispatcherMutation>;
export type CreatePostViaDispatcherMutationOptions = Apollo.BaseMutationOptions<CreatePostViaDispatcherMutation, CreatePostViaDispatcherMutationVariables>;
export const CreateProfileDocument = gql`
    mutation CreateProfile($request: CreateProfileRequest!) {
  createProfile(request: $request) {
    ...RelayerResultFields
  }
}
    ${RelayerResultFieldsFragmentDoc}`;
export type CreateProfileMutationFn = Apollo.MutationFunction<CreateProfileMutation, CreateProfileMutationVariables>;

/**
 * __useCreateProfileMutation__
 *
 * To run a mutation, you first call `useCreateProfileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateProfileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createProfileMutation, { data, loading, error }] = useCreateProfileMutation({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreateProfileMutation(baseOptions?: Apollo.MutationHookOptions<CreateProfileMutation, CreateProfileMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateProfileMutation, CreateProfileMutationVariables>(CreateProfileDocument, options);
      }
export type CreateProfileMutationHookResult = ReturnType<typeof useCreateProfileMutation>;
export type CreateProfileMutationResult = Apollo.MutationResult<CreateProfileMutation>;
export type CreateProfileMutationOptions = Apollo.BaseMutationOptions<CreateProfileMutation, CreateProfileMutationVariables>;
export const CreateSetDefaultProfileTypedDataDocument = gql`
    mutation CreateSetDefaultProfileTypedData($options: TypedDataOptions, $request: CreateSetDefaultProfileRequest!) {
  createSetDefaultProfileTypedData(options: $options, request: $request) {
    id
    expiresAt
    typedData {
      domain {
        name
        chainId
        version
        verifyingContract
      }
      types {
        SetDefaultProfileWithSig {
          name
          type
        }
      }
      value {
        nonce
        deadline
        wallet
        profileId
      }
    }
  }
}
    `;
export type CreateSetDefaultProfileTypedDataMutationFn = Apollo.MutationFunction<CreateSetDefaultProfileTypedDataMutation, CreateSetDefaultProfileTypedDataMutationVariables>;

/**
 * __useCreateSetDefaultProfileTypedDataMutation__
 *
 * To run a mutation, you first call `useCreateSetDefaultProfileTypedDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSetDefaultProfileTypedDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSetDefaultProfileTypedDataMutation, { data, loading, error }] = useCreateSetDefaultProfileTypedDataMutation({
 *   variables: {
 *      options: // value for 'options'
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreateSetDefaultProfileTypedDataMutation(baseOptions?: Apollo.MutationHookOptions<CreateSetDefaultProfileTypedDataMutation, CreateSetDefaultProfileTypedDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSetDefaultProfileTypedDataMutation, CreateSetDefaultProfileTypedDataMutationVariables>(CreateSetDefaultProfileTypedDataDocument, options);
      }
export type CreateSetDefaultProfileTypedDataMutationHookResult = ReturnType<typeof useCreateSetDefaultProfileTypedDataMutation>;
export type CreateSetDefaultProfileTypedDataMutationResult = Apollo.MutationResult<CreateSetDefaultProfileTypedDataMutation>;
export type CreateSetDefaultProfileTypedDataMutationOptions = Apollo.BaseMutationOptions<CreateSetDefaultProfileTypedDataMutation, CreateSetDefaultProfileTypedDataMutationVariables>;
export const CreateSetDispatcherTypedDataDocument = gql`
    mutation CreateSetDispatcherTypedData($options: TypedDataOptions, $request: SetDispatcherRequest!) {
  createSetDispatcherTypedData(options: $options, request: $request) {
    id
    expiresAt
    typedData {
      types {
        SetDispatcherWithSig {
          name
          type
        }
      }
      domain {
        name
        chainId
        version
        verifyingContract
      }
      value {
        nonce
        deadline
        profileId
        dispatcher
      }
    }
  }
}
    `;
export type CreateSetDispatcherTypedDataMutationFn = Apollo.MutationFunction<CreateSetDispatcherTypedDataMutation, CreateSetDispatcherTypedDataMutationVariables>;

/**
 * __useCreateSetDispatcherTypedDataMutation__
 *
 * To run a mutation, you first call `useCreateSetDispatcherTypedDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSetDispatcherTypedDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSetDispatcherTypedDataMutation, { data, loading, error }] = useCreateSetDispatcherTypedDataMutation({
 *   variables: {
 *      options: // value for 'options'
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreateSetDispatcherTypedDataMutation(baseOptions?: Apollo.MutationHookOptions<CreateSetDispatcherTypedDataMutation, CreateSetDispatcherTypedDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSetDispatcherTypedDataMutation, CreateSetDispatcherTypedDataMutationVariables>(CreateSetDispatcherTypedDataDocument, options);
      }
export type CreateSetDispatcherTypedDataMutationHookResult = ReturnType<typeof useCreateSetDispatcherTypedDataMutation>;
export type CreateSetDispatcherTypedDataMutationResult = Apollo.MutationResult<CreateSetDispatcherTypedDataMutation>;
export type CreateSetDispatcherTypedDataMutationOptions = Apollo.BaseMutationOptions<CreateSetDispatcherTypedDataMutation, CreateSetDispatcherTypedDataMutationVariables>;
export const CreateSetFollowModuleTypedDataDocument = gql`
    mutation CreateSetFollowModuleTypedData($options: TypedDataOptions, $request: CreateSetFollowModuleRequest!) {
  createSetFollowModuleTypedData(options: $options, request: $request) {
    id
    expiresAt
    typedData {
      types {
        SetFollowModuleWithSig {
          name
          type
        }
      }
      domain {
        name
        chainId
        version
        verifyingContract
      }
      value {
        nonce
        deadline
        profileId
        followModule
        followModuleInitData
      }
    }
  }
}
    `;
export type CreateSetFollowModuleTypedDataMutationFn = Apollo.MutationFunction<CreateSetFollowModuleTypedDataMutation, CreateSetFollowModuleTypedDataMutationVariables>;

/**
 * __useCreateSetFollowModuleTypedDataMutation__
 *
 * To run a mutation, you first call `useCreateSetFollowModuleTypedDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSetFollowModuleTypedDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSetFollowModuleTypedDataMutation, { data, loading, error }] = useCreateSetFollowModuleTypedDataMutation({
 *   variables: {
 *      options: // value for 'options'
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreateSetFollowModuleTypedDataMutation(baseOptions?: Apollo.MutationHookOptions<CreateSetFollowModuleTypedDataMutation, CreateSetFollowModuleTypedDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSetFollowModuleTypedDataMutation, CreateSetFollowModuleTypedDataMutationVariables>(CreateSetFollowModuleTypedDataDocument, options);
      }
export type CreateSetFollowModuleTypedDataMutationHookResult = ReturnType<typeof useCreateSetFollowModuleTypedDataMutation>;
export type CreateSetFollowModuleTypedDataMutationResult = Apollo.MutationResult<CreateSetFollowModuleTypedDataMutation>;
export type CreateSetFollowModuleTypedDataMutationOptions = Apollo.BaseMutationOptions<CreateSetFollowModuleTypedDataMutation, CreateSetFollowModuleTypedDataMutationVariables>;
export const CreateSetProfileImageUriTypedDataDocument = gql`
    mutation CreateSetProfileImageURITypedData($options: TypedDataOptions, $request: UpdateProfileImageRequest!) {
  createSetProfileImageURITypedData(options: $options, request: $request) {
    id
    expiresAt
    typedData {
      domain {
        name
        chainId
        version
        verifyingContract
      }
      types {
        SetProfileImageURIWithSig {
          name
          type
        }
      }
      value {
        nonce
        deadline
        imageURI
        profileId
      }
    }
  }
}
    `;
export type CreateSetProfileImageUriTypedDataMutationFn = Apollo.MutationFunction<CreateSetProfileImageUriTypedDataMutation, CreateSetProfileImageUriTypedDataMutationVariables>;

/**
 * __useCreateSetProfileImageUriTypedDataMutation__
 *
 * To run a mutation, you first call `useCreateSetProfileImageUriTypedDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSetProfileImageUriTypedDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSetProfileImageUriTypedDataMutation, { data, loading, error }] = useCreateSetProfileImageUriTypedDataMutation({
 *   variables: {
 *      options: // value for 'options'
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreateSetProfileImageUriTypedDataMutation(baseOptions?: Apollo.MutationHookOptions<CreateSetProfileImageUriTypedDataMutation, CreateSetProfileImageUriTypedDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSetProfileImageUriTypedDataMutation, CreateSetProfileImageUriTypedDataMutationVariables>(CreateSetProfileImageUriTypedDataDocument, options);
      }
export type CreateSetProfileImageUriTypedDataMutationHookResult = ReturnType<typeof useCreateSetProfileImageUriTypedDataMutation>;
export type CreateSetProfileImageUriTypedDataMutationResult = Apollo.MutationResult<CreateSetProfileImageUriTypedDataMutation>;
export type CreateSetProfileImageUriTypedDataMutationOptions = Apollo.BaseMutationOptions<CreateSetProfileImageUriTypedDataMutation, CreateSetProfileImageUriTypedDataMutationVariables>;
export const CreateSetProfileImageUriViaDispatcherDocument = gql`
    mutation CreateSetProfileImageURIViaDispatcher($request: UpdateProfileImageRequest!) {
  createSetProfileImageURIViaDispatcher(request: $request) {
    ...RelayerResultFields
  }
}
    ${RelayerResultFieldsFragmentDoc}`;
export type CreateSetProfileImageUriViaDispatcherMutationFn = Apollo.MutationFunction<CreateSetProfileImageUriViaDispatcherMutation, CreateSetProfileImageUriViaDispatcherMutationVariables>;

/**
 * __useCreateSetProfileImageUriViaDispatcherMutation__
 *
 * To run a mutation, you first call `useCreateSetProfileImageUriViaDispatcherMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSetProfileImageUriViaDispatcherMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSetProfileImageUriViaDispatcherMutation, { data, loading, error }] = useCreateSetProfileImageUriViaDispatcherMutation({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreateSetProfileImageUriViaDispatcherMutation(baseOptions?: Apollo.MutationHookOptions<CreateSetProfileImageUriViaDispatcherMutation, CreateSetProfileImageUriViaDispatcherMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSetProfileImageUriViaDispatcherMutation, CreateSetProfileImageUriViaDispatcherMutationVariables>(CreateSetProfileImageUriViaDispatcherDocument, options);
      }
export type CreateSetProfileImageUriViaDispatcherMutationHookResult = ReturnType<typeof useCreateSetProfileImageUriViaDispatcherMutation>;
export type CreateSetProfileImageUriViaDispatcherMutationResult = Apollo.MutationResult<CreateSetProfileImageUriViaDispatcherMutation>;
export type CreateSetProfileImageUriViaDispatcherMutationOptions = Apollo.BaseMutationOptions<CreateSetProfileImageUriViaDispatcherMutation, CreateSetProfileImageUriViaDispatcherMutationVariables>;
export const CreateSetProfileMetadataTypedDataDocument = gql`
    mutation CreateSetProfileMetadataTypedData($options: TypedDataOptions, $request: CreatePublicSetProfileMetadataURIRequest!) {
  createSetProfileMetadataTypedData(options: $options, request: $request) {
    id
    expiresAt
    typedData {
      types {
        SetProfileMetadataURIWithSig {
          name
          type
        }
      }
      domain {
        name
        chainId
        version
        verifyingContract
      }
      value {
        nonce
        deadline
        profileId
        metadata
      }
    }
  }
}
    `;
export type CreateSetProfileMetadataTypedDataMutationFn = Apollo.MutationFunction<CreateSetProfileMetadataTypedDataMutation, CreateSetProfileMetadataTypedDataMutationVariables>;

/**
 * __useCreateSetProfileMetadataTypedDataMutation__
 *
 * To run a mutation, you first call `useCreateSetProfileMetadataTypedDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSetProfileMetadataTypedDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSetProfileMetadataTypedDataMutation, { data, loading, error }] = useCreateSetProfileMetadataTypedDataMutation({
 *   variables: {
 *      options: // value for 'options'
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreateSetProfileMetadataTypedDataMutation(baseOptions?: Apollo.MutationHookOptions<CreateSetProfileMetadataTypedDataMutation, CreateSetProfileMetadataTypedDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSetProfileMetadataTypedDataMutation, CreateSetProfileMetadataTypedDataMutationVariables>(CreateSetProfileMetadataTypedDataDocument, options);
      }
export type CreateSetProfileMetadataTypedDataMutationHookResult = ReturnType<typeof useCreateSetProfileMetadataTypedDataMutation>;
export type CreateSetProfileMetadataTypedDataMutationResult = Apollo.MutationResult<CreateSetProfileMetadataTypedDataMutation>;
export type CreateSetProfileMetadataTypedDataMutationOptions = Apollo.BaseMutationOptions<CreateSetProfileMetadataTypedDataMutation, CreateSetProfileMetadataTypedDataMutationVariables>;
export const CreateSetProfileMetadataViaDispatcherDocument = gql`
    mutation CreateSetProfileMetadataViaDispatcher($request: CreatePublicSetProfileMetadataURIRequest!) {
  createSetProfileMetadataViaDispatcher(request: $request) {
    ...RelayerResultFields
  }
}
    ${RelayerResultFieldsFragmentDoc}`;
export type CreateSetProfileMetadataViaDispatcherMutationFn = Apollo.MutationFunction<CreateSetProfileMetadataViaDispatcherMutation, CreateSetProfileMetadataViaDispatcherMutationVariables>;

/**
 * __useCreateSetProfileMetadataViaDispatcherMutation__
 *
 * To run a mutation, you first call `useCreateSetProfileMetadataViaDispatcherMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSetProfileMetadataViaDispatcherMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSetProfileMetadataViaDispatcherMutation, { data, loading, error }] = useCreateSetProfileMetadataViaDispatcherMutation({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreateSetProfileMetadataViaDispatcherMutation(baseOptions?: Apollo.MutationHookOptions<CreateSetProfileMetadataViaDispatcherMutation, CreateSetProfileMetadataViaDispatcherMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSetProfileMetadataViaDispatcherMutation, CreateSetProfileMetadataViaDispatcherMutationVariables>(CreateSetProfileMetadataViaDispatcherDocument, options);
      }
export type CreateSetProfileMetadataViaDispatcherMutationHookResult = ReturnType<typeof useCreateSetProfileMetadataViaDispatcherMutation>;
export type CreateSetProfileMetadataViaDispatcherMutationResult = Apollo.MutationResult<CreateSetProfileMetadataViaDispatcherMutation>;
export type CreateSetProfileMetadataViaDispatcherMutationOptions = Apollo.BaseMutationOptions<CreateSetProfileMetadataViaDispatcherMutation, CreateSetProfileMetadataViaDispatcherMutationVariables>;
export const CreateUnfollowTypedDataDocument = gql`
    mutation CreateUnfollowTypedData($request: UnfollowRequest!) {
  createUnfollowTypedData(request: $request) {
    id
    expiresAt
    typedData {
      domain {
        name
        chainId
        version
        verifyingContract
      }
      types {
        BurnWithSig {
          name
          type
        }
      }
      value {
        nonce
        deadline
        tokenId
      }
    }
  }
}
    `;
export type CreateUnfollowTypedDataMutationFn = Apollo.MutationFunction<CreateUnfollowTypedDataMutation, CreateUnfollowTypedDataMutationVariables>;

/**
 * __useCreateUnfollowTypedDataMutation__
 *
 * To run a mutation, you first call `useCreateUnfollowTypedDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateUnfollowTypedDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createUnfollowTypedDataMutation, { data, loading, error }] = useCreateUnfollowTypedDataMutation({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCreateUnfollowTypedDataMutation(baseOptions?: Apollo.MutationHookOptions<CreateUnfollowTypedDataMutation, CreateUnfollowTypedDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateUnfollowTypedDataMutation, CreateUnfollowTypedDataMutationVariables>(CreateUnfollowTypedDataDocument, options);
      }
export type CreateUnfollowTypedDataMutationHookResult = ReturnType<typeof useCreateUnfollowTypedDataMutation>;
export type CreateUnfollowTypedDataMutationResult = Apollo.MutationResult<CreateUnfollowTypedDataMutation>;
export type CreateUnfollowTypedDataMutationOptions = Apollo.BaseMutationOptions<CreateUnfollowTypedDataMutation, CreateUnfollowTypedDataMutationVariables>;
export const HidePublicationDocument = gql`
    mutation HidePublication($request: HidePublicationRequest!) {
  hidePublication(request: $request)
}
    `;
export type HidePublicationMutationFn = Apollo.MutationFunction<HidePublicationMutation, HidePublicationMutationVariables>;

/**
 * __useHidePublicationMutation__
 *
 * To run a mutation, you first call `useHidePublicationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useHidePublicationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [hidePublicationMutation, { data, loading, error }] = useHidePublicationMutation({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useHidePublicationMutation(baseOptions?: Apollo.MutationHookOptions<HidePublicationMutation, HidePublicationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<HidePublicationMutation, HidePublicationMutationVariables>(HidePublicationDocument, options);
      }
export type HidePublicationMutationHookResult = ReturnType<typeof useHidePublicationMutation>;
export type HidePublicationMutationResult = Apollo.MutationResult<HidePublicationMutation>;
export type HidePublicationMutationOptions = Apollo.BaseMutationOptions<HidePublicationMutation, HidePublicationMutationVariables>;
export const ProxyActionDocument = gql`
    mutation ProxyAction($request: ProxyActionRequest!) {
  proxyAction(request: $request)
}
    `;
export type ProxyActionMutationFn = Apollo.MutationFunction<ProxyActionMutation, ProxyActionMutationVariables>;

/**
 * __useProxyActionMutation__
 *
 * To run a mutation, you first call `useProxyActionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useProxyActionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [proxyActionMutation, { data, loading, error }] = useProxyActionMutation({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useProxyActionMutation(baseOptions?: Apollo.MutationHookOptions<ProxyActionMutation, ProxyActionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ProxyActionMutation, ProxyActionMutationVariables>(ProxyActionDocument, options);
      }
export type ProxyActionMutationHookResult = ReturnType<typeof useProxyActionMutation>;
export type ProxyActionMutationResult = Apollo.MutationResult<ProxyActionMutation>;
export type ProxyActionMutationOptions = Apollo.BaseMutationOptions<ProxyActionMutation, ProxyActionMutationVariables>;
export const RemoveReactionDocument = gql`
    mutation RemoveReaction($request: ReactionRequest!) {
  removeReaction(request: $request)
}
    `;
export type RemoveReactionMutationFn = Apollo.MutationFunction<RemoveReactionMutation, RemoveReactionMutationVariables>;

/**
 * __useRemoveReactionMutation__
 *
 * To run a mutation, you first call `useRemoveReactionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveReactionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeReactionMutation, { data, loading, error }] = useRemoveReactionMutation({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useRemoveReactionMutation(baseOptions?: Apollo.MutationHookOptions<RemoveReactionMutation, RemoveReactionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveReactionMutation, RemoveReactionMutationVariables>(RemoveReactionDocument, options);
      }
export type RemoveReactionMutationHookResult = ReturnType<typeof useRemoveReactionMutation>;
export type RemoveReactionMutationResult = Apollo.MutationResult<RemoveReactionMutation>;
export type RemoveReactionMutationOptions = Apollo.BaseMutationOptions<RemoveReactionMutation, RemoveReactionMutationVariables>;
export const ReportPublicationDocument = gql`
    mutation ReportPublication($request: ReportPublicationRequest!) {
  reportPublication(request: $request)
}
    `;
export type ReportPublicationMutationFn = Apollo.MutationFunction<ReportPublicationMutation, ReportPublicationMutationVariables>;

/**
 * __useReportPublicationMutation__
 *
 * To run a mutation, you first call `useReportPublicationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useReportPublicationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [reportPublicationMutation, { data, loading, error }] = useReportPublicationMutation({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useReportPublicationMutation(baseOptions?: Apollo.MutationHookOptions<ReportPublicationMutation, ReportPublicationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ReportPublicationMutation, ReportPublicationMutationVariables>(ReportPublicationDocument, options);
      }
export type ReportPublicationMutationHookResult = ReturnType<typeof useReportPublicationMutation>;
export type ReportPublicationMutationResult = Apollo.MutationResult<ReportPublicationMutation>;
export type ReportPublicationMutationOptions = Apollo.BaseMutationOptions<ReportPublicationMutation, ReportPublicationMutationVariables>;
export const ApprovedModuleAllowanceAmountDocument = gql`
    query ApprovedModuleAllowanceAmount($request: ApprovedModuleAllowanceAmountRequest!) {
  approvedModuleAllowanceAmount(request: $request) {
    currency
    module
    allowance
    contractAddress
  }
  enabledModuleCurrencies {
    name
    symbol
    decimals
    address
  }
}
    `;

/**
 * __useApprovedModuleAllowanceAmountQuery__
 *
 * To run a query within a React component, call `useApprovedModuleAllowanceAmountQuery` and pass it any options that fit your needs.
 * When your component renders, `useApprovedModuleAllowanceAmountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useApprovedModuleAllowanceAmountQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useApprovedModuleAllowanceAmountQuery(baseOptions: Apollo.QueryHookOptions<ApprovedModuleAllowanceAmountQuery, ApprovedModuleAllowanceAmountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ApprovedModuleAllowanceAmountQuery, ApprovedModuleAllowanceAmountQueryVariables>(ApprovedModuleAllowanceAmountDocument, options);
      }
export function useApprovedModuleAllowanceAmountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ApprovedModuleAllowanceAmountQuery, ApprovedModuleAllowanceAmountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ApprovedModuleAllowanceAmountQuery, ApprovedModuleAllowanceAmountQueryVariables>(ApprovedModuleAllowanceAmountDocument, options);
        }
export type ApprovedModuleAllowanceAmountQueryHookResult = ReturnType<typeof useApprovedModuleAllowanceAmountQuery>;
export type ApprovedModuleAllowanceAmountLazyQueryHookResult = ReturnType<typeof useApprovedModuleAllowanceAmountLazyQuery>;
export type ApprovedModuleAllowanceAmountQueryResult = Apollo.QueryResult<ApprovedModuleAllowanceAmountQuery, ApprovedModuleAllowanceAmountQueryVariables>;
export const ChallengeDocument = gql`
    query Challenge($request: ChallengeRequest!) {
  challenge(request: $request) {
    text
  }
}
    `;

/**
 * __useChallengeQuery__
 *
 * To run a query within a React component, call `useChallengeQuery` and pass it any options that fit your needs.
 * When your component renders, `useChallengeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChallengeQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useChallengeQuery(baseOptions: Apollo.QueryHookOptions<ChallengeQuery, ChallengeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChallengeQuery, ChallengeQueryVariables>(ChallengeDocument, options);
      }
export function useChallengeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChallengeQuery, ChallengeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChallengeQuery, ChallengeQueryVariables>(ChallengeDocument, options);
        }
export type ChallengeQueryHookResult = ReturnType<typeof useChallengeQuery>;
export type ChallengeLazyQueryHookResult = ReturnType<typeof useChallengeLazyQuery>;
export type ChallengeQueryResult = Apollo.QueryResult<ChallengeQuery, ChallengeQueryVariables>;
export const CollectModuleDocument = gql`
    query CollectModule($request: PublicationQueryRequest!) {
  publication(request: $request) {
    ... on Post {
      collectNftAddress
      collectModule {
        ...CollectModuleFields
      }
    }
    ... on Comment {
      collectNftAddress
      collectModule {
        ...CollectModuleFields
      }
    }
    ... on Mirror {
      collectNftAddress
      collectModule {
        ...CollectModuleFields
      }
    }
  }
}
    ${CollectModuleFieldsFragmentDoc}`;

/**
 * __useCollectModuleQuery__
 *
 * To run a query within a React component, call `useCollectModuleQuery` and pass it any options that fit your needs.
 * When your component renders, `useCollectModuleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCollectModuleQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCollectModuleQuery(baseOptions: Apollo.QueryHookOptions<CollectModuleQuery, CollectModuleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CollectModuleQuery, CollectModuleQueryVariables>(CollectModuleDocument, options);
      }
export function useCollectModuleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CollectModuleQuery, CollectModuleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CollectModuleQuery, CollectModuleQueryVariables>(CollectModuleDocument, options);
        }
export type CollectModuleQueryHookResult = ReturnType<typeof useCollectModuleQuery>;
export type CollectModuleLazyQueryHookResult = ReturnType<typeof useCollectModuleLazyQuery>;
export type CollectModuleQueryResult = Apollo.QueryResult<CollectModuleQuery, CollectModuleQueryVariables>;
export const CollectorsDocument = gql`
    query Collectors($request: WhoCollectedPublicationRequest!) {
  whoCollectedPublication(request: $request) {
    items {
      address
      defaultProfile {
        ...ProfileFields
        isFollowedByMe
      }
    }
    pageInfo {
      next
      totalCount
    }
  }
}
    ${ProfileFieldsFragmentDoc}`;

/**
 * __useCollectorsQuery__
 *
 * To run a query within a React component, call `useCollectorsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCollectorsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCollectorsQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useCollectorsQuery(baseOptions: Apollo.QueryHookOptions<CollectorsQuery, CollectorsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CollectorsQuery, CollectorsQueryVariables>(CollectorsDocument, options);
      }
export function useCollectorsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CollectorsQuery, CollectorsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CollectorsQuery, CollectorsQueryVariables>(CollectorsDocument, options);
        }
export type CollectorsQueryHookResult = ReturnType<typeof useCollectorsQuery>;
export type CollectorsLazyQueryHookResult = ReturnType<typeof useCollectorsLazyQuery>;
export type CollectorsQueryResult = Apollo.QueryResult<CollectorsQuery, CollectorsQueryVariables>;
export const CommentFeedDocument = gql`
    query CommentFeed($request: PublicationsQueryRequest!, $reactionRequest: ReactionFieldResolverRequest, $profileId: ProfileId) {
  publications(request: $request) {
    items {
      ... on Comment {
        ...CommentFields
      }
    }
    pageInfo {
      totalCount
      next
    }
  }
}
    ${CommentFieldsFragmentDoc}`;

/**
 * __useCommentFeedQuery__
 *
 * To run a query within a React component, call `useCommentFeedQuery` and pass it any options that fit your needs.
 * When your component renders, `useCommentFeedQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCommentFeedQuery({
 *   variables: {
 *      request: // value for 'request'
 *      reactionRequest: // value for 'reactionRequest'
 *      profileId: // value for 'profileId'
 *   },
 * });
 */
export function useCommentFeedQuery(baseOptions: Apollo.QueryHookOptions<CommentFeedQuery, CommentFeedQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CommentFeedQuery, CommentFeedQueryVariables>(CommentFeedDocument, options);
      }
export function useCommentFeedLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CommentFeedQuery, CommentFeedQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CommentFeedQuery, CommentFeedQueryVariables>(CommentFeedDocument, options);
        }
export type CommentFeedQueryHookResult = ReturnType<typeof useCommentFeedQuery>;
export type CommentFeedLazyQueryHookResult = ReturnType<typeof useCommentFeedLazyQuery>;
export type CommentFeedQueryResult = Apollo.QueryResult<CommentFeedQuery, CommentFeedQueryVariables>;
export const EnabledCurrencyModulesDocument = gql`
    query EnabledCurrencyModules {
  enabledModuleCurrencies {
    name
    symbol
    decimals
    address
  }
}
    `;

/**
 * __useEnabledCurrencyModulesQuery__
 *
 * To run a query within a React component, call `useEnabledCurrencyModulesQuery` and pass it any options that fit your needs.
 * When your component renders, `useEnabledCurrencyModulesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEnabledCurrencyModulesQuery({
 *   variables: {
 *   },
 * });
 */
export function useEnabledCurrencyModulesQuery(baseOptions?: Apollo.QueryHookOptions<EnabledCurrencyModulesQuery, EnabledCurrencyModulesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EnabledCurrencyModulesQuery, EnabledCurrencyModulesQueryVariables>(EnabledCurrencyModulesDocument, options);
      }
export function useEnabledCurrencyModulesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EnabledCurrencyModulesQuery, EnabledCurrencyModulesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EnabledCurrencyModulesQuery, EnabledCurrencyModulesQueryVariables>(EnabledCurrencyModulesDocument, options);
        }
export type EnabledCurrencyModulesQueryHookResult = ReturnType<typeof useEnabledCurrencyModulesQuery>;
export type EnabledCurrencyModulesLazyQueryHookResult = ReturnType<typeof useEnabledCurrencyModulesLazyQuery>;
export type EnabledCurrencyModulesQueryResult = Apollo.QueryResult<EnabledCurrencyModulesQuery, EnabledCurrencyModulesQueryVariables>;
export const EnabledCurrencyModulesWithProfileDocument = gql`
    query EnabledCurrencyModulesWithProfile($request: SingleProfileQueryRequest!) {
  enabledModuleCurrencies {
    name
    symbol
    decimals
    address
  }
  profile(request: $request) {
    followModule {
      __typename
    }
  }
}
    `;

/**
 * __useEnabledCurrencyModulesWithProfileQuery__
 *
 * To run a query within a React component, call `useEnabledCurrencyModulesWithProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useEnabledCurrencyModulesWithProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEnabledCurrencyModulesWithProfileQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useEnabledCurrencyModulesWithProfileQuery(baseOptions: Apollo.QueryHookOptions<EnabledCurrencyModulesWithProfileQuery, EnabledCurrencyModulesWithProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EnabledCurrencyModulesWithProfileQuery, EnabledCurrencyModulesWithProfileQueryVariables>(EnabledCurrencyModulesWithProfileDocument, options);
      }
export function useEnabledCurrencyModulesWithProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EnabledCurrencyModulesWithProfileQuery, EnabledCurrencyModulesWithProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EnabledCurrencyModulesWithProfileQuery, EnabledCurrencyModulesWithProfileQueryVariables>(EnabledCurrencyModulesWithProfileDocument, options);
        }
export type EnabledCurrencyModulesWithProfileQueryHookResult = ReturnType<typeof useEnabledCurrencyModulesWithProfileQuery>;
export type EnabledCurrencyModulesWithProfileLazyQueryHookResult = ReturnType<typeof useEnabledCurrencyModulesWithProfileLazyQuery>;
export type EnabledCurrencyModulesWithProfileQueryResult = Apollo.QueryResult<EnabledCurrencyModulesWithProfileQuery, EnabledCurrencyModulesWithProfileQueryVariables>;
export const EnabledModulesDocument = gql`
    query EnabledModules {
  enabledModules {
    collectModules {
      moduleName
      contractAddress
    }
  }
  enabledModuleCurrencies {
    name
    symbol
    decimals
    address
  }
}
    `;

/**
 * __useEnabledModulesQuery__
 *
 * To run a query within a React component, call `useEnabledModulesQuery` and pass it any options that fit your needs.
 * When your component renders, `useEnabledModulesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEnabledModulesQuery({
 *   variables: {
 *   },
 * });
 */
export function useEnabledModulesQuery(baseOptions?: Apollo.QueryHookOptions<EnabledModulesQuery, EnabledModulesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EnabledModulesQuery, EnabledModulesQueryVariables>(EnabledModulesDocument, options);
      }
export function useEnabledModulesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EnabledModulesQuery, EnabledModulesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EnabledModulesQuery, EnabledModulesQueryVariables>(EnabledModulesDocument, options);
        }
export type EnabledModulesQueryHookResult = ReturnType<typeof useEnabledModulesQuery>;
export type EnabledModulesLazyQueryHookResult = ReturnType<typeof useEnabledModulesLazyQuery>;
export type EnabledModulesQueryResult = Apollo.QueryResult<EnabledModulesQuery, EnabledModulesQueryVariables>;
export const ExploreFeedDocument = gql`
    query ExploreFeed($request: ExplorePublicationRequest!, $reactionRequest: ReactionFieldResolverRequest, $profileId: ProfileId) {
  explorePublications(request: $request) {
    items {
      ... on Post {
        ...PostFields
      }
      ... on Comment {
        ...CommentFields
      }
      ... on Mirror {
        ...MirrorFields
      }
    }
    pageInfo {
      totalCount
      next
    }
  }
}
    ${PostFieldsFragmentDoc}
${CommentFieldsFragmentDoc}
${MirrorFieldsFragmentDoc}`;

/**
 * __useExploreFeedQuery__
 *
 * To run a query within a React component, call `useExploreFeedQuery` and pass it any options that fit your needs.
 * When your component renders, `useExploreFeedQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useExploreFeedQuery({
 *   variables: {
 *      request: // value for 'request'
 *      reactionRequest: // value for 'reactionRequest'
 *      profileId: // value for 'profileId'
 *   },
 * });
 */
export function useExploreFeedQuery(baseOptions: Apollo.QueryHookOptions<ExploreFeedQuery, ExploreFeedQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ExploreFeedQuery, ExploreFeedQueryVariables>(ExploreFeedDocument, options);
      }
export function useExploreFeedLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ExploreFeedQuery, ExploreFeedQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ExploreFeedQuery, ExploreFeedQueryVariables>(ExploreFeedDocument, options);
        }
export type ExploreFeedQueryHookResult = ReturnType<typeof useExploreFeedQuery>;
export type ExploreFeedLazyQueryHookResult = ReturnType<typeof useExploreFeedLazyQuery>;
export type ExploreFeedQueryResult = Apollo.QueryResult<ExploreFeedQuery, ExploreFeedQueryVariables>;
export const FeedHighlightsDocument = gql`
    query FeedHighlights($request: FeedHighlightsRequest!, $reactionRequest: ReactionFieldResolverRequest, $profileId: ProfileId) {
  feedHighlights(request: $request) {
    items {
      ... on Post {
        ...PostFields
      }
      ... on Comment {
        ...CommentFields
      }
      ... on Mirror {
        ...MirrorFields
      }
    }
    pageInfo {
      totalCount
      next
    }
  }
}
    ${PostFieldsFragmentDoc}
${CommentFieldsFragmentDoc}
${MirrorFieldsFragmentDoc}`;

/**
 * __useFeedHighlightsQuery__
 *
 * To run a query within a React component, call `useFeedHighlightsQuery` and pass it any options that fit your needs.
 * When your component renders, `useFeedHighlightsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFeedHighlightsQuery({
 *   variables: {
 *      request: // value for 'request'
 *      reactionRequest: // value for 'reactionRequest'
 *      profileId: // value for 'profileId'
 *   },
 * });
 */
export function useFeedHighlightsQuery(baseOptions: Apollo.QueryHookOptions<FeedHighlightsQuery, FeedHighlightsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FeedHighlightsQuery, FeedHighlightsQueryVariables>(FeedHighlightsDocument, options);
      }
export function useFeedHighlightsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FeedHighlightsQuery, FeedHighlightsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FeedHighlightsQuery, FeedHighlightsQueryVariables>(FeedHighlightsDocument, options);
        }
export type FeedHighlightsQueryHookResult = ReturnType<typeof useFeedHighlightsQuery>;
export type FeedHighlightsLazyQueryHookResult = ReturnType<typeof useFeedHighlightsLazyQuery>;
export type FeedHighlightsQueryResult = Apollo.QueryResult<FeedHighlightsQuery, FeedHighlightsQueryVariables>;
export const FollowersDocument = gql`
    query Followers($request: FollowersRequest!) {
  followers(request: $request) {
    items {
      wallet {
        address
        defaultProfile {
          ...ProfileFields
          isFollowedByMe
        }
      }
      totalAmountOfTimesFollowed
    }
    pageInfo {
      next
      totalCount
    }
  }
}
    ${ProfileFieldsFragmentDoc}`;

/**
 * __useFollowersQuery__
 *
 * To run a query within a React component, call `useFollowersQuery` and pass it any options that fit your needs.
 * When your component renders, `useFollowersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFollowersQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useFollowersQuery(baseOptions: Apollo.QueryHookOptions<FollowersQuery, FollowersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FollowersQuery, FollowersQueryVariables>(FollowersDocument, options);
      }
export function useFollowersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FollowersQuery, FollowersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FollowersQuery, FollowersQueryVariables>(FollowersDocument, options);
        }
export type FollowersQueryHookResult = ReturnType<typeof useFollowersQuery>;
export type FollowersLazyQueryHookResult = ReturnType<typeof useFollowersLazyQuery>;
export type FollowersQueryResult = Apollo.QueryResult<FollowersQuery, FollowersQueryVariables>;
export const FollowingDocument = gql`
    query Following($request: FollowingRequest!) {
  following(request: $request) {
    items {
      profile {
        ...ProfileFields
        isFollowedByMe
      }
      totalAmountOfTimesFollowing
    }
    pageInfo {
      next
      totalCount
    }
  }
}
    ${ProfileFieldsFragmentDoc}`;

/**
 * __useFollowingQuery__
 *
 * To run a query within a React component, call `useFollowingQuery` and pass it any options that fit your needs.
 * When your component renders, `useFollowingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFollowingQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useFollowingQuery(baseOptions: Apollo.QueryHookOptions<FollowingQuery, FollowingQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FollowingQuery, FollowingQueryVariables>(FollowingDocument, options);
      }
export function useFollowingLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FollowingQuery, FollowingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FollowingQuery, FollowingQueryVariables>(FollowingDocument, options);
        }
export type FollowingQueryHookResult = ReturnType<typeof useFollowingQuery>;
export type FollowingLazyQueryHookResult = ReturnType<typeof useFollowingLazyQuery>;
export type FollowingQueryResult = Apollo.QueryResult<FollowingQuery, FollowingQueryVariables>;
export const GenerateModuleCurrencyApprovalDataDocument = gql`
    query GenerateModuleCurrencyApprovalData($request: GenerateModuleCurrencyApprovalDataRequest!) {
  generateModuleCurrencyApprovalData(request: $request) {
    to
    from
    data
  }
}
    `;

/**
 * __useGenerateModuleCurrencyApprovalDataQuery__
 *
 * To run a query within a React component, call `useGenerateModuleCurrencyApprovalDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useGenerateModuleCurrencyApprovalDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGenerateModuleCurrencyApprovalDataQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useGenerateModuleCurrencyApprovalDataQuery(baseOptions: Apollo.QueryHookOptions<GenerateModuleCurrencyApprovalDataQuery, GenerateModuleCurrencyApprovalDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GenerateModuleCurrencyApprovalDataQuery, GenerateModuleCurrencyApprovalDataQueryVariables>(GenerateModuleCurrencyApprovalDataDocument, options);
      }
export function useGenerateModuleCurrencyApprovalDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GenerateModuleCurrencyApprovalDataQuery, GenerateModuleCurrencyApprovalDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GenerateModuleCurrencyApprovalDataQuery, GenerateModuleCurrencyApprovalDataQueryVariables>(GenerateModuleCurrencyApprovalDataDocument, options);
        }
export type GenerateModuleCurrencyApprovalDataQueryHookResult = ReturnType<typeof useGenerateModuleCurrencyApprovalDataQuery>;
export type GenerateModuleCurrencyApprovalDataLazyQueryHookResult = ReturnType<typeof useGenerateModuleCurrencyApprovalDataLazyQuery>;
export type GenerateModuleCurrencyApprovalDataQueryResult = Apollo.QueryResult<GenerateModuleCurrencyApprovalDataQuery, GenerateModuleCurrencyApprovalDataQueryVariables>;
export const HasTxHashBeenIndexedDocument = gql`
    query HasTxHashBeenIndexed($request: HasTxHashBeenIndexedRequest!) {
  hasTxHashBeenIndexed(request: $request) {
    ... on TransactionIndexedResult {
      metadataStatus {
        status
      }
      txHash
      indexed
    }
    ... on TransactionError {
      reason
    }
  }
}
    `;

/**
 * __useHasTxHashBeenIndexedQuery__
 *
 * To run a query within a React component, call `useHasTxHashBeenIndexedQuery` and pass it any options that fit your needs.
 * When your component renders, `useHasTxHashBeenIndexedQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useHasTxHashBeenIndexedQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useHasTxHashBeenIndexedQuery(baseOptions: Apollo.QueryHookOptions<HasTxHashBeenIndexedQuery, HasTxHashBeenIndexedQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<HasTxHashBeenIndexedQuery, HasTxHashBeenIndexedQueryVariables>(HasTxHashBeenIndexedDocument, options);
      }
export function useHasTxHashBeenIndexedLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<HasTxHashBeenIndexedQuery, HasTxHashBeenIndexedQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<HasTxHashBeenIndexedQuery, HasTxHashBeenIndexedQueryVariables>(HasTxHashBeenIndexedDocument, options);
        }
export type HasTxHashBeenIndexedQueryHookResult = ReturnType<typeof useHasTxHashBeenIndexedQuery>;
export type HasTxHashBeenIndexedLazyQueryHookResult = ReturnType<typeof useHasTxHashBeenIndexedLazyQuery>;
export type HasTxHashBeenIndexedQueryResult = Apollo.QueryResult<HasTxHashBeenIndexedQuery, HasTxHashBeenIndexedQueryVariables>;
export const LensterStatsDocument = gql`
    query LensterStats {
  globalProtocolStats(request: {sources: "Lenster"}) {
    totalProfiles
    totalPosts
    totalBurntProfiles
    totalMirrors
    totalComments
    totalCollects
    totalFollows
  }
}
    `;

/**
 * __useLensterStatsQuery__
 *
 * To run a query within a React component, call `useLensterStatsQuery` and pass it any options that fit your needs.
 * When your component renders, `useLensterStatsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLensterStatsQuery({
 *   variables: {
 *   },
 * });
 */
export function useLensterStatsQuery(baseOptions?: Apollo.QueryHookOptions<LensterStatsQuery, LensterStatsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LensterStatsQuery, LensterStatsQueryVariables>(LensterStatsDocument, options);
      }
export function useLensterStatsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LensterStatsQuery, LensterStatsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LensterStatsQuery, LensterStatsQueryVariables>(LensterStatsDocument, options);
        }
export type LensterStatsQueryHookResult = ReturnType<typeof useLensterStatsQuery>;
export type LensterStatsLazyQueryHookResult = ReturnType<typeof useLensterStatsLazyQuery>;
export type LensterStatsQueryResult = Apollo.QueryResult<LensterStatsQuery, LensterStatsQueryVariables>;
export const LikesDocument = gql`
    query Likes($request: WhoReactedPublicationRequest!) {
  whoReactedPublication(request: $request) {
    items {
      reactionId
      profile {
        ...ProfileFields
        isFollowedByMe
      }
    }
    pageInfo {
      next
      totalCount
    }
  }
}
    ${ProfileFieldsFragmentDoc}`;

/**
 * __useLikesQuery__
 *
 * To run a query within a React component, call `useLikesQuery` and pass it any options that fit your needs.
 * When your component renders, `useLikesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLikesQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useLikesQuery(baseOptions: Apollo.QueryHookOptions<LikesQuery, LikesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LikesQuery, LikesQueryVariables>(LikesDocument, options);
      }
export function useLikesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LikesQuery, LikesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LikesQuery, LikesQueryVariables>(LikesDocument, options);
        }
export type LikesQueryHookResult = ReturnType<typeof useLikesQuery>;
export type LikesLazyQueryHookResult = ReturnType<typeof useLikesLazyQuery>;
export type LikesQueryResult = Apollo.QueryResult<LikesQuery, LikesQueryVariables>;
export const MirrorsDocument = gql`
    query Mirrors($request: ProfileQueryRequest!) {
  profiles(request: $request) {
    items {
      ...ProfileFields
      isFollowedByMe
    }
    pageInfo {
      next
      totalCount
    }
  }
}
    ${ProfileFieldsFragmentDoc}`;

/**
 * __useMirrorsQuery__
 *
 * To run a query within a React component, call `useMirrorsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMirrorsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMirrorsQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useMirrorsQuery(baseOptions: Apollo.QueryHookOptions<MirrorsQuery, MirrorsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MirrorsQuery, MirrorsQueryVariables>(MirrorsDocument, options);
      }
export function useMirrorsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MirrorsQuery, MirrorsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MirrorsQuery, MirrorsQueryVariables>(MirrorsDocument, options);
        }
export type MirrorsQueryHookResult = ReturnType<typeof useMirrorsQuery>;
export type MirrorsLazyQueryHookResult = ReturnType<typeof useMirrorsLazyQuery>;
export type MirrorsQueryResult = Apollo.QueryResult<MirrorsQuery, MirrorsQueryVariables>;
export const MutualFollowersDocument = gql`
    query MutualFollowers($request: MutualFollowersProfilesQueryRequest!) {
  mutualFollowersProfiles(request: $request) {
    items {
      handle
      name
      picture {
        ... on MediaSet {
          original {
            url
          }
        }
        ... on NftImage {
          uri
        }
      }
    }
    pageInfo {
      totalCount
    }
  }
}
    `;

/**
 * __useMutualFollowersQuery__
 *
 * To run a query within a React component, call `useMutualFollowersQuery` and pass it any options that fit your needs.
 * When your component renders, `useMutualFollowersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMutualFollowersQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useMutualFollowersQuery(baseOptions: Apollo.QueryHookOptions<MutualFollowersQuery, MutualFollowersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MutualFollowersQuery, MutualFollowersQueryVariables>(MutualFollowersDocument, options);
      }
export function useMutualFollowersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MutualFollowersQuery, MutualFollowersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MutualFollowersQuery, MutualFollowersQueryVariables>(MutualFollowersDocument, options);
        }
export type MutualFollowersQueryHookResult = ReturnType<typeof useMutualFollowersQuery>;
export type MutualFollowersLazyQueryHookResult = ReturnType<typeof useMutualFollowersLazyQuery>;
export type MutualFollowersQueryResult = Apollo.QueryResult<MutualFollowersQuery, MutualFollowersQueryVariables>;
export const MutualFollowersListDocument = gql`
    query MutualFollowersList($request: MutualFollowersProfilesQueryRequest!) {
  mutualFollowersProfiles(request: $request) {
    items {
      ...ProfileFields
      isFollowedByMe
    }
    pageInfo {
      next
      totalCount
    }
  }
}
    ${ProfileFieldsFragmentDoc}`;

/**
 * __useMutualFollowersListQuery__
 *
 * To run a query within a React component, call `useMutualFollowersListQuery` and pass it any options that fit your needs.
 * When your component renders, `useMutualFollowersListQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMutualFollowersListQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useMutualFollowersListQuery(baseOptions: Apollo.QueryHookOptions<MutualFollowersListQuery, MutualFollowersListQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MutualFollowersListQuery, MutualFollowersListQueryVariables>(MutualFollowersListDocument, options);
      }
export function useMutualFollowersListLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MutualFollowersListQuery, MutualFollowersListQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MutualFollowersListQuery, MutualFollowersListQueryVariables>(MutualFollowersListDocument, options);
        }
export type MutualFollowersListQueryHookResult = ReturnType<typeof useMutualFollowersListQuery>;
export type MutualFollowersListLazyQueryHookResult = ReturnType<typeof useMutualFollowersListLazyQuery>;
export type MutualFollowersListQueryResult = Apollo.QueryResult<MutualFollowersListQuery, MutualFollowersListQueryVariables>;
export const NftChallengeDocument = gql`
    query NFTChallenge($request: NftOwnershipChallengeRequest!) {
  nftOwnershipChallenge(request: $request) {
    id
    text
  }
}
    `;

/**
 * __useNftChallengeQuery__
 *
 * To run a query within a React component, call `useNftChallengeQuery` and pass it any options that fit your needs.
 * When your component renders, `useNftChallengeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNftChallengeQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useNftChallengeQuery(baseOptions: Apollo.QueryHookOptions<NftChallengeQuery, NftChallengeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NftChallengeQuery, NftChallengeQueryVariables>(NftChallengeDocument, options);
      }
export function useNftChallengeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NftChallengeQuery, NftChallengeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NftChallengeQuery, NftChallengeQueryVariables>(NftChallengeDocument, options);
        }
export type NftChallengeQueryHookResult = ReturnType<typeof useNftChallengeQuery>;
export type NftChallengeLazyQueryHookResult = ReturnType<typeof useNftChallengeLazyQuery>;
export type NftChallengeQueryResult = Apollo.QueryResult<NftChallengeQuery, NftChallengeQueryVariables>;
export const NftFeedDocument = gql`
    query NFTFeed($request: NFTsRequest!) {
  nfts(request: $request) {
    items {
      name
      collectionName
      contractAddress
      tokenId
      chainId
      originalContent {
        uri
        animatedUrl
      }
    }
    pageInfo {
      next
      totalCount
    }
  }
}
    `;

/**
 * __useNftFeedQuery__
 *
 * To run a query within a React component, call `useNftFeedQuery` and pass it any options that fit your needs.
 * When your component renders, `useNftFeedQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNftFeedQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useNftFeedQuery(baseOptions: Apollo.QueryHookOptions<NftFeedQuery, NftFeedQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NftFeedQuery, NftFeedQueryVariables>(NftFeedDocument, options);
      }
export function useNftFeedLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NftFeedQuery, NftFeedQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NftFeedQuery, NftFeedQueryVariables>(NftFeedDocument, options);
        }
export type NftFeedQueryHookResult = ReturnType<typeof useNftFeedQuery>;
export type NftFeedLazyQueryHookResult = ReturnType<typeof useNftFeedLazyQuery>;
export type NftFeedQueryResult = Apollo.QueryResult<NftFeedQuery, NftFeedQueryVariables>;
export const NotificationCountDocument = gql`
    query NotificationCount($request: NotificationRequest!) {
  notifications(request: $request) {
    pageInfo {
      totalCount
    }
  }
}
    `;

/**
 * __useNotificationCountQuery__
 *
 * To run a query within a React component, call `useNotificationCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useNotificationCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNotificationCountQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useNotificationCountQuery(baseOptions: Apollo.QueryHookOptions<NotificationCountQuery, NotificationCountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NotificationCountQuery, NotificationCountQueryVariables>(NotificationCountDocument, options);
      }
export function useNotificationCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NotificationCountQuery, NotificationCountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NotificationCountQuery, NotificationCountQueryVariables>(NotificationCountDocument, options);
        }
export type NotificationCountQueryHookResult = ReturnType<typeof useNotificationCountQuery>;
export type NotificationCountLazyQueryHookResult = ReturnType<typeof useNotificationCountLazyQuery>;
export type NotificationCountQueryResult = Apollo.QueryResult<NotificationCountQuery, NotificationCountQueryVariables>;
export const NotificationsDocument = gql`
    query Notifications($request: NotificationRequest!) {
  notifications(request: $request) {
    items {
      ... on NewFollowerNotification {
        notificationId
        wallet {
          address
          defaultProfile {
            ...ProfileFields
          }
        }
        createdAt
      }
      ... on NewMentionNotification {
        notificationId
        mentionPublication {
          ... on Post {
            id
            profile {
              ...ProfileFields
            }
            metadata {
              content
            }
          }
          ... on Comment {
            id
            profile {
              ...ProfileFields
            }
            metadata {
              content
            }
          }
        }
        createdAt
      }
      ... on NewReactionNotification {
        notificationId
        profile {
          ...ProfileFields
        }
        publication {
          ... on Post {
            id
            metadata {
              content
            }
          }
          ... on Comment {
            id
            metadata {
              content
            }
          }
          ... on Mirror {
            id
            metadata {
              content
            }
          }
        }
        createdAt
      }
      ... on NewCommentNotification {
        notificationId
        profile {
          ...ProfileFields
        }
        comment {
          id
          metadata {
            content
          }
          commentOn {
            ... on Post {
              id
            }
            ... on Comment {
              id
            }
            ... on Mirror {
              id
            }
          }
        }
        createdAt
      }
      ... on NewMirrorNotification {
        notificationId
        profile {
          ...ProfileFields
        }
        publication {
          ... on Post {
            id
            metadata {
              content
            }
          }
          ... on Comment {
            id
            metadata {
              content
            }
          }
        }
        createdAt
      }
      ... on NewCollectNotification {
        notificationId
        wallet {
          address
          defaultProfile {
            ...ProfileFields
          }
        }
        collectedPublication {
          ... on Post {
            id
            metadata {
              content
            }
            collectModule {
              ...CollectModuleFields
            }
          }
          ... on Comment {
            id
            metadata {
              content
            }
            collectModule {
              ...CollectModuleFields
            }
          }
        }
        createdAt
      }
    }
    pageInfo {
      totalCount
      next
    }
  }
}
    ${ProfileFieldsFragmentDoc}
${CollectModuleFieldsFragmentDoc}`;

/**
 * __useNotificationsQuery__
 *
 * To run a query within a React component, call `useNotificationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useNotificationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useNotificationsQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useNotificationsQuery(baseOptions: Apollo.QueryHookOptions<NotificationsQuery, NotificationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<NotificationsQuery, NotificationsQueryVariables>(NotificationsDocument, options);
      }
export function useNotificationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<NotificationsQuery, NotificationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<NotificationsQuery, NotificationsQueryVariables>(NotificationsDocument, options);
        }
export type NotificationsQueryHookResult = ReturnType<typeof useNotificationsQuery>;
export type NotificationsLazyQueryHookResult = ReturnType<typeof useNotificationsLazyQuery>;
export type NotificationsQueryResult = Apollo.QueryResult<NotificationsQuery, NotificationsQueryVariables>;
export const ProfileDocument = gql`
    query Profile($request: SingleProfileQueryRequest!, $who: ProfileId) {
  profile(request: $request) {
    id
    handle
    ownedBy
    name
    bio
    metadata
    followNftAddress
    isFollowedByMe
    isFollowing(who: $who)
    attributes {
      key
      value
    }
    dispatcher {
      canUseRelay
    }
    onChainIdentity {
      proofOfHumanity
      sybilDotOrg {
        verified
        source {
          twitter {
            handle
          }
        }
      }
      ens {
        name
      }
      worldcoin {
        isHuman
      }
    }
    stats {
      totalFollowers
      totalFollowing
      totalPosts
      totalComments
      totalMirrors
    }
    picture {
      ... on MediaSet {
        original {
          url
        }
      }
      ... on NftImage {
        uri
      }
    }
    coverPicture {
      ... on MediaSet {
        original {
          url
        }
      }
    }
    followModule {
      __typename
    }
  }
}
    `;

/**
 * __useProfileQuery__
 *
 * To run a query within a React component, call `useProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfileQuery({
 *   variables: {
 *      request: // value for 'request'
 *      who: // value for 'who'
 *   },
 * });
 */
export function useProfileQuery(baseOptions: Apollo.QueryHookOptions<ProfileQuery, ProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProfileQuery, ProfileQueryVariables>(ProfileDocument, options);
      }
export function useProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProfileQuery, ProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProfileQuery, ProfileQueryVariables>(ProfileDocument, options);
        }
export type ProfileQueryHookResult = ReturnType<typeof useProfileQuery>;
export type ProfileLazyQueryHookResult = ReturnType<typeof useProfileLazyQuery>;
export type ProfileQueryResult = Apollo.QueryResult<ProfileQuery, ProfileQueryVariables>;
export const ProfileAddressDocument = gql`
    query ProfileAddress($request: SingleProfileQueryRequest!) {
  profile(request: $request) {
    id
    ownedBy
  }
}
    `;

/**
 * __useProfileAddressQuery__
 *
 * To run a query within a React component, call `useProfileAddressQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfileAddressQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfileAddressQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useProfileAddressQuery(baseOptions: Apollo.QueryHookOptions<ProfileAddressQuery, ProfileAddressQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProfileAddressQuery, ProfileAddressQueryVariables>(ProfileAddressDocument, options);
      }
export function useProfileAddressLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProfileAddressQuery, ProfileAddressQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProfileAddressQuery, ProfileAddressQueryVariables>(ProfileAddressDocument, options);
        }
export type ProfileAddressQueryHookResult = ReturnType<typeof useProfileAddressQuery>;
export type ProfileAddressLazyQueryHookResult = ReturnType<typeof useProfileAddressLazyQuery>;
export type ProfileAddressQueryResult = Apollo.QueryResult<ProfileAddressQuery, ProfileAddressQueryVariables>;
export const ProfileFeedDocument = gql`
    query ProfileFeed($request: PublicationsQueryRequest!, $reactionRequest: ReactionFieldResolverRequest, $profileId: ProfileId) {
  publications(request: $request) {
    items {
      ... on Post {
        ...PostFields
      }
      ... on Comment {
        ...CommentFields
      }
      ... on Mirror {
        ...MirrorFields
      }
    }
    pageInfo {
      totalCount
      next
    }
  }
}
    ${PostFieldsFragmentDoc}
${CommentFieldsFragmentDoc}
${MirrorFieldsFragmentDoc}`;

/**
 * __useProfileFeedQuery__
 *
 * To run a query within a React component, call `useProfileFeedQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfileFeedQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfileFeedQuery({
 *   variables: {
 *      request: // value for 'request'
 *      reactionRequest: // value for 'reactionRequest'
 *      profileId: // value for 'profileId'
 *   },
 * });
 */
export function useProfileFeedQuery(baseOptions: Apollo.QueryHookOptions<ProfileFeedQuery, ProfileFeedQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProfileFeedQuery, ProfileFeedQueryVariables>(ProfileFeedDocument, options);
      }
export function useProfileFeedLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProfileFeedQuery, ProfileFeedQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProfileFeedQuery, ProfileFeedQueryVariables>(ProfileFeedDocument, options);
        }
export type ProfileFeedQueryHookResult = ReturnType<typeof useProfileFeedQuery>;
export type ProfileFeedLazyQueryHookResult = ReturnType<typeof useProfileFeedLazyQuery>;
export type ProfileFeedQueryResult = Apollo.QueryResult<ProfileFeedQuery, ProfileFeedQueryVariables>;
export const ProfileSettingsDocument = gql`
    query ProfileSettings($request: SingleProfileQueryRequest!) {
  profile(request: $request) {
    id
    handle
    name
    bio
    attributes {
      traitType
      key
      value
    }
    coverPicture {
      ... on MediaSet {
        original {
          url
        }
      }
    }
    picture {
      ... on MediaSet {
        original {
          url
        }
      }
      ... on NftImage {
        uri
        tokenId
        contractAddress
      }
    }
  }
}
    `;

/**
 * __useProfileSettingsQuery__
 *
 * To run a query within a React component, call `useProfileSettingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfileSettingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfileSettingsQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useProfileSettingsQuery(baseOptions: Apollo.QueryHookOptions<ProfileSettingsQuery, ProfileSettingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProfileSettingsQuery, ProfileSettingsQueryVariables>(ProfileSettingsDocument, options);
      }
export function useProfileSettingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProfileSettingsQuery, ProfileSettingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProfileSettingsQuery, ProfileSettingsQueryVariables>(ProfileSettingsDocument, options);
        }
export type ProfileSettingsQueryHookResult = ReturnType<typeof useProfileSettingsQuery>;
export type ProfileSettingsLazyQueryHookResult = ReturnType<typeof useProfileSettingsLazyQuery>;
export type ProfileSettingsQueryResult = Apollo.QueryResult<ProfileSettingsQuery, ProfileSettingsQueryVariables>;
export const ProfilesDocument = gql`
    query Profiles($request: ProfileQueryRequest!) {
  profiles(request: $request) {
    items {
      ...ProfileFields
      isDefault
      isFollowedByMe
    }
    pageInfo {
      next
      totalCount
    }
  }
}
    ${ProfileFieldsFragmentDoc}`;

/**
 * __useProfilesQuery__
 *
 * To run a query within a React component, call `useProfilesQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfilesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfilesQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useProfilesQuery(baseOptions: Apollo.QueryHookOptions<ProfilesQuery, ProfilesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProfilesQuery, ProfilesQueryVariables>(ProfilesDocument, options);
      }
export function useProfilesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProfilesQuery, ProfilesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProfilesQuery, ProfilesQueryVariables>(ProfilesDocument, options);
        }
export type ProfilesQueryHookResult = ReturnType<typeof useProfilesQuery>;
export type ProfilesLazyQueryHookResult = ReturnType<typeof useProfilesLazyQuery>;
export type ProfilesQueryResult = Apollo.QueryResult<ProfilesQuery, ProfilesQueryVariables>;
export const PublicationDocument = gql`
    query Publication($request: PublicationQueryRequest!, $reactionRequest: ReactionFieldResolverRequest, $profileId: ProfileId) {
  publication(request: $request) {
    ... on Post {
      ...PostFields
      onChainContentURI
      collectNftAddress
      profile {
        isFollowedByMe
      }
      referenceModule {
        __typename
      }
    }
    ... on Comment {
      ...CommentFields
      onChainContentURI
      collectNftAddress
      profile {
        isFollowedByMe
      }
      referenceModule {
        __typename
      }
    }
    ... on Mirror {
      ...MirrorFields
      onChainContentURI
      collectNftAddress
      profile {
        isFollowedByMe
      }
      referenceModule {
        __typename
      }
    }
  }
}
    ${PostFieldsFragmentDoc}
${CommentFieldsFragmentDoc}
${MirrorFieldsFragmentDoc}`;

/**
 * __usePublicationQuery__
 *
 * To run a query within a React component, call `usePublicationQuery` and pass it any options that fit your needs.
 * When your component renders, `usePublicationQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePublicationQuery({
 *   variables: {
 *      request: // value for 'request'
 *      reactionRequest: // value for 'reactionRequest'
 *      profileId: // value for 'profileId'
 *   },
 * });
 */
export function usePublicationQuery(baseOptions: Apollo.QueryHookOptions<PublicationQuery, PublicationQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PublicationQuery, PublicationQueryVariables>(PublicationDocument, options);
      }
export function usePublicationLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PublicationQuery, PublicationQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PublicationQuery, PublicationQueryVariables>(PublicationDocument, options);
        }
export type PublicationQueryHookResult = ReturnType<typeof usePublicationQuery>;
export type PublicationLazyQueryHookResult = ReturnType<typeof usePublicationLazyQuery>;
export type PublicationQueryResult = Apollo.QueryResult<PublicationQuery, PublicationQueryVariables>;
export const PublicationRevenueDocument = gql`
    query PublicationRevenue($request: PublicationRevenueQueryRequest!) {
  publicationRevenue(request: $request) {
    revenue {
      total {
        value
      }
    }
  }
}
    `;

/**
 * __usePublicationRevenueQuery__
 *
 * To run a query within a React component, call `usePublicationRevenueQuery` and pass it any options that fit your needs.
 * When your component renders, `usePublicationRevenueQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePublicationRevenueQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function usePublicationRevenueQuery(baseOptions: Apollo.QueryHookOptions<PublicationRevenueQuery, PublicationRevenueQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PublicationRevenueQuery, PublicationRevenueQueryVariables>(PublicationRevenueDocument, options);
      }
export function usePublicationRevenueLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PublicationRevenueQuery, PublicationRevenueQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PublicationRevenueQuery, PublicationRevenueQueryVariables>(PublicationRevenueDocument, options);
        }
export type PublicationRevenueQueryHookResult = ReturnType<typeof usePublicationRevenueQuery>;
export type PublicationRevenueLazyQueryHookResult = ReturnType<typeof usePublicationRevenueLazyQuery>;
export type PublicationRevenueQueryResult = Apollo.QueryResult<PublicationRevenueQuery, PublicationRevenueQueryVariables>;
export const RecommendedProfilesDocument = gql`
    query RecommendedProfiles($options: RecommendedProfileOptions) {
  recommendedProfiles(options: $options) {
    ...ProfileFields
    isFollowedByMe
  }
}
    ${ProfileFieldsFragmentDoc}`;

/**
 * __useRecommendedProfilesQuery__
 *
 * To run a query within a React component, call `useRecommendedProfilesQuery` and pass it any options that fit your needs.
 * When your component renders, `useRecommendedProfilesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRecommendedProfilesQuery({
 *   variables: {
 *      options: // value for 'options'
 *   },
 * });
 */
export function useRecommendedProfilesQuery(baseOptions?: Apollo.QueryHookOptions<RecommendedProfilesQuery, RecommendedProfilesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RecommendedProfilesQuery, RecommendedProfilesQueryVariables>(RecommendedProfilesDocument, options);
      }
export function useRecommendedProfilesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RecommendedProfilesQuery, RecommendedProfilesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RecommendedProfilesQuery, RecommendedProfilesQueryVariables>(RecommendedProfilesDocument, options);
        }
export type RecommendedProfilesQueryHookResult = ReturnType<typeof useRecommendedProfilesQuery>;
export type RecommendedProfilesLazyQueryHookResult = ReturnType<typeof useRecommendedProfilesLazyQuery>;
export type RecommendedProfilesQueryResult = Apollo.QueryResult<RecommendedProfilesQuery, RecommendedProfilesQueryVariables>;
export const RelevantPeopleDocument = gql`
    query RelevantPeople($request: ProfileQueryRequest!) {
  profiles(request: $request) {
    items {
      ...ProfileFields
      isFollowedByMe
    }
  }
}
    ${ProfileFieldsFragmentDoc}`;

/**
 * __useRelevantPeopleQuery__
 *
 * To run a query within a React component, call `useRelevantPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useRelevantPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRelevantPeopleQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useRelevantPeopleQuery(baseOptions: Apollo.QueryHookOptions<RelevantPeopleQuery, RelevantPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RelevantPeopleQuery, RelevantPeopleQueryVariables>(RelevantPeopleDocument, options);
      }
export function useRelevantPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RelevantPeopleQuery, RelevantPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RelevantPeopleQuery, RelevantPeopleQueryVariables>(RelevantPeopleDocument, options);
        }
export type RelevantPeopleQueryHookResult = ReturnType<typeof useRelevantPeopleQuery>;
export type RelevantPeopleLazyQueryHookResult = ReturnType<typeof useRelevantPeopleLazyQuery>;
export type RelevantPeopleQueryResult = Apollo.QueryResult<RelevantPeopleQuery, RelevantPeopleQueryVariables>;
export const SearchProfilesDocument = gql`
    query SearchProfiles($request: SearchQueryRequest!) {
  search(request: $request) {
    ... on ProfileSearchResult {
      items {
        ...ProfileFields
      }
      pageInfo {
        next
        totalCount
      }
    }
  }
}
    ${ProfileFieldsFragmentDoc}`;

/**
 * __useSearchProfilesQuery__
 *
 * To run a query within a React component, call `useSearchProfilesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchProfilesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchProfilesQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useSearchProfilesQuery(baseOptions: Apollo.QueryHookOptions<SearchProfilesQuery, SearchProfilesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchProfilesQuery, SearchProfilesQueryVariables>(SearchProfilesDocument, options);
      }
export function useSearchProfilesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchProfilesQuery, SearchProfilesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchProfilesQuery, SearchProfilesQueryVariables>(SearchProfilesDocument, options);
        }
export type SearchProfilesQueryHookResult = ReturnType<typeof useSearchProfilesQuery>;
export type SearchProfilesLazyQueryHookResult = ReturnType<typeof useSearchProfilesLazyQuery>;
export type SearchProfilesQueryResult = Apollo.QueryResult<SearchProfilesQuery, SearchProfilesQueryVariables>;
export const SearchPublicationsDocument = gql`
    query SearchPublications($request: SearchQueryRequest!, $reactionRequest: ReactionFieldResolverRequest, $profileId: ProfileId) {
  search(request: $request) {
    ... on PublicationSearchResult {
      items {
        ... on Post {
          ...PostFields
        }
        ... on Comment {
          ...CommentFields
        }
      }
      pageInfo {
        next
        totalCount
      }
    }
  }
}
    ${PostFieldsFragmentDoc}
${CommentFieldsFragmentDoc}`;

/**
 * __useSearchPublicationsQuery__
 *
 * To run a query within a React component, call `useSearchPublicationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchPublicationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchPublicationsQuery({
 *   variables: {
 *      request: // value for 'request'
 *      reactionRequest: // value for 'reactionRequest'
 *      profileId: // value for 'profileId'
 *   },
 * });
 */
export function useSearchPublicationsQuery(baseOptions: Apollo.QueryHookOptions<SearchPublicationsQuery, SearchPublicationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchPublicationsQuery, SearchPublicationsQueryVariables>(SearchPublicationsDocument, options);
      }
export function useSearchPublicationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchPublicationsQuery, SearchPublicationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchPublicationsQuery, SearchPublicationsQueryVariables>(SearchPublicationsDocument, options);
        }
export type SearchPublicationsQueryHookResult = ReturnType<typeof useSearchPublicationsQuery>;
export type SearchPublicationsLazyQueryHookResult = ReturnType<typeof useSearchPublicationsLazyQuery>;
export type SearchPublicationsQueryResult = Apollo.QueryResult<SearchPublicationsQuery, SearchPublicationsQueryVariables>;
export const SuperFollowDocument = gql`
    query SuperFollow($request: SingleProfileQueryRequest!) {
  profile(request: $request) {
    id
    followModule {
      ... on FeeFollowModuleSettings {
        amount {
          asset {
            name
            symbol
            decimals
            address
          }
          value
        }
        recipient
      }
    }
  }
}
    `;

/**
 * __useSuperFollowQuery__
 *
 * To run a query within a React component, call `useSuperFollowQuery` and pass it any options that fit your needs.
 * When your component renders, `useSuperFollowQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSuperFollowQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useSuperFollowQuery(baseOptions: Apollo.QueryHookOptions<SuperFollowQuery, SuperFollowQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SuperFollowQuery, SuperFollowQueryVariables>(SuperFollowDocument, options);
      }
export function useSuperFollowLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SuperFollowQuery, SuperFollowQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SuperFollowQuery, SuperFollowQueryVariables>(SuperFollowDocument, options);
        }
export type SuperFollowQueryHookResult = ReturnType<typeof useSuperFollowQuery>;
export type SuperFollowLazyQueryHookResult = ReturnType<typeof useSuperFollowLazyQuery>;
export type SuperFollowQueryResult = Apollo.QueryResult<SuperFollowQuery, SuperFollowQueryVariables>;
export const SuperfluidInflowsDocument = gql`
    query SuperfluidInflows($id: ID = "") {
  account(id: $id) {
    createdAtTimestamp
    createdAtBlockNumber
    isSuperApp
    updatedAtBlockNumber
    updatedAtTimestamp
    inflows {
      id
      token {
        name
        symbol
        underlyingToken {
          name
          symbol
        }
        id
        decimals
      }
      deposit
      currentFlowRate
      sender {
        id
      }
      createdAtTimestamp
    }
  }
}
    `;

/**
 * __useSuperfluidInflowsQuery__
 *
 * To run a query within a React component, call `useSuperfluidInflowsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSuperfluidInflowsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSuperfluidInflowsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSuperfluidInflowsQuery(baseOptions?: Apollo.QueryHookOptions<SuperfluidInflowsQuery, SuperfluidInflowsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SuperfluidInflowsQuery, SuperfluidInflowsQueryVariables>(SuperfluidInflowsDocument, options);
      }
export function useSuperfluidInflowsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SuperfluidInflowsQuery, SuperfluidInflowsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SuperfluidInflowsQuery, SuperfluidInflowsQueryVariables>(SuperfluidInflowsDocument, options);
        }
export type SuperfluidInflowsQueryHookResult = ReturnType<typeof useSuperfluidInflowsQuery>;
export type SuperfluidInflowsLazyQueryHookResult = ReturnType<typeof useSuperfluidInflowsLazyQuery>;
export type SuperfluidInflowsQueryResult = Apollo.QueryResult<SuperfluidInflowsQuery, SuperfluidInflowsQueryVariables>;
export const TimelineDocument = gql`
    query Timeline($request: FeedRequest!, $reactionRequest: ReactionFieldResolverRequest, $profileId: ProfileId) {
  feed(request: $request) {
    items {
      root {
        ... on Post {
          ...PostFields
        }
        ... on Comment {
          ...CommentFields
        }
      }
      electedMirror {
        mirrorId
        profile {
          ...ProfileFields
        }
        timestamp
      }
      mirrors {
        profile {
          ...ProfileFields
        }
        timestamp
      }
      collects {
        profile {
          ...ProfileFields
        }
        timestamp
      }
      reactions {
        profile {
          ...ProfileFields
        }
        reaction
        timestamp
      }
      comments {
        ...CommentFields
      }
    }
    pageInfo {
      next
      totalCount
    }
  }
}
    ${PostFieldsFragmentDoc}
${CommentFieldsFragmentDoc}
${ProfileFieldsFragmentDoc}`;

/**
 * __useTimelineQuery__
 *
 * To run a query within a React component, call `useTimelineQuery` and pass it any options that fit your needs.
 * When your component renders, `useTimelineQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTimelineQuery({
 *   variables: {
 *      request: // value for 'request'
 *      reactionRequest: // value for 'reactionRequest'
 *      profileId: // value for 'profileId'
 *   },
 * });
 */
export function useTimelineQuery(baseOptions: Apollo.QueryHookOptions<TimelineQuery, TimelineQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TimelineQuery, TimelineQueryVariables>(TimelineDocument, options);
      }
export function useTimelineLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TimelineQuery, TimelineQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TimelineQuery, TimelineQueryVariables>(TimelineDocument, options);
        }
export type TimelineQueryHookResult = ReturnType<typeof useTimelineQuery>;
export type TimelineLazyQueryHookResult = ReturnType<typeof useTimelineLazyQuery>;
export type TimelineQueryResult = Apollo.QueryResult<TimelineQuery, TimelineQueryVariables>;
export const TrendingDocument = gql`
    query Trending($request: AllPublicationsTagsRequest!) {
  allPublicationsTags(request: $request) {
    items {
      tag
      total
    }
  }
}
    `;

/**
 * __useTrendingQuery__
 *
 * To run a query within a React component, call `useTrendingQuery` and pass it any options that fit your needs.
 * When your component renders, `useTrendingQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTrendingQuery({
 *   variables: {
 *      request: // value for 'request'
 *   },
 * });
 */
export function useTrendingQuery(baseOptions: Apollo.QueryHookOptions<TrendingQuery, TrendingQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TrendingQuery, TrendingQueryVariables>(TrendingDocument, options);
      }
export function useTrendingLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TrendingQuery, TrendingQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TrendingQuery, TrendingQueryVariables>(TrendingDocument, options);
        }
export type TrendingQueryHookResult = ReturnType<typeof useTrendingQuery>;
export type TrendingLazyQueryHookResult = ReturnType<typeof useTrendingLazyQuery>;
export type TrendingQueryResult = Apollo.QueryResult<TrendingQuery, TrendingQueryVariables>;
export const UserProfilesDocument = gql`
    query UserProfiles($ownedBy: [EthereumAddress!]) {
  profiles(request: {ownedBy: $ownedBy}) {
    items {
      ...ProfileFields
      stats {
        totalFollowing
      }
      isDefault
      dispatcher {
        canUseRelay
      }
    }
  }
  userSigNonces {
    lensHubOnChainSigNonce
  }
}
    ${ProfileFieldsFragmentDoc}`;

/**
 * __useUserProfilesQuery__
 *
 * To run a query within a React component, call `useUserProfilesQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserProfilesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserProfilesQuery({
 *   variables: {
 *      ownedBy: // value for 'ownedBy'
 *   },
 * });
 */
export function useUserProfilesQuery(baseOptions?: Apollo.QueryHookOptions<UserProfilesQuery, UserProfilesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserProfilesQuery, UserProfilesQueryVariables>(UserProfilesDocument, options);
      }
export function useUserProfilesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserProfilesQuery, UserProfilesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserProfilesQuery, UserProfilesQueryVariables>(UserProfilesDocument, options);
        }
export type UserProfilesQueryHookResult = ReturnType<typeof useUserProfilesQuery>;
export type UserProfilesLazyQueryHookResult = ReturnType<typeof useUserProfilesLazyQuery>;
export type UserProfilesQueryResult = Apollo.QueryResult<UserProfilesQuery, UserProfilesQueryVariables>;